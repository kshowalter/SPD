(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports={

    "NEC 250.122_header": ["Amp","AWG"],
    "NEC 250.122": {
        "15":"14",
        "20":"12",
        "30":"10",
        "40":"10",
        "60":"10",
        "100":"8",
        "200":"6",
        "300":"4",
        "400":"3",
        "500":"2",
        "600":"1",
        "800":"1/0",
        "1000":"2/0",
        "1200":"3/0",
        "1600":"4/0",
        "2000":"250",
        "2500":"350",
        "3000":"400",
        "4000":"500",
        "5000":"700",
        "6000":"800"
    },

    "NEC T690.7_header": ["Ambient Temperature (C)", "Correction Factor"],
    "NEC T690.7": {
        "25 to 20":"1.02",
        "19 to 15":"1.04",
        "15 to 10":"1.06",
        "9 to 5":"1.08",
        "4 to 0":"1.10",
        "-1 to -5":"1.12",
        "-6 to -10":"1.14",
        "-11 to -15":"1.16",
        "-16 to -20":"1.18",
        "-21 to -25":"1.20",
        "-26 to -30":"1.21",
        "-31 to -35":"1.23",
        "-36 to -40":"1.25"
    },

    "Ch 9 Table 8 Conductor Properties_header": ["Size","ohm/kft"],
    "Ch 9 Table 8 Conductor Properties": {
        "#01":" 0.154",
        "#01/0":"0.122",
        "#02":"0.194",
        "#02/0":"0.0967",
        "#03":"0.245",
        "#03/0":"0.0766",
        "#04":"0.308",
        "#04/0":"0.0608",
        "#06":"0.491",
        "#08":"0.778",
        "#10":"1.24",
        "#12":"1.98",
        "#14":"3.14"
    }
}

},{}],2:[function(require,module,exports){
'use strict';

var kontainer = {
    ref: function(refString){
        if( typeof refString === 'undefined' ){
            return this.refString;
        } else {
            this.refString = refString;
            this.refArray = refString.split('.');
            if( typeof this.object !== 'undefined'){
                this.ready = true;
            } else {
                this.ready = false;
            }
        }
        return this;
    },
    obj: function(obj){
        if( typeof obj === 'undefined' ){
            return this.object;
        } else {
            this.object = obj;
            if( typeof this.refString !== 'undefined'){
                this.ready = true;
            } else {
                this.ready = false;
            }
        }
        return this;
    },
    set: function(input){
        if( typeof this.object === 'undefined' || typeof this.refString === 'undefined' ){
            return false;
        }
        var parent = this.object;
        var last_level = this.refArray[this.refArray.length-1];

        this.refArray.forEach(function(level_name,i){
            if( typeof parent[level_name] === 'undefined' ) {
                parent[level_name] = {};
            }
            if( level_name !== last_level ){
                parent = parent[level_name];
            }
        });
        parent[last_level] = input;
        //console.log('setting:', input, this.get(), this.refString );
        return parent[last_level];
    },
    get: function(){
        var level = this.object;
        this.refArray.forEach(function(level_name,i){
            if( typeof level[level_name] === 'undefined' ) {
                return false;
            }
            level = level[level_name];
        });
        return level;
    },
};

module.exports = kontainer;

},{}],3:[function(require,module,exports){
'use strict';
var kontainer = require('../lib/kontainer');

var f = {};


f.setup_body = function(title, sections){
    document.title = title;
    var body = document.body;
    var status_bar = document.createElement('div');
    status_bar.id = 'status';
    status_bar.innerHTML = 'loading status...';
    body.insertBefore(status_bar, body.firstChild);
};

f.pad_zero = function(num, size){
    var s = '000000000' + num;
    return s.substr(s.length-size);
};

f.uptime = function(boot_time){
    var uptime_seconds_total = moment().diff(boot_time, 'seconds');
    var uptime_hours = Math.floor(  uptime_seconds_total /(60*60) );
    var minutes_left = uptime_seconds_total %(60*60);
    var uptime_minutes = f.pad_zero( Math.floor(  minutes_left /60 ), 2 );
    var uptime_seconds = f.pad_zero( (minutes_left % 60), 2 );
    return uptime_hours +":"+ uptime_minutes +":"+ uptime_seconds;
};

f.update_status_bar = function(status_id, boot_time, string) {
    var status_div = document.getElementById(status_id);
    status_div.innerHTML = string;
    status_div.innerHTML += ' | ';

    var clock = document.createElement('span');
    clock.innerHTML = moment().format('YYYY-MM-DD HH:mm:ss');

    var uptime = document.createElement('span');
    uptime.innerHTML = 'Uptime: ' + f.uptime(boot_time);

    status_div.appendChild(clock);
    status_div.innerHTML += ' | ';
    status_div.appendChild(uptime);
    status_div.innerHTML += ' | ';
};


f.obj_names = function( object ) {
    if( object !== undefined ) {
        var a = [];
        for( var id in object ) {
            if( object.hasOwnProperty(id) )  {
                a.push(id);
            }
        }
        return a;
    }
};

f.object_defined = function(object){
    //console.log(object);
    for( var key in object ){
        if( object.hasOwnProperty(key) ){
            //console.log(key);
            if( object[key] === null || object[key] === undefined ) return false;
        }
    }
    return true;
};

f.section_defined = function(settings, section_name){
    //console.log("-"+section_name);
    //var input_section = g.inputs[section_name];
    //var output_section = g.system[section_name];
    var output_section = settings.user_input[section_name];
    for( var key in output_section ){
        if( output_section.hasOwnProperty(key) ){
            //console.log(key);

            if( output_section[key] === undefined || output_section[key] === null ) {
                return false;
            }
        }
    }
    return true;
};

f.nullToObject = function(object){
    for( var key in object ){
        if( object.hasOwnProperty(key) ){
            if( object[key] === null ){
                object[key] = {};
            } else if( typeof object[key] === 'object' ) {
                object[key] = f.nullToObject(object[key]);
            }
        }
    }
    return object;
};

f.blank_copy = function(object){
    var newObject = {};
    for( var key in object ){
        if( object.hasOwnProperty(key) ){
            if( object[key].constructor === Object ) {
                newObject[key] = {};
                for( var key2 in object[key] ){
                    if( object[key].hasOwnProperty(key2) ){
                        newObject[key][key2] = null;
                    }
                }
            } else {
                newObject[key] = null;
            }
        }
    }
    return newObject;
};

f.add_sections = function(inputs){
    var blank_user_input = {};
    for( var section_name in inputs ){
        if( inputs.hasOwnProperty(section_name) ){
            if( inputs[section_name].constructor === Object ) {
                blank_user_input[section_name] = {};
                for( var name in inputs[section_name] ){
                    if( inputs[section_name].hasOwnProperty(name) ){
                        blank_user_input[section_name][name] = null;
                    }
                }
            } else {
                console.log('error: section not object');
            }
        }
    }
    return blank_user_input;

};

f.blank_clean_copy = function(object){
    var newObject = {};
    for( var key in object ){
        if( object.hasOwnProperty(key) ){
            if( object[key].constructor === Object ) {
                newObject[key] = {};
                for( var key2 in object[key] ){
                    if( object[key].hasOwnProperty(key2) ){
                        var clean_key = f.clean_name(key2);
                        newObject[key][clean_key] = null;
                    }
                }
            } else {
                newObject[key] = null;
            }
        }
    }
    return newObject;
};

//f.merge_objects = function merge_objects(object1, object2){
//    for( var key in object1 ){
//        if( object1.hasOwnProperty(key) ){
//            //if( key === 'make' ) console.log(key, object1, typeof object1[key], typeof object2[key]);
//            //console.log(key, object1, typeof object1[key], typeof object2[key]);
//            if( object1[key] && object1[key].constructor === Object ) {
//                if( object2[key] === undefined ) object2[key] = {};
//                merge_objects( object1[key], object2[key] );
//            } else {
//                if( object2[key] === undefined ) object2[key] = null;
//            }
//        }
//    }
//};

f.merge_objects = function merge_objects(object1, object2){
    for( var key in object1 ){
        if( object1.hasOwnProperty(key) ){
            //if( key === 'make' ) console.log(key, object1, typeof object1[key], typeof object2[key]);
            //console.log(key, object1, typeof object1[key], typeof object2[key]);
            if( object1[key] && object1[key].constructor === Object ) {
                if( object2[key] === undefined ) object2[key] = {};
                merge_objects( object1[key], object2[key] );
            } else {
                object2[key] = object1[key];
            }
        }
    }
};

f.array_to_object = function(arr) {
    var r = {};
    for (var i = 0; i < arr.length; ++i)
        r[i] = arr[i];
    return r;
};

f.nan_check = function nan_check(object, path){
    if( path === undefined ) path = "";
    path = path+".";
    for( var key in object ){
        //console.log( "NaNcheck: "+path+key );

        if( object[key] && object[key].constructor === Array ) object[key] = f.array_to_object(object[key]);


        if(  object[key] && ( object.hasOwnProperty(key) || object[key] !== null )){
            if( object[key].constructor === Object ){
                //console.log( "  Object: "+path+key );
                nan_check( object[key], path+key );
            } else if( object[key] === NaN || object[key] === null ){
                console.log( "NaN: "+path+key );
            } else {
                //console.log( "Defined: "+path+key, object[key]);

            }
        }

    }
};

f.str_to_num = function str_to_num(input){
    var output;
    if(!isNaN(input)) output = Number(input);
    else output = input;
    return output;
};


f.pretty_word = function(name){
    return name.charAt(0).toUpperCase() + name.slice(1);
};

f.pretty_name = function(name){
    var l = name.split('_');
    l.forEach(function(name_seqment,i){
        l[i] = f.pretty_word(name_seqment);
    });
    var pretty = l.join(' ');

    return pretty;
};

f.pretty_names = function(object){
    var new_object = {};
    for( var key in object ){
        if( object.hasOwnProperty(key) ){
            var new_key = f.pretty_name(key);
            new_object[new_key] = object[key];
        }
    }
    return new_object;
};

f.clean_name = function(name){
    return name.split(' ')[0];
};


f.mk_drawer = function(title, content){
    var drawer_container = $('<div>')
                            .attr('class', 'drawer_container')
                            .attr('id', 'section_'+title);
                            //.attr('id', title );
    //drawer_container.get(0).style.display = display_type;
    var system_div = $('<div>').attr('class', 'title_bar')
        .attr('section_nom', title)
        .appendTo(drawer_container)
        /* jshint -W083 */
        .click(function(){
            var name = $(this).attr('section_nom');
            g.webpage.selections_manual_toggled[name] = true;
            $(this).parent().children('.drawer').children('.drawer_content').slideToggle('fast');
        });
    var system_title = $('<a>')
        .attr('class', 'title_bar_text')
        .attr('href', '#')
        .text(f.pretty_name(title))
        .appendTo(system_div);

    var drawer = $('<div>').attr('class', 'drawer').appendTo(drawer_container);
    content.attr('class', 'drawer_content').appendTo(drawer);


    return drawer_container;


};


f.add_drawers = function(settings, parent_container){
    for( var section_name in settings.inputs ){

        //$(this).trigger('click');
        var drawer_content = $('<div>');
        var user_input_container = $('<div>').attr('class', 'user_input_container').appendTo(drawer_content);
        drawer_content.append(
            $('<div>')
                .attr('class', 'svg_drawing_container')
        );



        for( var input_name in settings.inputs[section_name] ){
            var units;
            if( (settings.inputs[section_name][input_name] !== undefined) && (settings.inputs[section_name][input_name].units !== undefined) ) {
                units = "(" + settings.inputs[section_name][input_name].units + ")";
            } else {
                units = "";
            }
            var note;
            if( (settings.inputs[section_name][input_name] !== undefined) && (settings.inputs[section_name][input_name].note !== undefined) ) {
                note = settings.inputs[section_name][input_name].note;
            } else {
                note = false;
            }

            var user_input = $('<span>').attr('class', 'user_input').appendTo(user_input_container);
            var input_text = $('<span>').html(f.pretty_name(input_name) + ': ' + units ).appendTo(user_input);
            if( note ) input_text.attr('title', note);
            /*
            var selector = k$('selector')
                .setOptionsRef( 'inputs.' + section_name + '.' + input_name )
                .setRef( 'system.' + section_name + '.' + input_name )
                .appendTo(user_input);
            f.kelem_setup(selector, settings);
            //*/
            var selector = {
                system_ref: Object.create(kontainer).obj(g).ref('system.' + section_name + '.' + input_name),
                input_ref: Object.create(kontainer).obj(g).ref('user_input.' + section_name + '.' + input_name),
                list_ref: Object.create(kontainer).obj(g).ref('inputs.' + section_name + '.' + input_name + '.options'),
                interacted: false,
            };
            if( (settings.inputs[section_name][input_name] !== undefined) && (settings.inputs[section_name][input_name].type !== undefined) ) {
                selector.type = settings.inputs[section_name][input_name].type;
            } else {
                selector.type = 'select';
            }
            if( selector.type === 'select' ){
                selector.elem = $('<select>')
                    //.attr('class', 'selector')
                    .appendTo(user_input)
                    .get()[0];
                selector.value = function(){
                    //console.log( this.set_ref.refString, this.elem.selectedIndex );
                    //if( this.interacted )
                    if( this.elem.selectedIndex >= 0) return this.elem.options[this.elem.selectedIndex].value;
                    else return false;
                };
                f.selector_add_options(selector);

            } else if( selector.type === 'number_input' || selector.type === 'text_input'){
                selector.elem = $('<input>')
                    .attr('class', selector.type)
                    .attr('type', 'text')
                    .appendTo(user_input)
                    .get()[0];
                selector.value = function(){
                    //console.log( this.set_ref.refString, this.elem.selectedIndex );
                    //console.log( this.elem, this.elem.value );
                    //if( this.interacted )
                    //if( this.elem.selectedIndex >= 0) return this.elem.options[this.elem.selectedIndex].value;
                    //else return false;
                    return this.elem.value;
                };
                selector.elem.value = selector.input_ref.get();
            }
            $(selector.elem).change(function(event){
                settings.f.update();
            });
            settings.select_registry.push(selector);
            //$('</br>').appendTo(drawer_content);

        }



        var selection_container = f.mk_drawer(section_name, drawer_content);

        selection_container.appendTo(parent_container);

        $(selection_container).children('.drawer').children('.drawer_content').slideUp('fast');
    }
};

f.selector_add_options = function(selector){
    var list = selector.list_ref.get();
    if( list && list.constructor === Object ) {
        //console.log('"list"', list);
        list = f.obj_names(list);
    }
    selector.elem.innerHTML = "";
    if( list instanceof Array ){
        var current_value = selector.input_ref.get();
        $('<option>').attr('selected',true).attr('disabled',true).attr('hidden',true).appendTo(selector.elem);

        list.forEach(function(opt_name){
            //console.log(opt_name);
            var o = document.createElement('option');
            o.value = opt_name;
            if( current_value ){
                if( opt_name.toString() === current_value.toString() ) {
                    //console.log('found it:', opt_name);
                    o.selected = "selected";
                } else {
                    //console.log('does not match: ', opt_name, ",",  current_value, "." );
                }
                //o.setAttribute('class', 'selector_option');
            } else {
                //console.log('no current value')
            }
            o.innerHTML = opt_name;
            selector.elem.appendChild(o);
        });

    } else {
        //console.log('list not a list', list, select);
    }
};

f.add_options = function(select, array){
    array.forEach( function(option){
        $('<option>').attr( 'value', option ).text(option).appendTo(select);
    });
};


//f.add_params = function(settings, parent_container){
//    for( var section_name in settings.system ){
//        if( true || f.object_defined(settings.system[section_name]) ){
//            var selection_container = $('<div>').attr('class', 'param_section').attr('id', section_name ).appendTo(parent_container);
//            //selection_container.get(0).style.display = display_type;
//            var system_div = $('<div>')
//                .attr('class', 'title_line')
//                .appendTo(selection_container)
//                /* jshint -W083 */
//                .click(function(){
//                    $(this).parent().children('.drawer').children('.drawer_content').slideToggle('fast');
//                });
//            var system_title = $('<a>')
//                .attr('class', 'title_line_text')
//                .attr('href', '#')
//                .text(f.pretty_name(section_name))
//                .appendTo(system_div);
//            $(this).trigger('click');
//            var drawer = $('<div>').attr('class', '').appendTo(selection_container);
//            var drawer_content = $('<div>').attr('class', 'param_section_content').appendTo(drawer);
//            for( var input_name in settings.system[section_name] ){
//                $('<span>').html(f.pretty_name(input_name) + ': ').appendTo(drawer_content);
//                /*
//                var selector = k$('value')
//                    //.setOptionsRef( 'inputs.' + section_name + '.' + input_name )
//                    .setRef( 'system.' + section_name + '.' + input_name )
//                    .appendTo(drawer_content);
//                f.kelem_setup(selector, settings);
//                //*/
//                var value_kontainer = Object.create(kontainer)
//                    .obj(settings)
//                    .ref('system.' + section_name + '.' + input_name);
//                var $elem = $('<span>')
//                    .attr('class', '')
//                    .appendTo(drawer_content)
//                    .text(value_kontainer.get());
//                var value = {
//                    elem: $elem.get()[0],
//                    value_ref: value_kontainer
//                };
//                settings.value_registry.push(value);
//                $('</br>').appendTo(drawer_content);
//            }
//        }
//    }
//};
//
//f.update_values = function(settings){
//    settings.value_registry.forEach(function(value_item){
//        //console.log( value_item );
//        //console.log( value_item.elem.options );
//        //console.log( value_item.elem.selectedIndex );
//        if(value_item.elem.selectedIndex){
//            value_item.value = value_item.elem.options[value_item.elem.selectedIndex].value;
//            value_item.kontainer.set(value_item.value);
//
//        }
//    });
//};
//
//f.show_hide_params = function(page_sections, settings){
//    for( var list_name in page_sections ){
//        var id = '#'+list_name;
//        var section_name = list_name.split('_')[0];
//        var section = k$(id);
//        if( settings.status.sections[section_name].set ) section.show();
//        else section.hide();
//    }
//};

//f.show_hide_selections = function(settings, active_section_name){
//    $('#sectionSelector').val(active_section_name);
//    for( var list_name in settings.input ){
//        var id = '#'+list_name;
//        var section_name = list_name.split('_')[0];
//        var section = k$(id);
//        if( section_name === active_section_name ) section.show();
//        else section.hide();
//    }
//};

//f.setDownloadLink(settings){
//
//    if( settings.PDF && settings.PDF.url ){
//        var link = $('a').attr('href', settings.PDF.url ).attr('download', 'PV_drawing.pdf').html('Download Drawing');
//        $('#download').html('').append(link);
//    }
//}

//f.loadTables = function(string){
//    var tables = {};
//    var l = string.split('\n');
//    var title;
//    var fields;
//    var need_title = true;
//    var need_fields = true;
//    l.forEach( function(string, i){
//        var line = string.trim();
//        if( line.length === 0 ){
//            need_title = true;
//            need_fields = true;
//        } else if( need_title ) {
//            title = line;
//            tables[title] = [];
//            need_title = false;
//        } else if( need_fields ) {
//            fields = line.split(',');
//            tables[title+"_fields"] = fields;
//            need_fields = false;
//        //} else {
//        //    var entry = {};
//        //    var line_array = line.split(',');
//        //    fields.forEach( function(field, id){
//        //        entry[field.trim()] = line_array[id].trim();
//        //    });
//        //    tables[title].push( entry );
//        //}
//        } else {
//            var line_array = line.split(',');
//            tables[title][line_array[0].trim()] = line_array[1].trim();
//        }
//    });
//
//    return tables;
//};
//
//f.loadComponents = function(string){
//    var db = k.parseCSV(string);
//    var object = {};
//    for( var i in db ){
//        var component = db[i];
//        if( object[component.Make] === undefined ){
//            object[component.Make] = {};
//        }
//        if( object[component.Make][component.Model] === undefined ){
//            object[component.Make][component.Model] = {};
//        }
//
//        var fields = k.objIdArray(component);
//        fields.forEach( function( field ){
//            var param = component[field];
//            if( !( field in ['Make', 'Model'] ) && !( isNaN(parseFloat(param)) ) ){
//                component[field] = parseFloat(param);
//            }
//        })
//        object[component.Make][component.Model] = component;
//    }
//    return object;
//};




f.load_database = function(FSEC_database_obj){
    FSEC_database_obj = f.lowercase_properties(FSEC_database_obj);
    var components = {};
    components.inverters = {};
    FSEC_database_obj.inverters.forEach(function(component){
        if( components.inverters[component.make] === undefined ) components.inverters[component.make] = {};
        //components.inverters[component.make][component.make] = f.pretty_names(component);
        components.inverters[component.make][component.model] = component;
    });
    components.modules = {};
    FSEC_database_obj.modules.forEach(function(component){
        if( components.modules[component.make] === undefined ) components.modules[component.make] = {};
        //components.modules[component.make][component.make] = f.pretty_names(component);
        components.modules[component.make][component.model] = component;
    });

    return components;
};


f.get_ref = function(string, object){
    var ref_array = string.split('.');
    var level = object;
    ref_array.forEach(function(level_name,i){
        if( typeof level[level_name] === 'undefined' ) {
            return false;
        }
        level = level[level_name];
    });
    return level;
};
f.set_ref = function( object, ref_string, value ){
    var ref_array = ref_string.split('.');
    var level = object;
    ref_array.forEach(function(level_name,i){
        if( typeof level[level_name] === 'undefined' ) {
            return false;
        }
        level = level[level_name];
    });

    return level;
};




f.log_if_database_loaded = function(e){
    if(f.g.state.database_loaded) {
        console.log(e);
    }
};



f.lowercase_properties = function lowercase_properties(obj) {
    var new_object = new obj.constructor();
    for( var old_name in obj ){
        if (obj.hasOwnProperty(old_name)) {
            var new_name = old_name.toLowerCase();
            if( obj[old_name].constructor === Object || obj[old_name].constructor === Array ){
                new_object[new_name] = lowercase_properties(obj[old_name]);
            } else {
                new_object[new_name] = obj[old_name];
            }
        }

    }
    return new_object;
};


f.toggle_module = function(element){
    //console.log('switch', element, element.classLis );

    //element.setAttribute("fill", null);

    var elem = $(element);
    //console.log('switch', elem[0].classList.contains('preview_structural_module') );

    var r = element.getAttribute('module_ID').split(',')[0];
    var c = element.getAttribute('module_ID').split(',')[1];

    if( g.webpage.selected_modules[r][c] ){
        g.webpage.selected_modules[r][c] = false;
        g.webpage.selected_modules_total--;
    } else {
        g.webpage.selected_modules[r][c] = true;
        g.webpage.selected_modules_total++;
    }

    /*
    var layer;
    if( elem[0].classList.contains('svg_preview_structural_module_selected') ){
        //g.webpage.selected_modules[r][c] = true;
        //layer = g.drawing_settings.layer_attr.preview_structural_module;
        //element.setAttribute("class", "svg_preview_structural_module");
    } else {
        g.webpage.selected_modules = g.webpage.selected_modules +1 || 1;
        //layer = g.drawing_settings.layer_attr.preview_structural_module_selected;
        //element.setAttribute("class", "svg_preview_structural_module_selected");
    }
    //*/
    //console.log( g.webpage.selected_modules);
    //for( var attr_name in layer ){
    //    element.setAttribute(attr_name, layer[attr_name]);

    //}

    g.f.update();

    /*
    if( elem.hasClass("svg_preview_structural_module") ){
        elem.removeClass("svg_preview_structural_module");
        elem.addClass("svg_preview_structural_module_selected");
    } else if( elem.hasClass("svg_preview_structural_module_selected") ){
        elem.removeClass("svg_preview_structural_module_selected");
        elem.addClass("svg_preview_structural_module");
    } else {
        elem.addClass("svg_preview_structural_module");
    }
    */
};


f.clear_object = function(obj){
    for( var id in obj ){
        if( obj.hasOwnProperty(id)){
            delete obj[id];
        }
    }
};

// clear drawing
f.clear_drawing = function() {
    for( var id in g.drawing ){
        if( g.drawing.hasOwnProperty(id)){
            f.clear_object(g.drawing[id]);
        }
    }
};



f.query_string = function () {
  // Based on
  // http://stackoverflow.com/a/979995
  var query_string = {};
  var query = window.location.search.substring(1);
  var vars = query.split("&");
  var i;
  for ( i=0; i<vars.length; i++ ) {
    var pair = vars[i].split("=");
        // If first entry with this name
    if (typeof query_string[pair[0]] === "undefined") {
        query_string[pair[0]] = pair[1];
        // If second entry with this name
    } else if (typeof query_string[pair[0]] === "string") {
        var arr = [ query_string[pair[0]], pair[1] ];
        query_string[pair[0]] = arr;
        // If third or later entry with this name
    } else {
        query_string[pair[0]].push(pair[1]);
    }
  }
  return query_string;
};

f.request_geocode = function(){
    if( f.section_defined(g, 'location') ){
        var address_new = g.perm.location.new_address;

        if( address_new || g.perm.location.lat === undefined || g.perm.location.lat === undefined ) {
            console.log('new address');
            var address = encodeURIComponent([
                    g.perm.location.address,
                    g.perm.location.city,
                    'FL',
                    g.perm.location.zip
                ].join(', ') );
            //console.log(address);
            $('#geocode_display').text('Requesting coordinates...');
            $.getJSON('http://nominatim.openstreetmap.org/search?format=json&limit=5&q=' + address, f.set_coordinates_from_geocode );

        } else {
            $('#geocode_display').text('Address unchanged');
            f.set_coordinates_from_geocode();
        }
    } else {
        $('#geocode_display').text('Please enter address');
    }
};


f.set_sat_map_marker = function(){
    var latlng = L.latLng( g.perm.location.lat, g.perm.location.lon );
    g.perm.maps.marker_sat.setLatLng( latlng );
    g.perm.maps.marker_road.setLatLng( latlng );
    g.perm.maps.map_sat.setView( latlng );
};

f.set_coordinates_from_map = function(e){
    g.perm.location.lat = e.latlng.lat;
    g.perm.location.lon = e.latlng.lng;
    f.update();
};

f.set_coordinates_from_geocode = function(data){
    if( data === undefined && g.perm.location.lat !== undefined ){ // loading last locations
        g.perm.location.lat = g.perm.geocode.lat;
        g.perm.location.lon = g.perm.geocode.lon;
        f.update();
    } else if( data[0] !== undefined ){
        $('#geocode_display').text('Address loaded');
        console.log('New location from address', data);
        g.perm.geocode.data = data;
        g.perm.geocode.lat = data[0].lat;
        g.perm.geocode.lon = data[0].lon;
        g.perm.location.lat = g.perm.geocode.lat;
        g.perm.location.lon = g.perm.geocode.lon;
        f.update();
    } else {
        $('#geocode_display').text('Address not found');
    }
};



module.exports = f;

},{"../lib/kontainer":2}],4:[function(require,module,exports){
var mk_drawing = require('./mk_drawing');

//var drawing_parts = [];
//d.link_drawing_parts(drawing_parts);

var page = function(settings){
    console.log("** Making blocks");
    d = mk_drawing(settings);

    var f = settings.f;

    //var components = settings.components;
    //var system = settings.system;
    var system = settings.system;

    var size = settings.drawing_settings.size;
    var loc = settings.drawing_settings.loc;




    var x, y, h, w;
    var offset;

// Define d.blocks

// module d.block
    w = size.module.frame.w;
    h = size.module.frame.h;

    d.block_start('module');

    // frame
    d.layer('module');
    x = 0;
    y = 0+size.module.lead;
    d.rect( [x,y+h/2], [w,h] );
    // frame triangle?
    d.line([
        [x-w/2,y],
        [x,y+w/2],
    ]);
    d.line([
        [x,y+w/2],
        [x+w/2,y],
    ]);
    // leads
    d.layer('DC_pos');
    d.line([
        [x, y],
        [x, y-size.module.lead]
    ]);
    d.layer('DC_neg');
    d.line([
        [x, y+h],
        [x, y+h+(size.module.lead)]
    ]);
    // pos sign
    d.layer('text');
    d.text(
        [x+size.module.lead/2, y-size.module.lead/2],
        '+',
        null,
        'signs'
    );
    // neg sign
    d.text(
        [x+size.module.lead/2, y+h+size.module.lead/2],
        '-',
        null,
        'signs'
    );
    // ground
    d.layer('DC_ground');
    d.line([
        [x-w/2, y+h/2],
        [x-w/2-w/4, y+h/2],
    ]);

    d.layer();
    d.block_end();

//#string
    d.block_start('string');

    x = 0;
    y = 0;





    var max_displayed_modules = 9;
    var break_string = false;

    if( system.array.modules_per_string > max_displayed_modules ){
        displayed_modules = max_displayed_modules - 1;
        break_string = true;
        size.string.h = (size.module.h * (displayed_modules+1) ) + size.string.gap_missing;
    } else {
        displayed_modules = system.array.modules_per_string;
        size.string.h = (size.module.h * displayed_modules);
    }
    loc.array.lower = loc.array.upper + size.string.h;

    size.string.h_max = (size.module.h * max_displayed_modules) + size.string.gap_missing;
    loc.array.lower_limit = loc.array.upper + size.string.h_max;



    for( var r=0; r<displayed_modules; r++){
        d.block('module', [x,y]);
        y += size.module.h;

    }
    if( break_string ) {
        d.line(
            [
                [x,y],
                [x,y+size.string.gap_missing],
            //[x-size.module.frame.w*3/4, y+size.string.h + size.wire_offset.ground ],
            ],
            'DC_intermodule'
        );

        y += size.string.gap_missing;
        d.block('module', [x,y]);
    }

    x = 0;
    y = 0;

    //TODO: add loop to jump over negative return wires
    d.layer('DC_ground');
    d.line([
        [x-size.module.frame.w*3/4, y+size.module.h/2],
        [x-size.module.frame.w*3/4, y+size.string.h_max + size.wire_offset.ground],
        //[x-size.module.frame.w*3/4, y+size.string.h + size.wire_offset.ground ],
    ]);
    d.layer();


    d.block_end();


// terminal
    d.block_start('terminal');
    x = 0;
    y = 0;

    d.layer('terminal');
    d.circ(
        [x,y],
        size.terminal_diam
    );
    d.layer();
    d.block_end();

// fuse

    d.block_start('fuse');
    x = 0;
    y = 0;
    w = 10;
    h = 5;

    d.layer('terminal');
    d.rect(
        [x,y],
        [w,h]
    );
    d.line( [
        [w/2,y],
        [w/2+size.fuse.w, y]
    ]);
    d.block('terminal', [size.fuse.w, y] );

    d.line( [
        [-w/2,y],
        [-w/2-size.fuse.w, y]
    ]);
    d.block('terminal', [-size.fuse.w, y] );

    d.layer();
    d.block_end();

// ground symbol
    d.block_start('ground');
    x = 0;
    y = 0;

    d.layer('AC_ground');
    d.line([
        [x,y],
        [x,y+40],
    ]);
    y += 25;
    d.line([
        [x-7.5,y],
        [x+7.5,y],
    ]);
    y += 5;
    d.line([
        [x-5,y],
        [x+5,y],
    ]);
    y += 5;
    d.line([
        [x-2.5,y],
        [x+2.5,y],
    ]);
    d.layer();

    d.block_end();



// North arrow
    x = 0;
    y = 0;

    var arrow_w = 7;
    var letter_h = 14;
    var arrow_h = 50;

    d.block_start('north arrow_up');
    d.layer('north_letter');
    d.line([
        [x, y+letter_h],
        [x, y],
        [x+arrow_w, y+letter_h],
        [x+arrow_w, y],
    ]);
    d.layer('north_arrow');
    d.line([
        [x, y+arrow_h],
        [x, y],
        [x+arrow_w/2, y+letter_h/2],
    ]);
    d.line([
        [x, y],
        [x-arrow_w/2, y+letter_h/2],
    ]);
    d.layer();
    d.block_end('north arrow');

    d.block_start('north arrow_left');
    d.layer('north_letter');
    d.line([
        [x+letter_h, y],
        [x, y],
        [x+letter_h, y-arrow_w],
        [x,          y-arrow_w],
    ]);
    d.layer('north_arrow');
    d.line([
        [x+arrow_h, y],
        [x, y],
        [x+letter_h/2, y-arrow_w/2],
    ]);
    d.line([
        [x, y],
        [x+letter_h/2, y+arrow_w/2],
    ]);
    d.layer();
    d.block_end('north arrow');

//*/

    return d.drawing_parts;
};



module.exports = page;

},{"./mk_drawing":6}],5:[function(require,module,exports){
var mk_drawing = require('./mk_drawing');

//var drawing_parts = [];
//d.link_drawing_parts(drawing_parts);

/*
var fsec_logo_b64 =  'data:image/gif;base64,R0lGODlhXABcANUAAIWRZU9kdyZDhWp7bneGaru+U3CDtkFZfDROgKm109/f3/z8/NbW1lxvojpTluTfRcDCx1xvc66zV9bUSsnJTqCnXJOcYOzs7PHz+ERdoLjB2+/v793f5H6PvfLy8vLrQRk4iszMzP///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAAAAAAALAAAAABcAFwAAAb/QJFwSCwaj8ikcslsOp/QqHRKrVqv2Kx2yz12Et1w2AACgcXoK7lsTrula3b7TV/G5fO6nnjH5/d1fX5/gGmCg4SFXYeIiYpZjI2Oj1WRkpOUUZaXmJlNm5ydnkmgoaKjRaWmp6gioAJ4CCCwiGetSJYIASAEeAAgA5K2t3ycvxZ4FgK/wsTFfrRsEiAVcggAA7tyEX7DrYKwzGwAEQXaIAAAEucgAcHsrHqHAwcBvWwWFgAFZQIPAw/OCeBH4EC3b40kHCgQrAwFhh8kAKDwIcCHewIoDBhw76CnXBQOfACAgMCHAgI+qPwwwWLAAA8PTGhGCVQFiStPgpCwMlvO/wcyO9Z6dAjegIoVVvJD8OADhTI5BwCoiIdAtDLe6DCSGi2CzqQfkIEoSWvCh38gmhosE6DCVTZZDQ0SYIHeBAABIjT9IMvdtQIFHkooGACWRacRCAQWMECZxzeWFJfLSRVBAco5C8iamtMCTG5D3YA68AAbRZUHjmLGTEB1xAAWgF6Kq0WVSZSpI7heTdlCPQEZP4CeLUYVVJ0gvPLm3fDyTFO0K60CIVLlAH/LeT9gvFKWtUbR4Vyypw9A7JXpsi+vwPkse3V4aaoxxbhCgaYTJGBXv/oBAgl7FVDBdaGE90koUklQwGDetcPfcsMdQICCEjUkn3jT/adSAQa19/8gZb8EYFZYDRY4RQLTyWGSShF4+OFKFSh3UYpYTWGcHIeN5OKLJ7UHzyoa2JhicE4twyOIB5xGwVuhZIABFaowZtZdsKx4pEr3AGBWaSVe4qQVmxCQDza6FEbdlSsZVKY76VggFCJfWnFBA5xEUMGIKrWEJ48T6JXTBDE2+aScIYRAJyKJRRCAO5ephA2aja2k0aItroWIAxxccUGhhR7KSUqogdDoi08dtt0qDkAQwgVVbMppp6GA2hBTL/pXRlLPhZIqp6xK4cGrr3raSFLBtEhAAHupF1A61yUljiS7vtprFAoAy6mwfljQ0gB4EmCZeppZ+QABell4qarWbjD/RbXWGjrIf96ettI9A8ibk0Zl7HbSAQC4dW67DCxABbvWYktWBBQAcIAAPPHFyzoItJhOBAgsBIAA1VXDWEgCWOVHtMAGbAXBwGILzMVsWIRSo89FIAFoSgpgVjR0mcsGyK+KfAXJwcohADwWBdCwSmOpZGtmXllaRpcg4MypzljwfK0kFrDH0l47wQhCnhTt8+wgThcKdRZSwzoXhzPKzNdPW/OTHFATMHkzuiEL3EXZ7vpRwQEDskHABEdZlRSyHfHN77/Wjs0F3tgecMA1OEo0TRkFqMMOSfR8THfOdqPBuB9vJqZQym4OV8abZYQdguJifC4JSdXIIQHkl6jOtLrn7eaNyC9v/vK15gB3XofrgxgEj0Fyzx28IsTTCPbmTwsPSPPOK5+49IVQ77zt2DOfu8nTcX+L9qaITwz5tUMvdvejoI943c4Q4T4e5sc/xPypq786+87MX7/9RUDf/wAYwO8B73oEVELzBphAI7iOgQ104PcgGEEJtkt/t6vgEfCGQA06gYPR8yAUQJhBESYBbyU04Qk7qEJqca6FA1sfDKuggBTOkAn8u6EOd8jDHqIiCAA7';
//*/


var add_border = function(settings, sheet_info){
    d = mk_drawing(settings);
    var f = settings.f;

    //var components = settings.components;
    //var system = settings.system;
    var system = settings.system;

    var size = settings.drawing_settings.size;
    var loc = settings.drawing_settings.loc;




    var x, y, h, w;
    var offset;


////////////////////////////////////////
// Frame
    d.section('Frame');

    w = size.drawing.w;
    h = size.drawing.h;
    var padding = size.drawing.frame_padding;

    d.layer('border_lines');

    //border
    d.rect( [w/2 , h/2], [w - padding*2, h - padding*2 ] );

    var right_offset = size.drawing.titlebox;


// Project/FSEC logo
    x = w - padding;
    y = 0 + padding;
    var FSEC_logo_width = 32;
    x += -FSEC_logo_width;

    d.image(
        [x-2,y+2],
        [FSEC_logo_width,FSEC_logo_width],
        'data/logo/FSEC.gif'
    );
    d.line([
        [x-4,y],
        [x-4,                y+4+FSEC_logo_width],
        [w-padding,y+4+FSEC_logo_width],
    ]);


// title boxes

    // title box
    var titlebox = size.drawing.titlebox;

    // side
    x = w - padding - titlebox.side.w;
    y = h - padding;
    d.line([
        [ x, y],
        [ x,                 y - titlebox.side.h],
        [ x+titlebox.side.w, y - titlebox.side.h]
    ]);

    //bottom
    x = w - padding - titlebox.side.w - titlebox.bottom.w;
    y = h - padding;
    d.line([
        [ x, y],
        [ x, y - titlebox.bottom.h],
        [ x + titlebox.bottom.w , y - titlebox.bottom.h],
    ]);


// bottom bar content


    x = w - padding - titlebox.bottom.w - titlebox.side.w;
    y = h - padding - titlebox.bottom.h;


    if( settings.f.section_defined(settings, 'location')  ){
        d.text([x+10,y+titlebox.bottom.h *1/4], [
            'PV System Design',
            settings.perm.location.address,
            settings.perm.location.city + ', ' + settings.perm.location.county + ', FL, ' + settings.perm.location.zip,

        ], 'text', 'border_info');
    }


    x += 150;
    d.line([
        [ x , y ],
        [ x , y+titlebox.bottom.h ],
    ]);
    d.text([x+10,y+titlebox.bottom.h *1/4],
         [ 'PV System Design' ],
        'text',
        'border_info'
        );




// Side bar content

    x = w - padding - titlebox.side.w;
    y = h - padding - titlebox.side.h;

    // Contractor name box
    d.text([x+titlebox.side.w/2,y+10], [
             [ 'Solar Installer Inc.' ],
             [ '1234 Yellow Sub Ln.' ],
             [ 'Cocoa, Fl 32922' ],
         ],
         'text',
        'installer_info'
        );


    y += titlebox.side.w/2;
    d.line([
        [ x , y ],
        [ x+titlebox.side.w , y ],
    ]);

    // manufacturer logo box
    var logo_gap = 2;
    var logo_width = (titlebox.side.w-logo_gap*3)/2;

    var logos = [
        'data/logo/SMA.png',
        'data/logo/suniva.jpg',
        'data/logo/schletter.svg',
    ];
    d.image(
        [x+logo_gap,y+logo_gap],
        [logo_width,logo_width],
        logos[0]
    );
    d.image(
        [x+logo_gap,y+logo_gap+logo_width+logo_gap],
        [logo_width,logo_width],
        logos[1]
    );
    d.image(
        [x+logo_gap+logo_width+logo_gap,y+logo_gap],
        [logo_width,logo_width],
        logos[2]
    );

    y += titlebox.side.w;
    d.line([
        [ x , y ],
        [ x+titlebox.side.w , y ],
    ]);


    y += titlebox.side.w;
    d.line([
        [ x , y ],
        [ x+titlebox.side.w , y ],
    ]);

    y += titlebox.side.w /8;
    d.text([x+titlebox.side.w/2,y+10], [
             [ sheet_info.num ],
        ],
        'text',
        'sheet_num'
        );

    /*
    d.image(
        [x+32,y+32],
        [32,32],
        logos[3]
    );
    //*/



    /*
    x = w - padding * 3;
    y = padding * 3;

    w = size.drawing.titlebox;
    h = size.drawing.titlebox;

    // box top-right
    //d.rect( [x-w/2, y+h/2], [w,h] );

    y += h + padding;

    w = size.drawing.titlebox;
    h = size.drawing.h - padding*8 - size.drawing.titlebox*2.5;

    //title box
    //d.rect( [x-w/2, y+h/2], [w,h] );

    var title = {};
    title.top = y;
    title.bottom = y+h;
    title.right = x;
    title.left = x-w ;


    // box bottom-right
    h = size.drawing.titlebox * 1.5;
    y = title.bottom + padding;
    x = x-w/2;
    y = y+h/2;
    d.rect( [x, y], [w,h] );

    y -= 20*2/3;
    d.text([x,y],
        [ sheet_section, sheet_num ],
        'text',
        'page'
        );


    var page = {};
    page.right = title.right;
    page.left = title.left;
    page.top = title.bottom + padding;
    page.bottom = page.top + size.drawing.titlebox*1.5;
    // d.text

    x = title.left + padding;
    y = title.bottom - padding;

    x += 10;
    if( system.inverter.make && system.inverter.model ){
        d.text([x,y],
             [ 'PV System Design' ],
            'text',
            'title1'
            ).rotate(-90);

    }

    x += 14;
    if( settings.f.section_defined(settings, 'location')  ){
        d.text([x,y], [
            settings.perm.location.address,
            settings.perm.location.city + ', ' + settings.perm.location.county + ', FL, ' + settings.perm.location.zip,

        ], 'text', 'title3').rotate(-90);
    }

    x = page.left + padding;
    y = page.top + padding;
    y += size.drawing.titlebox * 1.5 * 3/4;



    //*/



    return d.drawing_parts;
};



module.exports = add_border;

},{"./mk_drawing":6}],6:[function(require,module,exports){
'use strict';

var _ = require('underscore');


var mk_drawing = function(g){

    var drawing = {};


    var layer_attr = require('./settings_layers');
    var fonts = require('./settings_fonts');







    // BLOCKS

    var Blk = {
        type: 'block',
    };
    Blk.move = function(x, y){
        for( var i in this.drawing_parts ){
            this.drawing_parts[i].move(x,y);
        }
        return this;
    };
    Blk.add = function(){
        if( typeof this.drawing_parts == 'undefined'){
            this.drawing_parts = [];
        }
        for( var i in arguments){
            this.drawing_parts.push(arguments[i]);
        }
        return this;
    };
    Blk.rotate = function(deg){
        this.rotate = deg;
    };


    var block_active = false;
    // Create default layer,block container and functions

    // Layers

    var layer_active = false;

    drawing.layer = function(name){ // set current layer
        if( typeof name === 'undefined' ){ // if no layer name given, reset to default
            layer_active = false;
        } else if ( ! (name in layer_attr) ) {
            console.warn('Error: unknown layer "'+name+'", using base');
            layer_active = 'base' ;
        } else { // finaly activate requested layer
            layer_active = name;
        }
        //*/
    };

    var section_active = false;

    drawing.section = function(name){ // set current section
        if( typeof name === 'undefined' ){ // if no section name given, reset to default
            section_active = false;
        } else { // finaly activate requested section
            section_active = name;
        }
        //*/
    };


    drawing.block_start = function(name) {
        if( typeof name === 'undefined' ){ // if name argument is submitted
            console.log('Error: name required');
        } else {
            var blk;
            block_active = name;
            if( g.drawing.blocks[block_active] !== undefined ){
                console.log('Error: block already exists');
            }
            blk = Object.create(Blk);
            g.drawing.blocks[block_active] = blk;
            return blk;
        }
    };

        /*
        x = loc.wire_table.x - w/2;
        y = loc.wire_table.y - h/2;
        if( typeof layer_name !== 'undefined' && (layer_name in layers) ) {
            var layer_selected = layers[layer_name]
        } else {
            if( ! (layer_name in layers) ){ console.log("error, layer does not exist, using current");}
            var layer_selected =  layer_active
        }
        */
    drawing.block_end = function() {
        var blk = g.drawing.blocks[block_active];
        block_active = false;
        return blk;
    };






    //////
    // build prototype element

        /*
        if( typeof layer_name !== 'undefined' && (layer_name in layers) ) {
            var layer_selected = layers[layer_name]
        } else {
            if( ! (layer_name in layers) ){ console.log("error, layer does not exist, using current");}
            var layer_selected =  layer_active
        }
        */


    var SvgElem = {
        object: 'SvgElem'
    };
    SvgElem.move = function(x, y){
        if( typeof this.points != 'undefined' ) {
            for( var i in this.points ) {
                this.points[i][0] += x;
                this.points[i][1] += y;
            }
        }
        return this;
    };
    SvgElem.rotate = function(deg){
        this.rotated = deg;
    };

    ///////
    // functions for adding drawing_parts

    drawing.add = function(type, points, layer_name, attrs) {
        if( points[0] === undefined ) console.warn("points not deffined", type, points, layer_name );

        if( ! layer_name ) { layer_name = layer_active; }
        if( ! (layer_name in layer_attr) ) {
            console.warn('Error: Layer "'+ layer_name +'" name not found, using base');
            layer_name = 'base';
        }

        if( typeof points == 'string') {
            var points_a = points.split(' ');
            for( var i in points_a ) {
                points_a[i] = points_a[i].split(',');
                for( var c in points_a[i] ) {
                    points_a[i][c] = Number(points_a[i][c]);
                }
            }
        }



        var elem = Object.create(SvgElem);
        elem.type = type;
        elem.layer_name = layer_name;
        elem.section_name = section_active;
        if( attrs !== undefined ) elem.attrs = attrs;
        if( type === 'line' ) {
            elem.points = points;
        } else if( type === 'poly' ) {
            elem.points = points;
        } else if( typeof points[0].x === 'undefined') {
            elem.x = points[0][0];
            elem.y = points[0][1];
        } else {
            elem.x = points[0].x;
            elem.y = points[0].y;
        }

        if(block_active) {
            elem.block_name = block_active;
            g.drawing.blocks[block_active].add(elem);
        } else {
            this.drawing_parts.push(elem);
        }


        // Temp. NaN check
        points.forEach(function(point){
            if( point.constructor === Array ){
                point.forEach(function(num){
                    if( isNaN(num) ){
                        console.log( 'NaN alert:', elem);
                    }
                });
            } else {
                if( isNaN(point.x) || isNaN(point.y) ){
                    console.log( 'NaN alert:', elem);
                }

            }
        });

        return elem;
    };

    drawing.line = function(points, layer, attrs){ // (points, [layer])
        //return add('line', points, layer)
        var line =  this.add('line', points, layer, attrs);
        return line;
    };

    drawing.poly = function(points, layer, attrs){ // (points, [layer])
        //return add('poly', points, layer)
        var poly =  this.add('poly', points, layer, attrs);
        return poly;
    };

    drawing.rect = function(loc, size, layer, attrs){
        var rec = this.add('rect', [loc], layer, attrs);
        rec.w = size[0];
        /*
        if( typeof layer_name !== 'undefined' && (layer_name in layers) ) {
            var layer_selected = layers[layer_name]
        } else {
            if( ! (layer_name in layers) ){ console.log("error, layer does not exist, using current");}
            var layer_selected =  layer_active
        }
        */
        rec.h = size[1];
        return rec;
    };

    drawing.circ = function(loc, diameter, layer, attrs){
        var cir = this.add('circ', [loc], layer, attrs);
        cir.d = diameter;
        return cir;
    };

    drawing.text = function(loc, strings, layer, font, attrs){
        var txt = this.add('text', [loc], layer, attrs);
        if( typeof strings == 'string'){
            strings = [strings];
        }
        txt.strings = strings;
        txt.font = font;
        return txt;
    };

    drawing.image = function(loc, size, href, layer, attrs){
        var img = this.add('image', [loc], 'image', attrs);
        img.w = size[0];
        img.h = size[1];
        img.href = href;
        return img;
    };

    drawing.block = function(name) {// set current block
        var x,y;
        if( arguments.length === 2 ){ // if coor is passed
            if( typeof arguments[1].x !== 'undefined' ){
                x = arguments[1].x;
                y = arguments[1].y;
            } else {
                x = arguments[1][0];
                y = arguments[1][1];
            }
        } else if( arguments.length === 3 ){ // if x,y is passed
            x = arguments[1];
            y = arguments[2];
        }

        // TODO: what if block does not exist? print list of blocks?
        var blk = Object.create(g.drawing.blocks[name]);
        blk.x = x;
        blk.y = y;

        if(block_active){
            g.drawing.blocks[block_active].add(blk);
        } else {
            this.drawing_parts.push(blk);
        }
        return blk;
    };










    //////////////
    // Tables

    var Cell = {
        init: function(table, R, C){
            var self = this;
            this.table = table;
            this.R = R;
            this.C = C;
            /*
            this.borders = {};
            this.border_options.forEach(function(side){
                self.borders[side] = false;
            });
            //*/
            return this;
        },
        /*
        border_options: ['T', 'B', 'L', 'R'],
        //*/
        text: function(text){
            this.cell_text = text;
            return this;

        },
        font: function(font_name){
            this.cell_font_name = font_name;
            return this;
        },

        border: function(border_string, state){
            this.table.border( this.R, this.C, border_string, state );
            return this;
        }
    };

    var Table = {
        init: function( drawing, num_rows, num_cols ){
            this.drawing = drawing;
            this.num_rows = num_rows;
            this.num_cols = num_cols;
            var r,c;

            // setup border containers
            this.borders_rows = [];
            for( r=0; r<=num_rows; r++){
                this.borders_rows[r] = [];
                for( c=1; c<=num_cols; c++){
                    this.borders_rows[r][c] = false;
                }
            }
            this.borders_cols = [];
            for( c=0; c<=num_cols; c++){
                this.borders_cols[c] = [];
                for( r=1; r<=num_rows; r++){
                    this.borders_cols[c][r] = false;
                }
            }

            // set column and row size containers
            this.row_sizes = [];
            for( r=1; r<=num_rows; r++){
                this.row_sizes[r] = 15;
            }
            this.col_sizes = [];
            for( c=1; c<=num_cols; c++){
                this.col_sizes[c] = 60;
            }

            // setup cell container
            this.cells = [];
            for( r=1; r<=num_rows; r++){
                this.cells[r] = [];
                for( c=1; c<=num_cols; c++){
                    this.cells[r][c] = Object.create(Cell);
                    this.cells[r][c].init( this, r, c);
                }

            }
            //*/

            return this;
        },
        loc: function( x, y){
            this.x = x;
            this.y = y;
            return this;
        },
        cell: function( R, C ){
            return this.cells[R][C];
        },
        all_cells: function(){
            var cell_array = [];
            this.cells.forEach(function(row){
                row.forEach(function(cell){
                    cell_array.push(cell);
                });
            });
            return cell_array;
        },
        col_size: function(col, size){
            if( typeof col === 'string' ){
                if( col === 'all'){
                    _.range(this.num_cols).forEach(function(c){
                        this.col_sizes[c+1] = size;
                    },this);
                } else {
                    size = Number(size);
                    if( isNaN(size) ){
                        console.log('Error: column wrong');
                    } else {
                        this.col_sizes[col] = size;
                    }
                }
            } else { // is number
                this.col_sizes[col] = size;
            }
            return this;
        },
        //*/
        row_size: function(row, size){
            if( typeof row === 'string' ){
                if( row === 'all'){
                    _.range(this.num_rows).forEach(function(r){
                        this.row_sizes[r+1] = size;
                    },this);
                } else {
                    size = Number(size);
                    if( isNaN(size) ){
                        console.log('Error: column wrong');
                    } else {
                        this.row_sizes[row] = size;
                    }
                }
            } else { // is number
                this.row_sizes[row] = size;
            }
            return this;
        },
        //*/

        /*
        add_cell: function(){

        },
        add_rows: function(n){
            this.num_colmns += n;
            this.num_rows += n;
            _.range(n).forEach(function(){
                this.rows.push([]);
            });
            _.range(n).forEach(function(){
                this.text_rows.push([]);
            });

        },
        text: function( R, C, text){
            this.text_rows[R][C] = text;
        },
        //*/
        border: function( R, C, border_string, state){
            if( state === undefined ) state = true;

            border_string = border_string.toUpperCase().trim();
            var borders;
            if( border_string === 'ALL' ){
                borders = ['T', 'B', 'L', 'R'];
            } else {
                borders = border_string.split(/[\s,]+/);
            }
            borders.forEach(function(side){
                switch(side){
                    case 'T':
                        this.borders_rows[R-1][C] = state;
                        break;
                    case 'B':
                        this.borders_rows[R][C] = state;
                        break;
                    case 'L':
                        this.borders_cols[C-1][R] = state;
                        break;
                    case 'R':
                        this.borders_cols[C][R] = state;
                        break;
                }
            }, this);
            return this;
        },
        corner: function(R,C){
            var x = this.x;
            var y = this.y;
            var r,c;
            for( r=1; r<=R; r++ ){
                y += this.row_sizes[r];
            }
            for( c=1; c<=C; c++ ){
                x += this.col_sizes[c];
            }
            return [x,y];
        },
        center: function(R,C){
            var x = this.x;
            var y = this.y;
            var r,c;
            for( r=1; r<=R; r++ ){
                y += this.row_sizes[r];
            }
            for( c=1; c<=C; c++ ){
                x += this.col_sizes[c];
            }
            y -= this.row_sizes[R]/2;
            x -= this.col_sizes[C]/2;
            return [x,y];
        },
        left: function(R,C){
            var coor = this.center(R,C);
            coor[0] = coor[0] - this.col_sizes[C]/2 + this.row_sizes[R]/2;
            return coor;
        },
        right: function(R,C){
            var coor = this.center(R,C);
            coor[0] = coor[0] + this.col_sizes[C]/2 - this.row_sizes[R]/2;
            return coor;
        },
        mk: function(){
            var self = this;
            var r,c;
            for( r=0; r<=this.num_rows; r++ ){
                for( c=1; c<=this.num_cols; c++ ){
                    if( this.borders_rows[r][c] === true ){
                        this.drawing.line([
                            this.corner(r,c-1),
                            this.corner(r,c),
                            ], 'border');

                    }
                }
            }
            for( c=0; c<=this.num_cols; c++ ){
                for( r=1; r<=this.num_rows; r++ ){
                    if( this.borders_cols[c][r] === true ){
                        this.drawing.line([
                            this.corner(r-1,c),
                            this.corner(r,c),
                            ], 'border');

                    }
                }
            }
            for( r=1; r<=this.num_rows; r++ ){
                for( c=1; c<=this.num_cols; c++ ){
                    if( typeof this.cell(r,c).cell_text === 'string' ){
                        var cell = this.cell(r,c);
                        var font_name = cell.cell_font_name || 'table';
                        var coor;
                        if( fonts[font_name]['text-anchor'] === 'center') coor = this.center(r,c);
                        else if( fonts[font_name]['text-anchor'] === 'right') coor = this.right(r,c);
                        else if( fonts[font_name]['text-anchor'] === 'left') coor = this.left(r,c);
                        else coor = this.center(r,c);

                        this.drawing.text(
                            coor,
                            this.cell(r,c).cell_text,
                            'text',
                            font_name
                        );
                    }
                }
            }

        }

    };

    drawing.table = function( num_rows, num_cols ){
        var new_table = Object.create(Table);
        new_table.init( this, num_rows, num_cols );

        return new_table;

    };


    drawing.append =  function(drawing_parts){
        var blk = Object.create(Blk);
        blk.drawing_parts = drawing_parts;
        
        this.drawing_parts = this.drawing_parts.concat(drawing_parts);
        //this.drawing_parts = this.drawing_parts.concat(drawing_parts);
        return this;
    };




    var page = Object.create(drawing);
    //console.log(page);
    page.drawing_parts = [];
    return page;




};





/////////////////////////////////



module.exports = mk_drawing;

},{"./settings_fonts":19,"./settings_layers":20,"underscore":23}],7:[function(require,module,exports){
"use strict";
var f = require('./functions');



var mk_settings = function() {


    var i;
    //var settingsCalculated = require('./settingsCalculated.js');

    // Load 'user' defined settings
    //var mk_settings = require('../data/settings.json.js');
    //f.mk_settings = mk_settings;

    var settings = {};




    settings.temp = {};

    settings.perm = {};
    settings.perm.geocode = {};
    settings.perm.location = {};
    settings.perm.location.new_address = false;
    settings.perm.maps = {};

    settings.config_options = {};
    settings.config_options.NEC_tables = require('../data/tables.json');
    //console.log(settings.config_options.NEC_tables);

    settings.state = {};
    settings.state.database_loaded = false;

    settings.in = {};

    settings.in.opt = {};
    settings.in.opt.AC = {};
    settings.in.opt.AC.types = {};
    settings.in.opt.AC.types["120V"] = ["ground","neutral","L1"];
    settings.in.opt.AC.types["240V"] = ["ground","neutral","L1","L2"];
    settings.in.opt.AC.types["208V"] = ["ground","neutral","L1","L2"];
    settings.in.opt.AC.types["277V"] = ["ground","neutral","L1"];
    settings.in.opt.AC.types["480V Wye"] = ["ground","neutral","L1","L2","L3"];
    settings.in.opt.AC.types["480V Delta"] = ["ground","L1","L2","L3"];


    settings.inputs = {};
    settings.inputs.location = {};
    settings.inputs.location.county = {};
    settings.inputs.location.county.type = 'text_input';
    settings.inputs.location.address = {};
    settings.inputs.location.address.type = 'text_input';
    settings.inputs.location.city = {};
    settings.inputs.location.city.type = 'text_input';
    settings.inputs.location.zip = {};
    settings.inputs.location.zip.type = 'text_input';

    settings.inputs.roof = {};
    settings.inputs.roof.width = {};
    settings.inputs.roof.width.options = [];
    //for( i=15; i<=70; i+=5 ) settings.inputs.roof.width.options.push(i);
    settings.inputs.roof.width.units = 'ft.';
    settings.inputs.roof.width.note = 'This the full size of the roof, perpendictular to the slope.';
    settings.inputs.roof.width.type = 'number_input';
    settings.inputs.roof.length = {};
    settings.inputs.roof.length.options = [];
    //for( i=10; i<=60; i+=5 ) settings.inputs.roof.length.options.push(i);
    settings.inputs.roof.length.units = 'ft.';
    settings.inputs.roof.length.note = 'This the full length of the roof, measured from low to high.';
    settings.inputs.roof.length.type = 'number_input';
    settings.inputs.roof.slope = {};
    settings.inputs.roof.slope.options = ['1:12','2:12','3:12','4:12','5:12','6:12','7:12','8:12','9:12','10:12','11:12','12:12'];
    settings.inputs.roof.type = {};
    settings.inputs.roof.type.options = ['Gable','Shed','Hipped'];
    settings.inputs.module = {};
    settings.inputs.module.make = {};
    //settings.inputs.module.make.options = null;
    settings.inputs.module.model = {};
    //settings.inputs.module.model.options = null;
    settings.inputs.module.orientation = {};
    settings.inputs.module.orientation.options = ['Portrait','Landscape'];
    settings.inputs.array = {};
    settings.inputs.array.modules_per_string = {};
    settings.inputs.array.modules_per_string.options = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];
    settings.inputs.array.num_strings = {};
    settings.inputs.array.num_strings.options = [1,2,3,4,5,6];
    settings.inputs.DC = {};
    settings.inputs.DC.home_run_length = {};
    //settings.inputs.DC.home_run_length.options = [25,50,75,100,125,150];
    settings.inputs.DC.home_run_length.type = 'number_input';
    settings.inputs.inverter = {};
    settings.inputs.inverter.make = {};
    //settings.inputs.inverter.make.options = null;
    settings.inputs.inverter.model = {};
    settings.inputs.inverter.location = {};
    settings.inputs.inverter.location.options = ['Inside', 'Outside'];
    //settings.inputs.inverter.model.options = null;
    settings.inputs.AC = {};
    settings.inputs.AC.loadcenter_types = {};
    settings.inputs.AC.loadcenter_types['240V'] = {};
    settings.inputs.AC.loadcenter_types['240V'] = ['240V','120V'];
    settings.inputs.AC.loadcenter_types['208/120V'] = {};
    settings.inputs.AC.loadcenter_types['208/120V'] = ['208V','120V'];
    settings.inputs.AC.loadcenter_types['480/277V'] = {};
    settings.inputs.AC.loadcenter_types['480/277V'] = ['480V Wye','480V Delta','277V'];
    settings.inputs.AC.type = {};
    //settings.inputs.AC.type.options = null;
    settings.inputs.AC.distance_to_loadcenter = {};
    //settings.inputs.AC.distance_to_loadcenter.options = [3,5,10,15,20,30];
    settings.inputs.AC.distance_to_loadcenter.type = 'number_input';

    settings.inputs.attachment_system = {};
    settings.inputs.attachment_system.make = {
        options: ['UNIRAC'],
        type: 'select',
    };
    settings.inputs.attachment_system.model = {
        options: ['SOLARMOUNT'],
        type: 'select',
    };



    settings.user_input = f.add_sections(settings.inputs);
console.log(settings.user_input);



    //settings.inputs = settings.inputs; // copy input reference with options to inputs
    //settings.inputs = f.blank_copy(settings.inputs); // make input section blank
    //settings.system_formulas = settings.system; // copy system reference to system_formulas
    settings.system = f.blank_copy(settings.inputs); // make system section blank
    //f.merge_objects( settings.inputs, settings.system );


    // load layers

    settings.drawing = {};

    settings.drawing_settings = {};
    settings.drawing_settings.layer_attr = require('./settings_layers');
    settings.drawing_settings.fonts = require('./settings_fonts');

    settings.drawing.blocks = {};

    // Load drawing specific settings
    // TODO Fix settings_drawing with new variable locations
    var settings_drawing = require('./settings_drawing');
    settings = settings_drawing(settings);

    //settings.state_app.version_string = version_string;

    //settings = f.nullToObject(settings);

    settings.select_registry = [];
    //settings.value_registry = [];


    //var config_options = settings.config_options = settings.config_options || {};

    settings.webpage = {};
    settings.webpage.selections_manual_toggled = {};
    settings.webpage.sections = Object.keys(settings.inputs);


    settings.webpage.sections.forEach( function(section_name){
        settings.webpage.selections_manual_toggled[section_name] = false;
    });

    settings.webpage.selected_modules_total = 0;
    settings.webpage.selected_modules = {};




    settings.components = {};





    // Load functions and add them the the global object
    f.g = settings;
    settings.f = f;




    // Load modules

    f.setup_webpage = require('./setup_webpage');

    f.process = require('./process');
    f.settings_dev_defaults = require('./settings_dev_defaults');


    f.mk_blocks = require('./mk_blocks');

    f.mk_sheet_num = {};
    f.mk_sheet_num['G-001'] = require('./page/G-001');
    f.mk_sheet_num['S-001'] = require('./page/S-001');
    f.mk_sheet_num['W-001'] = require('./page/W-001');
    f.mk_sheet_num['W-002'] = require('./page/W-002');

    f.mk_preview = {};
    f.mk_preview['roof'] = require('./preview/mk_preview_roof');
    f.mk_preview['elec'] = require('./preview/mk_preview_elec');

    f.mk_svg= require('./mk_svg');



    settings.drawing_settings.sheets = [
        {
            num: 'G-001',
            desc: 'Title Sheet'
        },
        {
            num: 'W-001',
            desc: 'PV system wiring diagram'
        },
        {
            num: 'W-002',
            desc: 'PV system specifications'
        },
        {
            num: 'S-001',
            desc: 'Roof details'
        },
        {
            num: 'X-042',
            desc: 'L.U.E.'
        },
    ];





    return settings;

};



module.exports = mk_settings;

},{"../data/tables.json":1,"./functions":3,"./mk_blocks":4,"./mk_svg":9,"./page/G-001":10,"./page/S-001":11,"./page/W-001":12,"./page/W-002":13,"./preview/mk_preview_elec":14,"./preview/mk_preview_roof":15,"./process":16,"./settings_dev_defaults":17,"./settings_drawing":18,"./settings_fonts":19,"./settings_layers":20,"./setup_webpage":21}],8:[function(require,module,exports){
var mk_drawing = require('./mk_drawing');
var mk_border = require('./mk_border');

var page = function(settings, sheet_info){
    console.log("** Making page "+sheet_info.num);

    //var page_maker = require()

    var d = mk_drawing(settings);

    d.append(mk_border(settings, sheet_info ));



    if( settings.f.mk_sheet_num[sheet_info.num] !== undefined ){
        //console.log('Sheet defined');
        d.append( settings.f.mk_sheet_num[sheet_info.num](settings) );
        d.append( settings.f.mk_sheet_num[sheet_info.num](settings) );
    } else {
        console.log('Error: Sheet not defined');
    }

    return d.drawing_parts;
};



module.exports = page;

},{"./mk_border":5,"./mk_drawing":6}],9:[function(require,module,exports){
'use strict';
//var settings = require('./settings.js');
//var snapsvg = require('snapsvg');
//log(settings);



var mk_svg = function(drawing_parts, drawing_settings){
    //console.log('displaying svg');
    //console.log('drawing_parts: ', drawing_parts);
    //container.empty()
    var drawing_size = drawing_settings.size.drawing;
    var layer_attr = drawing_settings.layer_attr;
    var fonts = drawing_settings.fonts;

    //var svg_document = document.getElementById('SvgjsSvg1000')
    var svg_document = document.createElementNS("http://www.w3.org/2000/svg", 'svg');
    //svg_document.setAttribute('class','svg_drawing');



    //svg_document.setAttribute('width', settings.drawing_settings.size.drawing.w);
    //svg_document.setAttribute('height', settings.drawing_settings.size.drawing.h);
    var view_box = '0 0 ' + drawing_size.w + ' ' + drawing_size.h + ' ';
    svg_document.setAttribute('viewBox', view_box);
    svg_document.setAttribute('xmlns','http://www.w3.org/2000/svg');
    svg_document.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');
    //var svg = snapsvg(svg_document).size(size.drawing.w, size.drawing.h);
    //var svg = snapsvg('#svg_drawing');

    // Loop through all the drawing contents, call the function below.
    drawing_parts.forEach( function(item,id) {
        svg_document.appendChild(
            mk_svg_elem(item)
        );
    });

    function mk_svg_elem(item){
        var x,y,attr_name;
        if( typeof item.x !== 'undefined' ) { x = item.x; }
        if( typeof item.y !== 'undefined' ) { y = item.y; }

        var attrs = layer_attr[item.layer_name];
        if( item.attrs !== undefined){
            for( attr_name in item.attrs ){
                attrs[attr_name] = item.attrs[attr_name];
            }
        }
        var svg_elem;

        if( item.type === 'rect') {
            //svg.rect( item.w, item.h ).move( x-item.w/2, y-item.h/2 ).attr( layer_attr[item.layer_name] );
            //console.log('elem:', elem );
            //if( isNaN(item.w) ) {
            //    console.log('error: elem not fully defined', elem)
            //    item.w = 10;
            //}
            //if( isNaN(item.h) ) {
            //    console.log('error: elem not fully defined', elem)
            //    item.h = 10;
            //}
            svg_elem = document.createElementNS("http://www.w3.org/2000/svg", 'rect');
            svg_elem.setAttribute('width', item.w);
            svg_elem.setAttribute('height', item.h);
            svg_elem.setAttribute('x', x-item.w/2);
            svg_elem.setAttribute('y', y-item.h/2);
            //console.log(item.layer_name);
            for( attr_name in attrs ){
                svg_elem.setAttribute(attr_name, attrs[attr_name]);
            }

        } else if( item.type === 'line') {
            var points2 = [];
            item.points.forEach( function(point){
                if( ! isNaN(point[0]) && ! isNaN(point[1]) ){
                    points2.push([ point[0], point[1] ]);
                } else {
                    console.log('error: elem not fully defined', item);
                }
            });
            //svg.polyline( points2 ).attr( layer_attr[item.layer_name] );

            svg_elem = document.createElementNS("http://www.w3.org/2000/svg", 'polyline');
            svg_elem.setAttribute( 'points', points2.join(' ') );
            for( attr_name in attrs ){
                svg_elem.setAttribute(attr_name, attrs[attr_name]);
            }

        } else if( item.type === 'poly') {
            var points2 = [];
            item.points.forEach( function(point){
                if( ! isNaN(point[0]) && ! isNaN(point[1]) ){
                    points2.push([ point[0], point[1] ]);
                } else {
                    console.log('error: elem not fully defined', item);
                }
            });
            //svg.polyline( points2 ).attr( layer_attr[item.layer_name] );

            svg_elem = document.createElementNS("http://www.w3.org/2000/svg", 'polyline');
            svg_elem.setAttribute( 'points', points2.join(' ') );
            for( attr_name in attrs ){
                svg_elem.setAttribute(attr_name, attrs[attr_name]);
            }

        } else if( item.type === 'text') {
            //var t = svg.text( item.strings ).move( item.points[0][0], item.points[0][1] ).attr( layer_attr[item.layer_name] )
            var font;
            if( item.font && fonts[item.font] ){
                font = fonts[item.font];
            } else if(fonts[attrs.font]){
                font = fonts[attrs.font];
            } else {
                font = fonts['base'];
            }
            if( font === undefined){
                console.log('Font not found', font, fonts['base']['font-size']);

            }

            svg_elem = document.createElementNS("http://www.w3.org/2000/svg", 'text');
            if(item.rotated){
                //t.setAttribute('transform', "rotate(" + item.rotated + " " + x + " " + y + ")" );
                svg_elem.setAttribute('transform', "rotate(" + item.rotated + " " + x + " " + y + ")" );
            } else {
                //if( font['text-anchor'] === 'middle' ) y += font['font-size']*1/3;
                y += font['font-size']*1/3;
            }
            var dy = font['font-size']*1.5;
            svg_elem.setAttribute('x', x);
            //svg_elem.setAttribute('y', y + font['font-size']/2 );
            svg_elem.setAttribute('y', y-dy );

            for( attr_name in attrs ){
                if( attr_name === 'stroke' ) {
                    svg_elem.setAttribute( 'fill', attrs[attr_name] );
                } else if( attr_name === 'fill' ) {
                    //svg_elem.setAttribute( 'stroke', 'none' );
                } else {
                    svg_elem.setAttribute( attr_name, attrs[attr_name] );
                }

            }
            for( attr_name in font ){
                svg_elem.setAttribute( attr_name, font[attr_name] );
            }
            for( attr_name in item.strings ){
                var tspan = document.createElementNS("http://www.w3.org/2000/svg", 'tspan');
                tspan.setAttribute('dy', dy );
                tspan.setAttribute('x', x);
                tspan.innerHTML = item.strings[attr_name];
                svg_elem.appendChild(tspan);
            }

        } else if( item.type === 'circ') {
            var svg_elem = document.createElementNS("http://www.w3.org/2000/svg", 'ellipse');
            svg_elem.setAttribute('rx', item.d/2);
            svg_elem.setAttribute('ry', item.d/2);
            svg_elem.setAttribute('cx', x);
            svg_elem.setAttribute('cy', y);
            for( attr_name in attrs ){
                svg_elem.setAttribute(attr_name, attrs[attr_name]);
            }
            /*
            c.attributes( layer_attr[item.layer_name] )
            c.attributes({
                rx: 5,
                --------------------------
                ry: 5,
                cx: item.points[0][0]-item.d/2,
                cy: item.points[0][1]-item.d/2
            })
            var c2 = svg.ellipse( item.r, item.r )
            c2.move( item.points[0][0]-item.d/2, item.points[0][1]-item.d/2 )
            c2.attr({rx:5, ry:5})
            c2.attr( layer_attr[item.layer_name] )
            //*/
        } else if( item.type === 'image') {

            svg_elem = document.createElementNS("http://www.w3.org/2000/svg", 'g');
            var image = document.createElementNS("http://www.w3.org/2000/svg", 'image');
            image.setAttribute('x', x);
            image.setAttribute('y', y);
            image.setAttribute('width', item.w);
            image.setAttribute('height', item.h);
            image.setAttribute('xlink:href', item.href);
            for( attr_name in attrs ){
                image.setAttribute(attr_name, attrs[attr_name]);
            }
            //g.appendChild(svg_elem);
            //svg_elem.appendChild(g);
            svg_elem.innerHTML += image.outerHTML;




        } else if(item.type === 'block') {
            // if it is a block, run this function through each element.

            svg_elem = document.createElementNS("http://www.w3.org/2000/svg", 'g');
            svg_elem.setAttribute('transform', 'translate('+x+','+y+')');
            item.drawing_parts.forEach( function(block_item,id){
                svg_elem.appendChild(
                    mk_svg_elem(block_item)
                );
            });
        }

        return svg_elem;


    }
    return svg_document;
};


module.exports = mk_svg;

},{}],10:[function(require,module,exports){
var mk_drawing = require('../mk_drawing');
var mk_border = require('../mk_border');

var page = function(settings){

    var d = mk_drawing(settings);

    var sheet_section = 'A';
    var sheet_num = '00';
    //d.append(mk_border(settings, sheet_section, sheet_num ));

    var size = settings.drawing_settings.size;
    var loc = settings.drawing_settings.loc;

    var x, y, h, w;
    d.layer('text');
    d.text(
        [size.drawing.w*1/2, size.drawing.h*1/3],
        [
            'PV System Design',
        ],
        null,
        'project title'
    );

    if( settings.f.section_defined(settings, 'location')  ){
        d.text(
            [size.drawing.w*1/2, size.drawing.h*1/3 +30],
            [
                settings.perm.location.address,
                settings.perm.location.city + ', ' + settings.perm.location.county + ', FL, ' + settings.perm.location.zip,
            ],
            null,
            'project title'
        );
    }
    var n_rows = settings.drawing_settings.sheets.length;
    var n_cols = 2;
    w = 400+80;
    h = n_rows*20;
    x = size.drawing.frame_padding*6;
    y = size.drawing.h - size.drawing.frame_padding - size.drawing.titlebox.bottom.h;
    y += -20 * n_rows;
    y += -40; // the last number is the gap to the title box
    d.text( [x+w/2, y-20], 'Contents', null, 'table_large' );

    var t = d.table(n_rows,n_cols).loc(x,y);
    t.row_size('all', 20).col_size(2, 400).col_size(1, 80);

    settings.drawing_settings.sheets.forEach(function(sheet,i){
        t.cell(i+1,1).text(sheet.num);
        t.cell(i+1,2).text(sheet.desc);

    });


    t.all_cells().forEach(function(cell){
        cell.font('table_large_left').border('all');
    });

    t.mk();

    /*
    console.log(table_parts);
    d.append(table_parts);
    d.text([size.drawing.w/3,size.drawing.h/3], 'X', 'table');
    d.rect([size.drawing.w/3-5,size.drawing.h/3-5],[10,10],'box');

    t.cell(2,2).border('all').text('cell 2,2');
    t.cell(3,3).border('all').text('cell 3,3');
    t.cell(4,4).border('all').text('cell 4,4');
    t.cell(5,5).border('all').text('cell 5,5');



    t.cell(4,6).border('all').text('cell 4,6');
    t.cell(4,7).border('all').text('cell 4,7');
    t.cell(5,6).border('all').text('cell 5,6');
    t.cell(5,7).border('all').text('cell 5,7');


    //*/

    return d.drawing_parts;
};



module.exports = page;

},{"../mk_border":5,"../mk_drawing":6}],11:[function(require,module,exports){
var mk_drawing = require('../mk_drawing');
var mk_border = require('../mk_border');

var page = function(settings){
    var f = settings.f;

    d = mk_drawing(settings);

    var sheet_section = 'S';
    var sheet_num = '01';
    //d.append(mk_border(settings, sheet_section, sheet_num ));

    var size = settings.drawing_settings.size;
    var loc = settings.drawing_settings.loc;
    var system = settings.system;












    if( f.section_defined(settings, 'roof') ){



        var x, y, h, w, section_x, section_y, length_p, scale;

        var slope = system.roof.slope.split(':')[0];
        var angle_rad = Math.atan( Number(slope) /12 );
        //angle_rad = angle * (Math.PI/180);


        length_p = system.roof.length * Math.cos(angle_rad);
        system.roof.height = system.roof.length * Math.sin(angle_rad);

        var roof_ratio = system.roof.length / system.roof.width;
        var roof_plan_ratio = length_p / system.roof.width;


        if( system.roof.type === "Gable"){


            ///////
            // Rood plan view
            var plan_x = 60;
            var plan_y = 60;

            var plan_w, plan_h;
            if( length_p*2 > system.roof.width ){
                scale = 200/(length_p*2);
                plan_w = (length_p*2) * scale;
                plan_h = plan_w / (length_p*2 / system.roof.width);
            } else {
                scale = 300/(system.roof.width);
                plan_h = system.roof.width * scale;
                plan_w = plan_h * (length_p*2 / system.roof.width);
            }

            d.rect(
                [plan_x+plan_w/2, plan_y+plan_h/2],
                [plan_w, plan_h],
                "preview_structural"
            );

            d.poly([
                    [plan_x       , plan_y],
                    [plan_x+plan_w/2, plan_y],
                    [plan_x+plan_w/2, plan_y+plan_h],
                    [plan_x,        plan_y+plan_h],
                    [plan_x       , plan_y],
                ],
                "preview_structural_poly_unselected"
            );
            d.poly([
                    [plan_x+plan_w/2       , plan_y],
                    [plan_x+plan_w/2+plan_w/2, plan_y],
                    [plan_x+plan_w/2+plan_w/2, plan_y+plan_h],
                    [plan_x+plan_w/2,        plan_y+plan_h],
                    [plan_x+plan_w/2       , plan_y],
                ],
                "preview_structural_poly_selected"
            );

            d.line([
                    [plan_x+plan_w/2, plan_y],
                    [plan_x+plan_w/2, plan_y+plan_h]
                ],
                "preview_structural_dot"
            );

            /*
            d.text(
                [plan_x-20, plan_y+plan_h/2],
                system.roof.length.toString(),
                'dimention'
            );
            */

            d.text(
                [plan_x+plan_w+20, plan_y+plan_h/2],
                system.roof.width.toString(),
                'dimention',
                'dimention'
            );


            x = plan_x + 120;
            y = plan_y - 20;

            d.block('north arrow_left', [x,y]);


            ////////
            // roof crossection

            var cs_x = plan_x;
            var cs_y = plan_y + plan_h + 50;
            var cs_h = system.roof.height * scale;
            var cs_w = plan_w/2;

            d.line([
                    [cs_x+cs_w,   cs_y],
                    [cs_x+cs_w,   cs_y+cs_h],
                ],
                "preview_structural_dot"
            );
            d.line([
                    [cs_x+cs_w,   cs_y],
                    [cs_x+cs_w*2, cs_y+cs_h],
                    [cs_x,        cs_y+cs_h],
                    [cs_x+cs_w,   cs_y],
                ],
                "preview_structural"
            );
            d.text(
                [cs_x+cs_w-15, cs_y+cs_h*2/3],
                parseFloat( system.roof.height ).toFixed().toString(),
                'dimention',
                'dimention'
            );
            d.text(
                [cs_x+cs_w*1.5+20, cs_y+cs_h/3],
                parseFloat( system.roof.length ).toFixed().toString(),
                'dimention',
                'dimention'
            );



            //////
            // roof detail

            var detail_x = 30+400;
            var detail_y = 30;

            if( Number(system.roof.width) >= Number(system.roof.length) ){
                scale = 350/(system.roof.width);
            } else {
                scale = 350/(system.roof.length);
            }
            var detail_w = system.roof.width * scale;
            var detail_h = system.roof.length * scale;

            d.rect(
                [detail_x+detail_w/2, detail_y+detail_h/2],
                [detail_w, detail_h],
                "preview_structural_poly_selected_framed"
            );

            var a = 3;
            var offset_a = a * scale;

            d.line([
                    [detail_x,   detail_y+offset_a],
                    [detail_x+detail_w,   detail_y+offset_a],
                ],
                "preview_structural_dot"
            );
            d.line([
                    [detail_x,          detail_y+detail_h-offset_a],
                    [detail_x+detail_w, detail_y+detail_h-offset_a],
                ],
                "preview_structural_dot"
            );
            d.line([
                    [detail_x+offset_a, detail_y],
                    [detail_x+offset_a, detail_y+detail_h],
                ],
                "preview_structural_dot"
            );
            d.line([
                    [detail_x+detail_w-offset_a, detail_y],
                    [detail_x+detail_w-offset_a, detail_y+detail_h],
                ],
                "preview_structural_dot"
            );

            d.text(
                [detail_x-40, detail_y+detail_h/2],
                parseFloat( system.roof.length ).toFixed().toString(),
                'dimention',
                'dimention'
            );
            d.text(
                [detail_x+detail_w/2, detail_y+detail_h+40],
                parseFloat( system.roof.width ).toFixed().toString(),
                'dimention',
                'dimention'
            );

            d.text(
                [detail_x+ (offset_a)/2, detail_y+detail_h+15],
                'a',
                'dimention',
                'dimention'
            );
            d.text(
                [detail_x+detail_w-(offset_a)/2, detail_y+detail_h+15],
                'a',
                'dimention',
                'dimention'
            );
            d.text(
                [detail_x-15, detail_y+detail_h-(offset_a)/2],
                'a',
                'dimention',
                'dimention'
            );
            d.text(
                [detail_x-15, detail_y+(offset_a)/2],
                'a',
                'dimention',
                'dimention'
            );

            x = detail_x + detail_w + 25;
            y = detail_y + 120;

            d.block('north arrow_up', [x,y]);



            //////
            // Module options
            if( f.section_defined(settings, 'module') && f.section_defined(settings, 'array')){
                var r,c;

                var roof_length_avail = system.roof.length - (a*2);
                var roof_width_avail = system.roof.width - (a*2);

                var row_spacing;
                if( system.module.orientation === 'Portrait' ){
                    row_spacing = Number(system.module.length) + 1;
                    col_spacing = Number(system.module.width) + 1;
                    module_w = (Number(system.module.width)  )/12;
                    module_h = (Number(system.module.length) )/12;
                } else {
                    row_spacing = Number(system.module.width) + 1;
                    col_spacing = Number(system.module.length) + 1;
                    module_w = (Number(system.module.length))/12;
                    module_h = (Number(system.module.width) )/12;
                }

                row_spacing = row_spacing/12; //module dimentions are in inches
                col_spacing = col_spacing/12; //module dimentions are in inches

                var num_rows = Math.floor(roof_length_avail/row_spacing);
                var num_cols = Math.floor(roof_width_avail/col_spacing);

                //selected modules

                if( num_cols !== settings.temp.num_cols || num_rows !== settings.temp.num_rows ){
                    settings.webpage.selected_modules = {};
                    settings.webpage.selected_modules_total = 0;

                    for( r=1; r<=num_rows; r++){
                        settings.webpage.selected_modules[r] = {};
                        for( c=1; c<=num_cols; c++){
                            settings.webpage.selected_modules[r][c] = false;
                        }
                    }


                    settings.temp.num_cols = num_cols;
                    settings.temp.num_rows = num_rows;
                }


                x = detail_x + offset_a; //corner of usable space
                y = detail_y + offset_a;
                x += ( roof_width_avail - (col_spacing*num_cols))/2 *scale; // center array on roof
                y += ( roof_length_avail - (row_spacing*num_rows))/2 *scale;
                module_w = module_w * scale;
                module_h = module_h * scale;



                for( r=1; r<=num_rows; r++){

                    for( c=1; c<=num_cols; c++){

                        var layer;
                        if( settings.webpage.selected_modules[r][c] ) layer = 'preview_structural_module_selected';
                        else layer = 'preview_structural_module';
                        module_x = (c-1) * col_spacing * scale;
                        module_y = (r-1) * row_spacing * scale;

                        d.rect(
                            [x+module_x+module_w/2, y+module_y+module_h/2],
                            [module_w, module_h],
                            layer,
                            {
                                onclick: "g.f.toggle_module(this)",
                                module_ID:  (r) + ',' + (c)

                            }
                        );

                    }
                }

                d.text(
                    [detail_x+detail_w/2, detail_y+detail_h+100],
                    [
                        "Selected modules: " + parseFloat( settings.webpage.selected_modules_total ).toFixed().toString(),
                        "Calculated modules: " + parseFloat( settings.system.array.number_of_modules ).toFixed().toString(),
                    ],
                    'dimention',
                    'dimention'
                );

            }




        }
    }






    return d.drawing_parts;
};



module.exports = page;

},{"../mk_border":5,"../mk_drawing":6}],12:[function(require,module,exports){
'use strict';

var _ = require('underscore');

var mk_drawing = require('../mk_drawing');
var mk_border = require('../mk_border');

//var drawing_parts = [];
//d.link_drawing_parts(drawing_parts);

var page = function(settings){
    var d = mk_drawing(settings);
    var sheet_section = 'PV';
    var sheet_num = '01';
    //d.append(mk_border(settings, sheet_section, sheet_num ));

    var f = settings.f;

    //var components = settings.components;
    //var system = settings.system;
    var system = settings.system;

    var size = settings.drawing_settings.size;
    var loc = settings.drawing_settings.loc;




    var x, y, h, w;
    var offset;






////////////////////////////////////////
//#array
    if( f.section_defined(settings, 'module') && f.section_defined(settings, 'array') ){
        d.section('array');


        x = loc.array.right - size.string.w;
        y = loc.array.upper;
        //y -= size.string.h/2;


        //for( var i=0; i<system.DC.string_num; i++ ) {
        for( var i in _.range(system.array.num_strings)) {
            //var offset = i * size.wire_offset.base
            var offset_wire = size.wire_offset.min + ( size.wire_offset.base * i );

            d.block('string', [x,y]);
            // positive home run
            d.layer('DC_pos');
            d.line([
                [ x , loc.array.upper ],
                [ x , loc.array.upper-offset_wire ],
                [ loc.array.right+offset_wire , loc.array.upper-offset_wire ],
                [ loc.array.right+offset_wire , loc.jb_box.y-offset_wire],
                [ loc.jb_box.x , loc.jb_box.y-offset_wire],
            ]);

            // negative home run
            d.layer('DC_neg');
            d.line([
                [ x , loc.array.lower ],
                [ x , loc.array.lower_limit+offset_wire ],
                [ loc.array.right+offset_wire , loc.array.lower_limit+offset_wire ],
                [ loc.array.right+offset_wire , loc.jb_box.y+offset_wire],
                [ loc.jb_box.x , loc.jb_box.y+offset_wire],
            ]);

            x -= size.string.w;
        }

    //    d.rect(
    //        [ (loc.array.right+loc.array.left)/2, (loc.array.lower+loc.array.upper)/2 ],
    //        [ loc.array.right-loc.array.left, loc.array.lower-loc.array.upper ],
    //        'DC_pos');
    //

        d.layer('DC_ground');
        d.line([
            //[ loc.array.left , loc.array.lower + size.wire_offset.ground ],
            [ loc.array.left, loc.array.lower_limit + size.wire_offset.ground ],
            [ loc.array.right+size.wire_offset.ground , loc.array.lower_limit + size.wire_offset.ground ],
            [ loc.array.right+size.wire_offset.ground , loc.jb_box.y + size.wire_offset.ground],
            [ loc.jb_box.x , loc.jb_box.y+size.wire_offset.ground],
        ]);

        d.layer();


    }// else { console.log("Drawing: array not ready")}

///////////////////////////////
// combiner box

    if( f.section_defined(settings, 'DC') ){

        d.section("combiner");

        x = loc.jb_box.x;
        y = loc.jb_box.y;

        d.rect(
            [x,y],
            [size.jb_box.w,size.jb_box.h],
            'box'
        );

        for( i in _.range(system.array.num_strings)) {
            offset = size.wire_offset.min + ( size.wire_offset.base * i );

            d.layer('DC_pos');
            d.line([
                [ x , y-offset],
                [ x , y-offset],
            ]);
            d.block( 'terminal', {
                x: x,
                y: y-offset,
            });
            d.line([
                [ x , y-offset],
                [ loc.discbox.x-offset , y-offset],
                [ loc.discbox.x-offset , loc.discbox.y+size.discbox.h/2-size.terminal_diam],
                [ loc.discbox.x-offset , loc.discbox.y+size.discbox.h/2-size.terminal_diam-size.terminal_diam*3],
            ]);
            d.block( 'terminal', {
                x: loc.discbox.x-offset,
                y: loc.discbox.y+size.discbox.h/2-size.terminal_diam
            });

            d.layer('DC_neg');
            d.line([
                [ x, y+offset],
                [ x-size.fuse.w/2 , y+offset],
            ]);
            d.block( 'fuse', {
                x: x ,
                y: y+offset,
            });
            d.line([
                [ x+size.fuse.w/2 , y+offset],
                [ loc.discbox.x+offset , y+offset],
                [ loc.discbox.x+offset , loc.discbox.y+size.discbox.h/2-size.terminal_diam],
                [ loc.discbox.x+offset , loc.discbox.y+size.discbox.h/2-size.terminal_diam-size.terminal_diam*3],
            ]);
            d.block( 'terminal', {
                x: loc.discbox.x+offset,
                y: loc.discbox.y+size.discbox.h/2-size.terminal_diam
            });
            d.layer();
        }

        //d.layer('DC_ground');
        //d.line([
        //    [ loc.array.left , loc.array.lower + size.module.w + size.wire_offset.ground ],
        //    [ loc.array.right+size.wire_offset.ground , loc.array.lower + size.module.w + size.wire_offset.ground ],
        //    [ loc.array.right+size.wire_offset.ground , loc.array.y + size.module.w + size.wire_offset.ground],
        //    [ loc.array.x , loc.array.y+size.module.w+size.wire_offset.ground],
        //]);

        //d.layer();

        // Ground
        //offset = size.wire_offset.gap + size.wire_offset.ground;
        offset = size.wire_offset.ground;

        d.layer('DC_ground');
        d.line([
            [ x , y+offset],
            [ x , y+offset],
        ]);
        d.block( 'terminal', {
            x: x,
            y: y+offset,
        });
        d.line([
            [ x , y+offset],
            [ loc.discbox.x+offset , y+offset],
            [ loc.discbox.x+offset , loc.discbox.y+size.discbox.h/2-size.terminal_diam],
            [ loc.discbox.x+offset , loc.discbox.y+size.discbox.h/2-size.terminal_diam-size.terminal_diam*3],
        ]);
        d.block( 'terminal', {
            x: loc.discbox.x+offset,
            y: loc.discbox.y+size.discbox.h/2-size.terminal_diam
        });
        d.layer();


    ///////////////////////////////
        // DC disconect
        d.section("DC diconect");


        d.rect(
            [loc.discbox.x, loc.discbox.y],
            [size.discbox.w,size.discbox.h],
            'box'
        );

        // DC disconect combiner d.lines

        x = loc.discbox.x;
        y = loc.discbox.y + size.discbox.h/2;

        if( system.array.num_strings > 1){
            var offset_min = size.wire_offset.min;
            var offset_max = size.wire_offset.min + ( (system.array.num_strings -1) * size.wire_offset.base );
            d.line([
                [ x-offset_min, y-size.terminal_diam-size.terminal_diam*3],
                [ x-offset_max, y-size.terminal_diam-size.terminal_diam*3],
            ], 'DC_pos');
            d.line([
                [ x+offset_min, y-size.terminal_diam-size.terminal_diam*3],
                [ x+offset_max, y-size.terminal_diam-size.terminal_diam*3],
            ], 'DC_neg');
        }

        // Inverter conection
        //d.line([
        //    [ x-offset_min, y-size.terminal_diam-size.terminal_diam*3],
        //    [ x-offset_min, y-size.terminal_diam-size.terminal_diam*3],
        //],'DC_pos');

        //offset = offset_max - offset_min;
        offset = size.wire_offset.min;

        // neg
        d.line([
            [ x+offset, y-size.terminal_diam-size.terminal_diam*3],
            [ x+offset, loc.inverter.y+size.inverter.h/2-size.terminal_diam ],
        ],'DC_neg');
        d.block( 'terminal', {
            x: x+offset,
            y: loc.inverter.y+size.inverter.h/2-size.terminal_diam,
        });

        // pos
        d.line([
            [ x-offset, y-size.terminal_diam-size.terminal_diam*3],
            [ x-offset, loc.inverter.y+size.inverter.h/2-size.terminal_diam ],
        ],'DC_pos');
        d.block( 'terminal', {
            x: x-offset,
            y: loc.inverter.y+size.inverter.h/2-size.terminal_diam,
        });

        // ground
        //offset = size.wire_offset.gap + size.wire_offset.ground;
        offset = size.wire_offset.ground;
        d.line([
            [ x+offset, y-size.terminal_diam-size.terminal_diam*3],
            [ x+offset, loc.inverter.y+size.inverter.h/2-size.terminal_diam ],
        ],'DC_ground');
        d.block( 'terminal', {
            x: x+offset,
            y: loc.inverter.y+size.inverter.h/2-size.terminal_diam,
        });

    }




///////////////////////////////
//#inverter
    if( f.section_defined(settings, 'inverter') ){

        d.section("inverter");


        x = loc.inverter.x;
        y = loc.inverter.y;


        //frame
        d.layer('box');
        d.rect(
            [x,y],
            [size.inverter.w, size.inverter.h]
        );
        // Label at top (Inverter, make, model, ...)
        d.layer('text');
        d.text(
            [loc.inverter.x, loc.inverter.top + size.inverter.text_gap ],
            [ 'Inverter', settings.system.inverter.make + " " + settings.system.inverter.model ],
            'text',
            'label'
        );
        d.layer();

    //#inverter symbol
        d.section("inverter symbol");

        x = loc.inverter.x;
        y = loc.inverter.y;

        w = size.inverter.symbol_w;
        h = size.inverter.symbol_h;

        var space = w*1/12;

        // Inverter symbol
        d.layer('box');

        // box
        d.rect(
            [x,y],
            [w, h]
        );
        // diaganal
        d.line([
            [x-w/2, y+h/2],
            [x+w/2, y-h/2],

        ]);
        // DC
        d.line([
            [x - w/2 + space,
                y - h/2 + space],
            [x - w/2 + space*6,
                y - h/2 + space],
        ]);
        d.line([
            [x - w/2 + space,
                y - h/2 + space*2],
            [x - w/2 + space*2,
                y - h/2 + space*2],
        ]);
        d.line([
            [x - w/2 + space*3,
                y - h/2 + space*2],
            [x - w/2 + space*4,
                y - h/2 + space*2],
        ]);
        d.line([
            [x - w/2 + space*5,
                y - h/2 + space*2],
            [x - w/2 + space*6,
                y - h/2 + space*2],
        ]);

        // AC
        d.line([
            [x + w/2 - space,
                y + h/2 - space*1.5],
            [x + w/2 - space*2,
                y + h/2 - space*1.5],
        ]);
        d.line([
            [x + w/2 - space*3,
                y + h/2 - space*1.5],
            [x + w/2 - space*4,
                y + h/2 - space*1.5],
        ]);
        d.line([
            [x + w/2 - space*5,
                y + h/2 - space*1.5],
            [x + w/2 - space*6,
                y + h/2 - space*1.5],
        ]);
        d.layer();





    }





//#AC_discconect
    if( f.section_defined(settings, 'AC') ){
        d.section("AC_discconect");

        x = loc.AC_disc.x;
        y = loc.AC_disc.y;
        var padding = size.terminal_diam;

        d.layer('box');
        d.rect(
            [x, y],
            [size.AC_disc.w, size.AC_disc.h]
        );
        d.layer();


    //d.circ([x,y],5);



    //#AC load center
        d.section("AC load center");

        var breaker_spacing = size.AC_loadcenter.breakers.spacing;

        x = loc.AC_loadcenter.x;
        y = loc.AC_loadcenter.y;
        w = size.AC_loadcenter.w;
        h = size.AC_loadcenter.h;

        d.rect([x,y],
            [w,h],
            'box'
        );

        d.text([x,y-h*0.4],
            [system.AC.loadcenter_types, 'Load Center'],
            'text',
            'label'
        );
        w = size.AC_loadcenter.breaker.w;
        h = size.AC_loadcenter.breaker.h;

        padding = loc.AC_loadcenter.x - loc.AC_loadcenter.breakers.left - size.AC_loadcenter.breaker.w;

        y = loc.AC_loadcenter.breakers.top;
        y += size.AC_loadcenter.breakers.spacing/2;
        for( var i=0; i<size.AC_loadcenter.breakers.num; i++){
            d.rect([x-padding-w/2,y],[w,h],'box');
            d.rect([x+padding+w/2,y],[w,h],'box');
            y += breaker_spacing;
        }

        var s, l;

        l = loc.AC_loadcenter.neutralbar;
        s = size.AC_loadcenter.neutralbar;
        d.rect([l.x,l.y], [s.w,s.h], 'AC_neutral' );

        l = loc.AC_loadcenter.groundbar;
        s = size.AC_loadcenter.groundbar;
        d.rect([l.x,l.y], [s.w,s.h], 'AC_ground' );

        d.block('ground', [l.x,l.y+s.h/2]);



    // AC d.lines
        d.section("AC d.lines");

        x = loc.inverter.bottom_right.x;
        y = loc.inverter.bottom_right.y;
        x -= size.terminal_diam * (system.AC.num_conductors+1);
        y -= size.terminal_diam;

        var conduit_y = loc.AC_conduit.y;
        padding = size.terminal_diam;
        //var AC_d.layer_names = ['AC_ground', 'AC_neutral', 'AC_L1', 'AC_L2', 'AC_L2'];

        for( var i=0; i < system.AC.num_conductors; i++ ){
            d.block('terminal', [x,y] );
            d.layer('AC_'+system.AC.conductors[i]);
            d.line([
                [x, y],
                [x, loc.AC_disc.bottom - padding*2 - padding*i  ],
                [loc.AC_disc.left, loc.AC_disc.bottom - padding*2 - padding*i ],
            ]);
            x += size.terminal_diam;
        }
        d.layer();

        x = loc.AC_disc.x;
        y = loc.AC_disc.y + size.AC_disc.h/2;
        y -= padding*2;

        if( system.AC.conductors && system.AC.conductors.indexOf('ground')+1 ) {
            d.layer('AC_ground');
            d.line([
                [ x-size.AC_disc.w/2, y ],
                [ x+size.AC_disc.w/2+padding*2, y ],
                [ x+size.AC_disc.w/2+padding*2, conduit_y + breaker_spacing*2 ],
                [ loc.AC_loadcenter.left+padding*2, conduit_y + breaker_spacing*2 ],
                //[ loc.AC_loadcenter.left+padding*2, y ],
                //[ loc.AC_loadcenter.groundbar.x-padding, y ],
                //[ loc.AC_loadcenter.groundbar.x-padding, loc.AC_loadcenter.groundbar.y+size.AC_loadcenter.groundbar.h/2 ],
                [ loc.AC_loadcenter.left+padding*2, loc.AC_loadcenter.groundbar.y ],
                [ loc.AC_loadcenter.groundbar.x-size.AC_loadcenter.groundbar.w/2, loc.AC_loadcenter.groundbar.y ],
            ]);
        }

        if( system.AC.conductors && system.AC.conductors.indexOf('neutral')+1 ) {
            y -= padding;
            d.layer('AC_neutral');
            d.line([
                [ x-size.AC_disc.w/2, y ],
                [ x+padding*3*2, y ],
                [ x+padding*3*2, conduit_y + breaker_spacing*1 ],
                [ loc.AC_loadcenter.neutralbar.x, conduit_y + breaker_spacing*1 ],
                [ loc.AC_loadcenter.neutralbar.x,
                    loc.AC_loadcenter.neutralbar.y-size.AC_loadcenter.neutralbar.h/2 ],
            ]);
        }



        for( var i=1; i <= 3; i++ ) {
            if( system.AC.conductors && system.AC.conductors.indexOf('L'+i)+1 ) {
                y -= padding;
                d.layer('AC_L'+i);
                d.line([
                    [ x-size.AC_disc.w/2, y ],
                    [ x+padding*3*(2-i), y ],
                    [ x+padding*3*(2-i), loc.AC_disc.switch_bottom ],
                ]);
                d.block('terminal', [ x-padding*(i-2)*3, loc.AC_disc.switch_bottom ] );
                d.block('terminal', [ x-padding*(i-2)*3, loc.AC_disc.switch_top ] );
                d.line([
                    [ x-padding*(i-2)*3, loc.AC_disc.switch_top ],
                    [ x-padding*(i-2)*3, conduit_y-breaker_spacing*(i-1) ],
                    [ loc.AC_loadcenter.breakers.left, conduit_y-breaker_spacing*(i-1) ],
                ]);

            }

        }



    }




// Wire table
    d.section("Wire table");

///*

    x = loc.wire_table.x;
    y = loc.wire_table.y;

    if( system.AC.num_conductors ) {
        var n_rows = 2 + system.AC.num_conductors;
        var n_cols = 6;
        var row_height = 15;
        var column_width = {
            number: 25,
            conductor: 50,
            wire_gauge: 25,
            wire_type: 75,
            conduit_size: 35,
            conduit_type: 75,
        };

        h = n_rows*row_height;

        var t = d.table(n_rows,n_cols).loc(x,y);
        t.row_size('all', row_height)
            .col_size(1, column_width.number)
            .col_size(2, column_width.conductor)
            .col_size(3, column_width.wire_gauge)
            .col_size(4, column_width.wire_type)
            .col_size(5, column_width.conduit_size)
            .col_size(6, column_width.conduit_type);

        t.all_cells().forEach(function(cell){
            cell.font('table').border('all');
        });
        t.cell(1,1).border('B', false);
        t.cell(1,3).border('R', false);
        t.cell(1,5).border('R', false);

        t.cell(1,3).font('table_left').text('Wire');
        t.cell(1,5).font('table_left').text('Conduit');

        t.cell(2,3).font('table').text('Conductors');
        t.cell(2,3).font('table').text('AWG');
        t.cell(2,4).font('table').text('Type');
        t.cell(2,5).font('table').text('Size');
        t.cell(2,6).font('table').text('Type');

        for( i=1; i<=system.AC.num_conductors; i++){
            t.cell(2+i,1).font('table').text(i.toString());
            t.cell(2+i,2).font('table_left').text( f.pretty_word(settings.system.AC.conductors[i-1]) );

        }


        //d.text( [x+w/2, y-row_height], f.pretty_name(section_name),'table' );


        t.mk();

    }

//*/












// voltage drop
    d.section("voltage drop");


    x = loc.volt_drop_table.x;
    y = loc.volt_drop_table.y;
    w = size.volt_drop_table.w;
    h = size.volt_drop_table.h;

    d.layer('table');
    d.rect( [x,y], [w,h] );

    y -= h/2;
    y += 10;

    d.text( [x,y], 'Voltage Drop', 'text', 'table');


// general notes
    d.section("general notes");

    x = loc.general_notes.x;
    y = loc.general_notes.y;
    w = size.general_notes.w;
    h = size.general_notes.h;

    d.layer('table');
    d.rect( [x,y], [w,h] );

    y -= h/2;
    y += 10;

    d.text( [x,y], 'General Notes', 'text', 'table');


    d.section();

    return d.drawing_parts;
};



module.exports = page;

},{"../mk_border":5,"../mk_drawing":6,"underscore":23}],13:[function(require,module,exports){
var mk_drawing = require('../mk_drawing');
var mk_border = require('../mk_border');

var page = function(settings){
    var f = settings.f;

    d = mk_drawing(settings);

    var sheet_section = 'PV';
    var sheet_num = '02';
    //d.append(mk_border(settings, sheet_section, sheet_num ));

    var size = settings.drawing_settings.size;
    var loc = settings.drawing_settings.loc;


    d.text(
        [size.drawing.w/2, size.drawing.h/2],
        'Calculation Sheet',
        'text',
        'title2'
    );


    x = size.drawing.frame_padding*6;
    y = size.drawing.frame_padding*6 +20;

    d.layer('table');


    for( var section_name in settings.system ){
        if( f.section_defined(settings, section_name) ){
            var section = settings.system[section_name];

            var n = Object.keys(section).length;

            var n_rows = n+0;
            var n_cols = 2;

            var row_height = 15;
            h = n_rows*row_height;


            var t = d.table(n_rows,n_cols).loc(x,y);
            t.row_size('all', row_height).col_size(1, 100).col_size(2, 125);
            w = 100+80;

            var r = 1;
            var value;
            for( var value_name in section ){
                t.cell(r,1).text( f.pretty_name(value_name) );
                if( ! section[value_name]) {
                    value = '-';
                } else if( section[value_name].constructor === Array ){
                    value = section[value_name].toString();
                } else if( section[value_name].constructor === Object ){
                    value = '( )';
                } else if( isNaN(section[value_name]) ){
                    value = section[value_name];
                } else {
                    value = parseFloat(section[value_name]).toFixed(2);
                }
                t.cell(r,2).text( value );
                r++;

            }

            d.text( [x+w/2, y-row_height], f.pretty_name(section_name),'table' );




            t.all_cells().forEach(function(cell){
                cell.font('table').border('all');
            });

            t.mk();

            //*/
            y += h + 30;

            if( y > ( settings.drawing_settings.size.drawing.h * 0.8 ) ) {
                y =
                    y = size.drawing.frame_padding*6 +20;
                    x += w*1.5;
            }

        } else {

            //console.log('not defined: ', section_name, section);
        }




    }

    d.layer();


    return d.drawing_parts;
};



module.exports = page;

},{"../mk_border":5,"../mk_drawing":6}],14:[function(require,module,exports){
var mk_drawing = require('../mk_drawing');
var mk_border = require('../mk_border');
var f = require('../functions');

var page = function(settings){
    console.log("** Making preview 1");

    var d = mk_drawing(settings);



    var size = settings.drawing_settings.size;
    var loc = settings.drawing_settings.loc;
    var system = settings.system;

    var x, y, h, w, section_x, section_y;

    w = size.preview.module.w;
    h = size.preview.module.h;
    loc.preview.array.bottom = loc.preview.array.top + h*1.25*system.array.modules_per_string + h*3/4;
    //loc.preview.array.right = loc.preview.array.left + w*1.25*system.array.num_strings + w*2;
    loc.preview.array.right = loc.preview.array.left + w*1.25*8 + w*2;

    loc.preview.inverter.center = 500 ;
    w = size.preview.inverter.w;
    loc.preview.inverter.left = loc.preview.inverter.center - w/2;
    loc.preview.inverter.right = loc.preview.inverter.center + w/2;

    loc.preview.DC.left = loc.preview.array.right;
    loc.preview.DC.right = loc.preview.inverter.left;
    loc.preview.DC.center = ( loc.preview.DC.right + loc.preview.DC.left )/2;

    loc.preview.AC.left = loc.preview.inverter.right;
    loc.preview.AC.right = loc.preview.AC.left + 300;
    loc.preview.AC.center = ( loc.preview.AC.right + loc.preview.AC.left )/2;


// TODO fix: sections must be defined in order, or there are areas

    if( f.section_defined(settings, 'array') && f.section_defined(settings, 'module') ){
        d.layer('preview_array');

        w = size.preview.module.w;
        h = size.preview.module.h;
        var offset = 40;

        for( var s=0; s<system.array.num_strings; s++ ){
            x = loc.preview.array.left + w*1.25*s;
            // string wiring
            d.line([
                    [ x , loc.preview.array.top ],
                    [ x , loc.preview.array.bottom ],
                ]
            );
            // modules
            for( var m=0; m<system.array.modules_per_string; m++ ){
                y = loc.preview.array.top + h + h*1.25*m;
                // modules
                d.rect(
                    [ x , y ],
                    [w,h],
                    'preview_module'
                );
            }
        }

        // top array conduit
        d.line([
                [ loc.preview.array.left , loc.preview.array.top ],
                [ loc.preview.array.right - w, loc.preview.array.top ],
                [ loc.preview.array.right , loc.preview.array.top ],
            ]
        );
        // bottom array conduit
        d.line([
                [ loc.preview.array.left , loc.preview.array.bottom ],
                [ loc.preview.array.right - w , loc.preview.array.bottom ],
                [ loc.preview.array.right - w , loc.preview.array.top ],
            ]
        );

        y = loc.preview.array.top;
        h = size.preview.module.h;

        d.text(
            [ loc.preview.DC.center, y+h/2+offset ],
            [
                'Array DC',
                'Strings: ' + parseFloat(system.array.num_strings).toFixed(),
                'Modules: ' + parseFloat(system.array.modules_per_string).toFixed(),
                'Pmp: ' + parseFloat(system.array.pmp).toFixed(),
                'Imp: ' + parseFloat(system.array.imp).toFixed(),
                'Vmp: ' + parseFloat(system.array.vmp).toFixed(),
                'Isc: ' + parseFloat(system.array.isc).toFixed(),
                'Voc: ' + parseFloat(system.array.voc).toFixed(),
            ],
            'text',
            'preview text'
        );
    }

    if( f.section_defined(settings, 'DC') ){
        d.layer('preview_DC');

        //y = y;
        y = loc.preview.array.top;
        w = size.preview.module.w;
        h = size.preview.module.h;

        d.line([
                [ loc.preview.DC.left , y ],
                [ loc.preview.DC.right, y ],
            ]
        );
        d.rect(
            [loc.preview.DC.center,y],
            [w,h],
            'preview_DC_box'
        );

    }

    if( f.section_defined(settings, 'inverter') ){

        d.layer('preview_inverter');

        y = y;
        w = size.preview.inverter.w;
        h = size.preview.inverter.h;

        d.rect(
            [loc.preview.inverter.center,y],
            [w,h],
            'preview_inverter_box'
        );
        d.text(
            [loc.preview.inverter.center,y+h/2+offset],
            [
                'Inverter',
                system.inverter.make,
                system.inverter.model,
            ],
            'text',
            'preview text'
        );
    }

    if( f.section_defined(settings, 'AC') ){

        d.layer('preview_AC');


        y = y;
        d.line([
                [ loc.preview.AC.left, y ],
                [ loc.preview.AC.right, y ],
            ]
        );
        w = size.preview.AC.w;
        h = size.preview.AC.h;
        d.rect(
            [loc.preview.AC.center,y],
            [w,h],
            'preview_AC_box'
        );
        w = size.preview.loadcenter.w;
        h = size.preview.loadcenter.h;
        d.rect(
            [ loc.preview.AC.right-w/2, y+h/4 ],
            [w,h],
            'preview_AC_box'
        );

        d.text(
            [loc.preview.AC.center,y+h/2+offset],
            [
                'AC',

            ],
            'text',
            'preview text'
        );

    }

    return d.drawing_parts;
};



module.exports = page;

},{"../functions":3,"../mk_border":5,"../mk_drawing":6}],15:[function(require,module,exports){
var mk_drawing = require('../mk_drawing');
var mk_border = require('../mk_border');
var f = require('../functions');

var page = function(settings){
    console.log("** Making preview 2");

    var d = mk_drawing(settings);

    if( f.section_defined(settings, 'roof') ){

        var size = settings.drawing_settings.size;
        var loc = settings.drawing_settings.loc;
        var system = settings.system;

        var x, y, h, w, section_x, section_y, length_p, scale;

        var slope = system.roof.slope.split(':')[0];
        var angle_rad = Math.atan( Number(slope) /12 );
        //angle_rad = angle * (Math.PI/180);


        length_p = system.roof.length * Math.cos(angle_rad);
        system.roof.height = system.roof.length * Math.sin(angle_rad);

        var roof_ratio = system.roof.length / system.roof.width;
        var roof_plan_ratio = length_p / system.roof.width;


        if( system.roof.type === "Gable"){


            ///////
            // Rood plan view
            var plan_x = 30;
            var plan_y = 30;

            var plan_w, plan_h;
            if( length_p*2 > system.roof.width ){
                scale = 250/(length_p*2);
                plan_w = (length_p*2) * scale;
                plan_h = plan_w / (length_p*2 / system.roof.width);
            } else {
                scale = 400/(system.roof.width);
                plan_h = system.roof.width * scale;
                plan_w = plan_h * (length_p*2 / system.roof.width);
            }

            d.rect(
                [plan_x+plan_w/2, plan_y+plan_h/2],
                [plan_w, plan_h],
                "preview_structural"
            );

            d.poly([
                    [plan_x       , plan_y],
                    [plan_x+plan_w/2, plan_y],
                    [plan_x+plan_w/2, plan_y+plan_h],
                    [plan_x,        plan_y+plan_h],
                    [plan_x       , plan_y],
                ],
                "preview_structural_poly_unselected"
            );
            d.poly([
                    [plan_x+plan_w/2       , plan_y],
                    [plan_x+plan_w/2+plan_w/2, plan_y],
                    [plan_x+plan_w/2+plan_w/2, plan_y+plan_h],
                    [plan_x+plan_w/2,        plan_y+plan_h],
                    [plan_x+plan_w/2       , plan_y],
                ],
                "preview_structural_poly_selected"
            );

            d.line([
                    [plan_x+plan_w/2, plan_y],
                    [plan_x+plan_w/2, plan_y+plan_h]
                ],
                "preview_structural_dot"
            );

            /*
            d.text(
                [plan_x-20, plan_y+plan_h/2],
                system.roof.length.toString(),
                'dimention'
            );
            */

            d.text(
                [plan_x+plan_w+20, plan_y+plan_h/2],
                system.roof.width.toString(),
                'dimention'
            );




            ////////
            // roof crossection

            var cs_x = 30;
            var cs_y = 30+plan_h+50;
            var cs_h = system.roof.height * scale;
            var cs_w = plan_w/2;

            d.line([
                    [cs_x+cs_w,   cs_y],
                    [cs_x+cs_w,   cs_y+cs_h],
                ],
                "preview_structural_dot"
            );
            d.line([
                    [cs_x+cs_w,   cs_y],
                    [cs_x+cs_w*2, cs_y+cs_h],
                    [cs_x,        cs_y+cs_h],
                    [cs_x+cs_w,   cs_y],
                ],
                "preview_structural"
            );
            d.text(
                [cs_x+cs_w-15, cs_y+cs_h*2/3],
                parseFloat( system.roof.height ).toFixed().toString(),
                'dimention'
            );
            d.text(
                [cs_x+cs_w*1.5+20, cs_y+cs_h/3],
                parseFloat( system.roof.length ).toFixed().toString(),
                'dimention'
            );



            //////
            // roof detail

            var detail_x = 30+450;
            var detail_y = 30;

            if( Number(system.roof.width) >= Number(system.roof.length) ){
                scale = 450/(system.roof.width);
            } else {
                scale = 450/(system.roof.length);
            }
            var detail_w = system.roof.width * scale;
            var detail_h = system.roof.length * scale;

            d.rect(
                [detail_x+detail_w/2, detail_y+detail_h/2],
                [detail_w, detail_h],
                "preview_structural_poly_selected_framed"
            );

            var a = 3;
            var offset_a = a * scale;

            d.line([
                    [detail_x,   detail_y+offset_a],
                    [detail_x+detail_w,   detail_y+offset_a],
                ],
                "preview_structural_dot"
            );
            d.line([
                    [detail_x,          detail_y+detail_h-offset_a],
                    [detail_x+detail_w, detail_y+detail_h-offset_a],
                ],
                "preview_structural_dot"
            );
            d.line([
                    [detail_x+offset_a, detail_y],
                    [detail_x+offset_a, detail_y+detail_h],
                ],
                "preview_structural_dot"
            );
            d.line([
                    [detail_x+detail_w-offset_a, detail_y],
                    [detail_x+detail_w-offset_a, detail_y+detail_h],
                ],
                "preview_structural_dot"
            );

            d.text(
                [detail_x-40, detail_y+detail_h/2],
                parseFloat( system.roof.length ).toFixed().toString(),
                'dimention'
            );
            d.text(
                [detail_x+detail_w/2, detail_y+detail_h+40],
                parseFloat( system.roof.width ).toFixed().toString(),
                'dimention'
            );

            d.text(
                [detail_x+ (offset_a)/2, detail_y+detail_h+15],
                'a',
                'dimention'
            );
            d.text(
                [detail_x+detail_w-(offset_a)/2, detail_y+detail_h+15],
                'a',
                'dimention'
            );
            d.text(
                [detail_x-15, detail_y+detail_h-(offset_a)/2],
                'a',
                'dimention'
            );
            d.text(
                [detail_x-15, detail_y+(offset_a)/2],
                'a',
                'dimention'
            );





            //////
            // Module options
            if( f.section_defined(settings, 'module') && f.section_defined(settings, 'array')){
                var r,c;

                var roof_length_avail = system.roof.length - (a*2);
                var roof_width_avail = system.roof.width - (a*2);

                var row_spacing;
                if( system.module.orientation === 'Portrait' ){
                    row_spacing = Number(system.module.length) + 1;
                    col_spacing = Number(system.module.width) + 1;
                    module_w = (Number(system.module.width)  )/12;
                    module_h = (Number(system.module.length) )/12;
                } else {
                    row_spacing = Number(system.module.width) + 1;
                    col_spacing = Number(system.module.length) + 1;
                    module_w = (Number(system.module.length))/12;
                    module_h = (Number(system.module.width) )/12;
                }

                row_spacing = row_spacing/12; //module dimentions are in inches
                col_spacing = col_spacing/12; //module dimentions are in inches

                var num_rows = Math.floor(roof_length_avail/row_spacing);
                var num_cols = Math.floor(roof_width_avail/col_spacing);

                //selected modules

                if( num_cols !== settings.temp.num_cols || num_rows !== settings.temp.num_rows ){
                    settings.webpage.selected_modules = {};
                    settings.webpage.selected_modules_total = 0;

                    for( r=1; r<=num_rows; r++){
                        settings.webpage.selected_modules[r] = {};
                        for( c=1; c<=num_cols; c++){
                            settings.webpage.selected_modules[r][c] = false;
                        }
                    }


                    settings.temp.num_cols = num_cols;
                    settings.temp.num_rows = num_rows;
                }


                x = detail_x + offset_a; //corner of usable space
                y = detail_y + offset_a;
                x += ( roof_width_avail - (col_spacing*num_cols))/2 *scale; // center array on roof
                y += ( roof_length_avail - (row_spacing*num_rows))/2 *scale;
                module_w = module_w * scale;
                module_h = module_h * scale;



                for( r=1; r<=num_rows; r++){

                    for( c=1; c<=num_cols; c++){

                        var layer;
                        if( settings.webpage.selected_modules[r][c] ) layer = 'preview_structural_module_selected';
                        else layer = 'preview_structural_module';
                        module_x = (c-1) * col_spacing * scale;
                        module_y = (r-1) * row_spacing * scale;

                        d.rect(
                            [x+module_x+module_w/2, y+module_y+module_h/2],
                            [module_w, module_h],
                            layer,
                            {
                                onclick: "g.f.toggle_module(this)",
                                module_ID:  (r) + ',' + (c)

                            }
                        );

                    }
                }

                d.text(
                    [detail_x+detail_w/2, detail_y+detail_h+100],
                    [
                        "Selected modules: " + parseFloat( settings.webpage.selected_modules_total ).toFixed().toString(),
                        "Calculated modules: " + parseFloat( settings.system.array.number_of_modules ).toFixed().toString(),
                    ],
                    'dimention'
                );

            }

            x = detail_x + 475;
            y = detail_y + 120;

            d.block('north arrow_up', [x,y]);

            x = 120;
            y = 15;

            d.block('north arrow_left', [x,y]);
//*/
        }


        /*




        d.line([
            [x,    y],
            [x+dx, y-dy],
            [x+dx, y],
            [x,    y],
            ]
        );

        d.text(
            [x+dx/2-10, y-dy/2-20],
            system.roof.height.toString(),
            'dimention'
        );
        d.text(
            [x+dx/2+5, y-15],
            angle.toString(),
            'dimention'
        );


        x = x+dx+100;
        y = y;


        //*/

    }

    return d.drawing_parts;
};



module.exports = page;

},{"../functions":3,"../mk_border":5,"../mk_drawing":6}],16:[function(require,module,exports){
'use strict';
var mk_sheet = require('./mk_sheet');

var process = function(settings) {
    var f = settings.f;

    //copy inputs from settings.input to settings.system.
    f.merge_objects(settings.user_input, settings.system);


    //console.log('---settings---', settings);
    var config_options = settings.config_options;
    var system = settings.system;
    var loc = settings.drawing_settings.loc;
    var size = settings.drawing_settings.size;
    var state = settings.state;

    var inputs = settings.inputs;



// Update settings and calculations

    if( state.database_loaded ){
        inputs.DC = settings.inputs.DC || {};
        inputs.DC.wire_size = settings.inputs.DC.wire_size || {};
        inputs.DC.wire_size.options = inputs.DC.wire_size.options || f.obj_names(settings.config_options.NEC_tables['Ch 9 Table 8 Conductor Properties']);


    }



    //console.log("process");
    //console.log(system.module.make);

    inputs.module.make.options = f.obj_names(settings.components.modules);
    if( system.module.make ) {
        inputs.module.model.options  = f.obj_names( settings.components.modules[system.module.make] );
    }

    if( system.module.model ) {
        var specs = settings.components.modules[system.module.make][system.module.model];
        for( var spec_name in specs ){
            if( spec_name !== 'module_id' ){
                system.module[spec_name] = specs[spec_name];
            }
        }
        //system.module.specs = settings.components.modules[system.module.make][system.module.model];
    }

    if( f.section_defined(settings, 'array') && f.section_defined(settings, 'module') ){
        system.array = system.array || {};
        system.array.isc = system.module.isc * system.array.num_strings;
        system.array.voc = system.module.voc * system.array.modules_per_string;
        system.array.imp = system.module.imp * system.array.num_strings;
        system.array.vmp = system.module.vmp * system.array.modules_per_string;
        system.array.pmp = system.array.vmp  * system.array.imp;

        system.array.number_of_modules = system.array.modules_per_string * system.array.num_strings;


    }


    if( f.section_defined(settings, 'DC') ){

        system.DC.wire_size = "-Undefined-";

    }

    inputs.inverter.make.options = f.obj_names(settings.components.inverters);
    if( system.inverter.make ) {
        inputs.inverter.model.options = f.obj_names( settings.components.inverters[system.inverter.make] );
    }
    if( f.section_defined(settings, 'inverter') ){

    }

    //inputs.AC.loadcenter_type = settings.f.obj_names(inputs.AC.loadcenter_types);
    if( system.AC.loadcenter_types ) {
        var loadcenter_type = system.AC.loadcenter_types;
        var AC_options = inputs.AC.loadcenter_types[loadcenter_type];
        inputs.AC.type.options = AC_options;
        //in.opt.AC.types[loadcenter_type];

        //inputs.AC['type'] = f.obj_names( settings.in.opt.AC.type );
    }
    if( system.AC.type ) {
        system.AC.conductors = settings.in.opt.AC.types[system.AC.type];
        system.AC.num_conductors = system.AC.conductors.length;

    }
    if( f.section_defined(settings, 'AC') ){

        system.AC.wire_size = "-Undefined-";
    }

    size.wire_offset.max = size.wire_offset.min + system.array.num_strings * size.wire_offset.base;
    size.wire_offset.ground = size.wire_offset.max + size.wire_offset.base*1;
    loc.array.left = loc.array.right - ( size.string.w * system.array.num_strings ) - ( size.module.frame.w*3/4 ) ;




    if( f.section_defined(settings, 'location') ){
        //console.log('address ready');
        //f.request_geocode();
        settings.perm.location.new_address = false;
        for( var name in settings.system.location ){
            if( settings.system.location[name] !== settings.perm.location[name]){
                settings.perm.location.new_address = true;
            }
            settings.perm.location[name] = settings.system.location[name];
        }

    }





// Update drawing

    // Make blocks
    f.mk_blocks(settings);


    // Make drawing
    var i, p;

    // Not needed on server


    settings.drawing.parts = {};
    settings.drawing.svgs = {};
    settings.drawing_settings.sheets.forEach(function(sheet_info, i){
        p = i+1;
        settings.drawing.parts[p] = mk_sheet(settings, sheet_info);
//        settings.drawing.parts[p] = f.mk_sheet_num[p](settings);

    });

};



module.exports = process;

},{"./mk_sheet":8}],17:[function(require,module,exports){
'use strict';


var settings_dev_defaults = function(settings) {
    console.log('Dev mode - defaults on');

    //console.log('---settings---', settings);
    var config_options = settings.config_options;
    var inputs = settings.inputs;
    var user_input = settings.user_input;
    var loc = settings.drawing_settings.loc;
    var size = settings.drawing_settings.size;
    var state = settings.state;

    if( state.database_loaded ){
        inputs.DC = settings.inputs.DC || {};
        inputs.DC.wire_size = settings.inputs.DC.wire_size || {};
        inputs.DC.wire_size.options = inputs.DC.wire_size.options || g.f.obj_names(settings.config_options.NEC_tables['Ch 9 Table 8 Conductor Properties']);


    }

    user_input.array.num_strings = user_input.array.num_strings || 4;
    user_input.array.modules_per_string = user_input.array.modules_per_string || 6;
    user_input.DC.home_run_length = user_input.DC.home_run_length || 50;

    user_input.roof.width  = user_input.roof.width || 60;
    user_input.roof.length = user_input.roof.length || 25;
    user_input.roof.slope  = user_input.roof.slope || "6:12";
    user_input.roof.type   = user_input.roof.type || "Gable";

    user_input.inverter.location = user_input.inverter.location  || "Inside";

    user_input.module.orientation = user_input.module.orientation || "Portrait";

    user_input.location.address = user_input.location.address || '1679 Clearlake Road';
    user_input.location.city    = user_input.location.city || 'Cocoa';
    user_input.location.zip     = user_input.location.zip || '32922';
    user_input.location.county   = user_input.location.county || 'Brevard';


    if( state.database_loaded ){

        user_input.module.make = user_input.module.make ||
            g.f.obj_names( settings.components.modules )[0];
        user_input.module.model = user_input.module.model ||
            g.f.obj_names( settings.components.modules[user_input.module.make] )[0];

        user_input.inverter.make = user_input.inverter.make ||
            g.f.obj_names( settings.components.inverters )[0];
        user_input.inverter.model = user_input.inverter.model ||
            g.f.obj_names( settings.components.inverters[user_input.inverter.make] )[0];


        user_input.AC.loadcenter_types = user_input.AC.loadcenter_types ||
        //    g.f.obj_names(inputs.AC.loadcenter_types)[0];
            '480/277V';


        user_input.AC.type = user_input.AC.type || '480V Wye';
        //system.AC.type = user_input.AC.type ||
        //    user_input.AC.loadcenter_types[system.AC.loadcenter_types][0];

        user_input.AC.distance_to_loadcenter = user_input.AC.distance_to_loadcenter ||
            50;


        user_input.DC.wire_size = inputs.DC.wire_size.options[3];
        /*

        settings.config_options.inverterMakeArray = k.objIdArray(settings.config_options.inverters);
        user_input.inverter.make = user_input.inverter.make || Object.keys( settings.config_options.inverters )[0];
        settings.config_options.inverterModelArray = k.objIdArray(settings.config_options.inverters[system.inverter.make]);

        user_input.AC_loadcenter_type = user_input.AC_loadcenter_type || config_options.AC_loadcenter_type_options[0];
        //*/


        user_input.attachment_system.make = user_input.attachment_system.make ||
            inputs.attachment_system.make.options[0];
        user_input.attachment_system.model = user_input.attachment_system.model ||
            inputs.attachment_system.model.options[0];

    }





};



module.exports = settings_dev_defaults;

},{}],18:[function(require,module,exports){
"use strict";

function settings_drawing(settings){

    var system = settings.system;
    var status = settings.status;

    // Drawing specific
    //settings.drawing = settings.drawing || {};


    var size = settings.drawing_settings.size = {};
    var loc = settings.drawing_settings.loc = {};


    // sizes
    size.drawing = {
        w: 1000,
        h: 780,
        frame_padding: 5,
        titlebox: {
            side: {
                w: 80,
                h: 80*3,
            },
            bottom: {
                h: 40,
                w: 650
            }
        }

    };

    size.module = {};
    size.module.frame = {
        w: 10,
        h: 30,
    };
    size.module.lead = size.module.frame.w*2/3;
    size.module.h = size.module.frame.h + size.module.lead*2;
    size.module.w = size.module.frame.w;

    size.wire_offset = {
        base: 7,
        gap: size.module.w,
    };
    size.wire_offset.min = size.wire_offset.base * 1;

    size.string = {};
    size.string.gap = size.module.frame.w/42;
    size.string.gap_missing = size.module.h;
    size.string.w = size.module.frame.w * 2.5;

    size.terminal_diam = 5;
    size.fuse = {};
    size.fuse.w = 15;
    size.fuse.h = 4;


    // Inverter
    size.inverter = { w: 250, h: 150 };
    size.inverter.text_gap = 15;
    size.inverter.symbol_w = 50;
    size.inverter.symbol_h = 25;

    loc.inverter = {
        x: size.drawing.w/2,
        y: size.drawing.h/3,
    };
    loc.inverter.bottom = loc.inverter.y + size.inverter.h/2;
    loc.inverter.top = loc.inverter.y - size.inverter.h/2;
    loc.inverter.bottom_right = {
        x: loc.inverter.x + size.inverter.w/2,
        y: loc.inverter.y + size.inverter.h/2,
    };

    // array
    loc.array = {
        x: loc.inverter.x - 200,
        upper: loc.inverter.y - 20,
    };
    //loc.array.upper = loc.array.y - size.string.h/2;
    loc.array.right = loc.array.x - size.module.frame.h*3;




    loc.DC = loc.array;

    // DC jb
    size.jb_box = {
        h: 150,
        w: 80,
    };
    loc.jb_box = {
        x: 350,
        y: 550,
    };

    // DC diconect
    size.discbox = {
        w: 140,
        h: 50,
    };
    loc.discbox = {
        x: loc.inverter.x - size.inverter.w/2 + size.discbox.w/2,
        y: loc.inverter.y + size.inverter.h/2 + size.discbox.h/2 + 10,
    };

    // AC diconect
    size.AC_disc = { w: 80, h: 125 };

    loc.AC_disc = {
        x: loc.inverter.x+200,
        y: loc.inverter.y+250
    };
    loc.AC_disc.bottom = loc.AC_disc.y + size.AC_disc.h/2;
    loc.AC_disc.top = loc.AC_disc.y - size.AC_disc.h/2;
    loc.AC_disc.left = loc.AC_disc.x - size.AC_disc.w/2;
    loc.AC_disc.switch_top = loc.AC_disc.top + 15;
    loc.AC_disc.switch_bottom = loc.AC_disc.switch_top + 30;


    // AC panel

    loc.AC_loadcenter = {
        x: loc.inverter.x+350,
        y: loc.inverter.y+100
    };
    size.AC_loadcenter = { w: 125, h: 300 };
    loc.AC_loadcenter.left = loc.AC_loadcenter.x - size.AC_loadcenter.w/2;
    loc.AC_loadcenter.top = loc.AC_loadcenter.y - size.AC_loadcenter.h/2;


    size.AC_loadcenter.breaker = { w: 20, h: size.terminal_diam, };
    loc.AC_loadcenter.breakers = {
        left: loc.AC_loadcenter.x - ( size.AC_loadcenter.breaker.w * 1.1 ),
    };
    size.AC_loadcenter.breakers = {
        num: 20,
        spacing: size.AC_loadcenter.breaker.h + 1,
    };
    loc.AC_loadcenter.breakers.top = loc.AC_loadcenter.top + size.AC_loadcenter.h/5;
    loc.AC_loadcenter.breakers.bottom = loc.AC_loadcenter.breakers.top + size.AC_loadcenter.breakers.spacing*size.AC_loadcenter.breakers.num;


    size.AC_loadcenter.neutralbar = { w:5, h:40 };
    loc.AC_loadcenter.neutralbar = {
        x: loc.AC_loadcenter.left + 20,
        y: loc.AC_loadcenter.y + size.AC_loadcenter.h*0.3
    };

    size.AC_loadcenter.groundbar = { w:40, h:5 };
    loc.AC_loadcenter.groundbar = {
        x: loc.AC_loadcenter.x + 10,
        y: loc.AC_loadcenter.y + size.AC_loadcenter.h*0.45
    };

    loc.AC_conduit = {
        y: loc.AC_loadcenter.breakers.bottom - size.AC_loadcenter.breakers.spacing/2,
    };


    // wire table
    loc.wire_table = {
        x: size.drawing.w - size.drawing.frame_padding*3 - 325,
        y: size.drawing.frame_padding*3,
    };

    // voltage drop table
    size.volt_drop_table = {};
    size.volt_drop_table.w = 150;
    size.volt_drop_table.h = 100;
    loc.volt_drop_table = {};
    loc.volt_drop_table.x = size.drawing.w - size.volt_drop_table.w/2 - 30 - size.drawing.titlebox.side.w;
    loc.volt_drop_table.y = size.drawing.h - size.volt_drop_table.h/2 - 30 - size.drawing.titlebox.bottom.h;


    // voltage drop table
    size.general_notes = {};
    size.general_notes.w = 150;
    size.general_notes.h = 100;
    loc.general_notes = {};
    loc.general_notes.x = size.general_notes.w/2 + 30;
    loc.general_notes.y = size.general_notes.h/2 + 30;




    settings.pages = {};
    settings.pages.letter = {
        units: 'inches',
        w: 11.0,
        h: 8.5,
    };
    settings.page = settings.pages.letter;

    settings.pages.PDF = {
        w: settings.page.w * 72,
        h: settings.page.h * 72,
    };

    settings.pages.PDF.scale = {
        x: settings.pages.PDF.w / settings.drawing_settings.size.drawing.w,
        y: settings.pages.PDF.h / settings.drawing_settings.size.drawing.h,
    };

    if( settings.pages.PDF.scale.x < settings.pages.PDF.scale.y ) {
        settings.page.scale = settings.pages.PDF.scale.x;
    } else {
        settings.page.scale = settings.pages.PDF.scale.y;
    }


    loc.preview = loc.preview || {};
    loc.preview.array = loc.preview.array = {};
    loc.preview.array.top = 100;
    loc.preview.array.left = 50;

    loc.preview.DC = loc.preview.DC = {};
    loc.preview.inverter = loc.preview.inverter = {};
    loc.preview.AC = loc.preview.AC = {};

    size.preview = size.preview || {};
    size.preview.module = {
        w: 15,
        h: 25,
    };
    size.preview.DC = {
        w: 30,
        h: 50,
    };
    size.preview.inverter = {
        w: 150,
        h: 75,
    };
    size.preview.AC = {
        w: 30,
        h: 50,
    };
    size.preview.loadcenter = {
        w: 50,
        h: 100,
    };



  return settings;

}


module.exports = settings_drawing;

},{}],19:[function(require,module,exports){
///////////////
// fonts

var fonts = {};

fonts['base'] = {
    'font-family': 'monospace',
    'font-size':     10,
    'text-anchor':   'middle',
};

fonts['signs'] = {
    'font-family': 'monospace',
    'font-size':     5,
    'text-anchor':   'middle',
};
fonts['label'] = {
    'font-family': 'monospace',
    'font-size':     12,
    'text-anchor':   'middle',
};
fonts['title1'] = {
    'font-family': 'monospace',
    'font-size':     14,
    'text-anchor':   'left',
};
fonts['title2'] = {
    'font-family': 'monospace',
    'font-size':     12,
    'text-anchor':   'left',
};
fonts['title3'] = {
    'font-family': 'monospace',
    'font-size':     10,
    'text-anchor':   'left',
};
fonts['title_FSEC'] = {
    'font-family': 'monospace',
    'font-size':     8,
    'text-anchor':   'middle',
};




fonts['installer_info'] = {
    'font-family': 'monospace',
    'font-size':     6,
    'text-anchor':   'middle',
};
fonts['sheet_num'] = {
    'font-family': 'monospace',
    'font-size':     16,
    'text-anchor':   'middle',
};
fonts['border_info'] = {
    'font-family': 'monospace',
    'font-size':     6,
    'text-anchor':   'left',
};




fonts['table'] = {
    'font-family': 'serif',
    'font-size':     8,
    'text-anchor':   'middle',
};
fonts['table_left'] = {
    'font-family': 'serif',
    'font-size':     8,
    'text-anchor':   'left',
};
fonts['table_large_left'] = {
    'font-family': 'monospace',
    'font-size':     14,
    'text-anchor':   'left',
};
fonts['table_large'] = {
    'font-family': 'monospace',
    'font-size':     14,
    'text-anchor':   'middle',
};
fonts['project title'] = {
    'font-family': 'monospace',
    'font-size':     16,
    'text-anchor':   'middle',
};
fonts['preview text'] = {
    'font-family': 'monospace',
    'font-size'  : 20,
    'text-anchor': 'middle',
};
fonts['dimention'] = {
    'font-family': 'monospace',
    'font-size'  : 20,
    'text-anchor': 'middle',
};





module.exports = fonts;

},{}],20:[function(require,module,exports){
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
if (!Object.assign) {
  Object.defineProperty(Object, "assign", {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function(target, firstSource) {
      "use strict";
      if (target === undefined || target === null)
        throw new TypeError("Cannot convert first argument to object");
      var to = Object(target);
      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];
        if (nextSource === undefined || nextSource === null) continue;
        var keysArray = Object.keys(Object(nextSource));
        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
          if (desc !== undefined && desc.enumerable) to[nextKey] = nextSource[nextKey];
        }
      }
      return to;
    }
  });
}


var layer_attr = {};

layer_attr.image = {};

layer_attr.base = {
    'fill': 'none',
    'stroke':'#000000',
    'stroke-width':'1px',
    'stroke-linecap':'butt',
    'stroke-linejoin':'miter',
    'stroke-opacity':1,

};
layer_attr.block = Object.create(layer_attr.base);
layer_attr.frame = Object.create(layer_attr.base);
layer_attr.frame.stroke = '#000042';
layer_attr.table = Object.create(layer_attr.base);
layer_attr.table.stroke = '#000000';

layer_attr.DC_intermodule = Object.assign(Object.create(layer_attr.base),{
    stroke: '#bebebe',
    "stroke-dasharray": "1, 1",


});

layer_attr.DC_pos = Object.create(layer_attr.base);
layer_attr.DC_pos.stroke = '#ff0000';
layer_attr.DC_neg = Object.create(layer_attr.base);
layer_attr.DC_neg.stroke = '#000000';
layer_attr.DC_ground = Object.create(layer_attr.base);
layer_attr.DC_ground.stroke = '#006600';
layer_attr.module = Object.create(layer_attr.base);
layer_attr.box = Object.create(layer_attr.base);



layer_attr.text = Object.create(layer_attr.base);
layer_attr.text.stroke = '#0000ff';
layer_attr.terminal = Object.create(layer_attr.base);


layer_attr.AC_ground = Object.create(layer_attr.base);
layer_attr.AC_ground.stroke = '#009900';
layer_attr.AC_neutral = Object.create(layer_attr.base);
layer_attr.AC_neutral.stroke = '#999797';
layer_attr.AC_L1 = Object.create(layer_attr.base);
layer_attr.AC_L1.stroke = '#000000';
layer_attr.AC_L2 = Object.create(layer_attr.base);
layer_attr.AC_L2.stroke = '#FF0000';
layer_attr.AC_L3 = Object.create(layer_attr.base);
layer_attr.AC_L3.stroke = '#0000FF';


layer_attr.preview = Object.assign(Object.create(layer_attr.base),{
    'stroke-width': '2',
});

layer_attr.preview_module = Object.assign(Object.create(layer_attr.preview),{
    fill: '#ffb300',
    stroke: 'none',
});

layer_attr.preview_array = Object.assign(Object.create(layer_attr.preview),{
    stroke: '#ff5d00',
});

layer_attr.preview_DC = Object.assign(Object.create(layer_attr.preview),{
    stroke: '#b092c4',
});
layer_attr.preview_DC_box = Object.assign(Object.create(layer_attr.preview),{
    fill: '#b092c4',
    stroke: 'none',
});

layer_attr.preview_inverter = Object.assign(Object.create(layer_attr.preview),{
    stroke:'#86c974',
});
layer_attr.preview_inverter_box = Object.assign(Object.create(layer_attr.preview),{
    fill: '#86c974',
    stroke: 'none',
});

layer_attr.preview_AC = Object.assign(Object.create(layer_attr.preview),{
    stroke: '#8188a1',
});

layer_attr.preview_AC_box = Object.assign(Object.create(layer_attr.preview),{
    fill: '#8188a1',
    stroke: 'none',
});

layer_attr.preview_structural = Object.assign(Object.create(layer_attr.preview),{
    stroke: '#000000',
});
layer_attr.preview_structural_dot = Object.assign(Object.create(layer_attr.preview),{
    stroke: '#000000',
    "stroke-dasharray": "5, 5"
});
layer_attr.preview_structural_poly_unselected = Object.assign(Object.create(layer_attr.preview),{
    fill: '#e1e1e1',
    stroke: 'none'
});
layer_attr.preview_structural_poly_selected = Object.assign(Object.create(layer_attr.preview),{
    fill: '#ffe7cb',
    stroke: 'none'
});
layer_attr.preview_structural_poly_selected_framed = Object.assign(Object.create(layer_attr.preview),{
    fill: '#ffe7cb',
    stroke: '#000000'
});

layer_attr.preview_structural_module = Object.assign(Object.create(layer_attr.preview),{
    fill: '#ffffff',
    stroke: 'none'
});
layer_attr.preview_structural_module_selected = Object.assign(Object.create(layer_attr.preview),{
    fill: '#8397e8',
    stroke: '#dffaff'
});

layer_attr.north_arrow = Object.assign(Object.create(layer_attr.preview),{
    stroke: '#000000',
    'stroke-width': 1,
    'stroke-linecap': "round",
    'stroke-linejoin': "round",
});
layer_attr.north_letter = Object.assign(Object.create(layer_attr.preview),{
    stroke: '#949494',
    'stroke-width': 5,
    'stroke-linecap': "round",
    'stroke-linejoin': "round",
});

layer_attr.dimention = Object.assign(Object.create(layer_attr.text),{
    stroke: '#1433fe',
});

layer_attr.border = Object.create(layer_attr.base);

layer_attr['border_lines'] = Object.assign(Object.create(layer_attr.text),{
    stroke: '#8e8e8e',
});


module.exports = layer_attr;

},{}],21:[function(require,module,exports){



function setup_webpage(){
    var settings = g;
    var f = g.f;

    var system_frame_id = 'system_frame';
    var title = 'PV drawing test';

    g.f.setup_body(title);

    var page = $('<div>').attr('class', 'page').appendTo($(document.body));
    //page.style('width', (settings.drawing_settings.size.drawing.w+20).toString() + 'px' )

    var system_frame = $('<div>').attr('id', system_frame_id).appendTo(page);


    var header_container = $('<div>').appendTo(system_frame);
    $('<img>')
        .attr('src', 'data/PlansMachine.png')
        .attr('class', 'title_image')
        //.attr('width', '90%')
        .appendTo(header_container);
    $('<div>').attr('class', 'subtitle').appendTo(header_container).append(
        $('<span>').html('Please select your system spec below').attr('class', 'category_title').appendTo(header_container),
        $('<span>').html(' | ').appendTo(header_container),
        //$('<input>').attr('type', 'button').attr('value', 'clear selections').click(window.location.reload),
        $('<a>').attr('href', 'javascript:window.location.reload()').html('clear selections').appendTo(header_container)

    );


    // System setup
    var config_frame = $('<div>').attr('id', 'config_frame').appendTo(system_frame);

    g.f.add_drawers(settings, config_frame);

    //console.log(section_selector);



    //var location_drawer = $('#section_location').children('.drawer').children('.drawer_content');
    //console.log(location_drawer);


    var map_div = $('<div>');
    var map_drawer = f.mk_drawer('map',map_div)
                        //.appendTo(config_frame);
                        .insertAfter( $('#section_location') );
    map_drawer.children('.drawer').children('.drawer_content').slideUp('fast');



    var list_element = $('<ul>').appendTo(map_div);
    $('<li>').appendTo(list_element).append(
        $('<a>')
            .text('Wind Zone ')
            .attr('href', 'http://windspeed.atcouncil.org/')
            .attr('target', '_blank')
    );
    $('<li>').appendTo(list_element).append(
        $('<a>')
            .text('Climate Conditions')
            .attr('href', 'http://www.solarabcs.org/about/publications/reports/expedited-permit/map/index.html')
            .attr('target', '_blank')
    );

//*
    var geocode_div = $('<div>')
        .attr('class', 'geocode_line')
        .appendTo(map_div);
    $('<a>').appendTo(geocode_div)
        .attr('class', 'geocode_button')
        .text('Find location from address')
        .attr('href', '#')
        .click(f.request_geocode);
    $('<span>').appendTo(geocode_div)
        .attr('class', 'geocode_display')
        .attr('id','geocode_display')
        .text('');

    $('<div>')
        .attr('id', 'map_road')
        .attr('class', 'map_road')
        .attr('style', 'width:485px;height:380px')
        .appendTo(map_div);
    $('<div>')
        .attr('id', 'map_sat')
        .attr('class', 'map_sat')
        .attr('style', 'width:485px;height:380px')
        .appendTo(map_div);


    var lat_fl_center = 27.75;
    var lon_fl_center = -84.0;

    var lat = 28.387399;
    var lon = -80.757833;
    var coor = [-80.757833, 28.387399];

    L.AwesomeMarkers.Icon.prototype.options.prefix = 'fa';
    var sun_marker = L.AwesomeMarkers.icon({
        icon: 'sun-o',
        markerColor: 'blue  ',
        iconColor: 'yellow'
    });

    var map_road  = g.perm.maps.map_road = L.map( 'map_road', {
        center: [lat_fl_center, lon_fl_center],
        zoom: 6
    });

    L.tileLayer( 'http://{s}.mqcdn.com/tiles/1.0.0/map/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="http://osm.org/copyright" title="OpenStreetMap" target="_blank">OpenStreetMap</a> contributors | Tiles Courtesy of <a href="http://www.mapquest.com/" title="MapQuest" target="_blank">MapQuest</a> <img src="http://developer.mapquest.com/content/osm/mq_logo.png" width="16" height="16">',
        subdomains: ['otile1','otile2','otile3','otile4']
    }).addTo( map_road );

    g.perm.maps.marker_road = L.marker([lat,lon], {icon: sun_marker}).addTo(map_road);

    map_road.on('click', f.set_coordinates_from_map );




    var map_sat = g.perm.maps.map_sat = L.map( 'map_sat', {
        center: [lat, lon],
        zoom: 16
    });
    L.tileLayer( 'http://{s}.mqcdn.com/tiles/1.0.0/sat/{z}/{x}/{y}.png', {
        subdomains: ['otile1','otile2','otile3','otile4']
    }).addTo( map_sat );

    g.perm.maps.marker_sat = L.marker([lat,lon], {icon: sun_marker}).addTo(map_sat);

    map_sat.on('click', f.set_coordinates_from_map );
//*/







    var drawing_section = $('<div>').attr('id', 'drawing_frame').appendTo(page);
    //drawing.css('width', (settings.drawing_settings.size.drawing.w+20).toString() + 'px' );


    //$('<form method="get" action="data/sample.pdf"><button type="submit">Download</button></form>').appendTo(drawing_section);
    //$('<span>').attr('id', 'download').attr('class', 'float_right').appendTo(drawing_section);
    $('<a>')
        .text('Download Drawing (sample)')
        .attr('href', 'sample_pdf/sample.pdf')
        .attr('id', 'download')
        .attr('class', 'button_float_right')
        .attr('target', '_blank')
        .appendTo(drawing_section);
    $('<a>')
        .text('Download Drawing (network test, once)')
        //.attr('href', '#')
        .attr('id', 'download')
        .attr('class', 'button_float_right')
        //.attr('target', '_blank')
        .appendTo(drawing_section)
        .click(f.request_SVG);
    $('<a>')
        .text('Download Drawing (network test, repeats)')
        //.attr('href', '#')
        .attr('id', 'download')
        .attr('class', 'button_float_right')
        //.attr('target', '_blank')
        .appendTo(drawing_section)
        .click(function(){
            setInterval(g.f.request_SVG, 1000);
        });

    var svg_container_object = $('<div>').attr('id', 'drawing').attr('class', 'drawing').css('clear', 'both').appendTo(drawing_section);
    //svg_container_object.style('width', settings.drawing_settings.size.drawing.w+'px' )
    //var svg_container = svg_container_object.elem;
    $('<br>').appendTo(drawing_section);

    ///////////////////
    $('<div>').html(' ').attr('class', 'section_title').appendTo(drawing_section);

}



module.exports = setup_webpage;

},{}],22:[function(require,module,exports){


var update_webpage = function(){
    var settings = g;
    var f = g.f;

    // Make preview


    // create previews
    settings.drawing.preview_parts = {};
    settings.drawing.preview_svgs = {};
    for( var name in f.mk_preview ){  // f.mk_sheet_num is a array of page making functions, so this will loop through the number of pages
        settings.drawing.preview_parts[name] = f.mk_preview[name](settings);
        settings.drawing.preview_svgs[name] = f.mk_svg(settings.drawing.preview_parts[name], settings.drawing_settings);
    }

    var preview_table = {
        'section_location': [],
        'section_map': [],
        'section_roof': [ settings.drawing.preview_svgs['roof'] ],
        'section_module': [ settings.drawing.preview_svgs['elec'], settings.drawing.preview_svgs['roof'] ],
        'section_array': [ settings.drawing.preview_svgs['elec'] ],
        'section_DC': [ settings.drawing.preview_svgs['elec'] ],
        'section_inverter': [ settings.drawing.preview_svgs['elec'] ],
        'section_AC': [ settings.drawing.preview_svgs['elec'] ],
        'section_attachment_system': [ settings.drawing.preview_svgs['roof'] ],
    };
    //console.log( $('#config_frame').children().map(function(){return this.id;}).get() );
    //$('#section_location')
    //    .append(settings.drawing.preview_svgs['elec']);
    //$('#section_map')
    //    .append(settings.drawing.preview_svgs['elec']);




// update web page
    // set maps markers
    if( g.perm.location.lat && g.perm.location.lon) {
        f.set_sat_map_marker();
    }

    // change user inputs to defaults if needed.
    // This also updates the drop list elements that are dependent on other inputs ( model list is based on selected make).
    settings.select_registry.forEach(function(selector){
        if( selector.type === 'select' ){
            f.selector_add_options(selector);
        } else if( selector.type === 'number_input' || selector.type === 'text_input' ) {
            selector.elem.value = selector.system_ref.get();
        }
    });

    // Determine active section based on section inputs entered by user
    var sections = g.webpage.sections;
    var active_section;
    sections.every(function(section_name,id){ //TODO: find pre IE9 way to do this?
        if( ! g.f.section_defined(g, section_name) ){
            active_section = section_name;
            console.log('active section:', section_name);
            return false;
        } else {
            if( id === sections.length-1 ){ //If last section is defined, there is no active section
                active_section = false;
            }
            return true;
        }
    });

    // Close section if they are not active sections, unless they have been opened by the user, open the active section
    sections.forEach(function(section_name,id){ //TODO: find pre IE9 way to do this?
        var svg_drawing_container = $('#section_'+section_name).children('.drawer').children('.drawer_content').children('.svg_drawing_container');
        svg_drawing_container.empty();
        console.log(section_name);
        preview_table['section_'+section_name].forEach(function(preview_svg){
            svg_drawing_container.append(
                $(preview_svg).clone()
                    .attr('class', 'svg_drawing_preview')
            );
        });

        if( section_name === active_section ){
            $('#section_'+section_name).children('.drawer').children('.drawer_content').slideDown('fast');

        } else if( ! g.webpage.selections_manual_toggled[section_name] ){
            $('#section_'+section_name).children('.drawer').children('.drawer_content').slideUp('fast');
        }
    });
    //If the location is defined, open the map.
    /*
    if( (! g.webpage.selections_manual_toggled.location) &&  g.f.section_defined(g, 'location') ){
            $('#section_map').children('.drawer').children('.drawer_content').slideDown('fast');
    }
    //*/





    var p;
    /*
    $('#drawing_preview').empty();
    for( p in f.mk_preview ){  // f.mk_sheet_num is a array of page making functions, so this will loop through the number of pages
        //settings.drawing.preview_svgs[p] = f.mk_svg(settings.drawing.preview_parts[p], settings.drawing_settings);
        var section = ['','Electrical','Structural'][p];
        $('#drawing_preview')
            //.append($('<p>Page '+p+'</p>'))
            .append($('<p>'+section+'</p>'))
            .append($(settings.drawing.preview_svgs[p]))
            .append($('</br>'))
            .append($('</br>'));

    }
    //*/

    // Add drawing to page
    $('#drawing').empty();
    for( p in settings.drawing.parts ){  // f.mk_sheet_num is a array of page making functions, so this will loop through the number of pages
        settings.drawing.svgs[p] = f.mk_svg(settings.drawing.parts[p], settings.drawing_settings);
        $('#drawing')
            //.append($('<p>Page '+p+'</p>'))
            .append($(settings.drawing.svgs[p]))
            .append($('</br>'))
            .append($('</br>'));

    }


};


module.exports = update_webpage;

},{}],23:[function(require,module,exports){
//     Underscore.js 1.8.2
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.2';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var isArrayLike = function(collection) {
    var length = collection && collection.length;
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, target, fromIndex) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    return _.indexOf(obj, target, typeof fromIndex == 'number' && fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = input && input.length; i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, 'length').length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = list && list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    var i = 0, length = array && array.length;
    if (typeof isSorted == 'number') {
      i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
    } else if (isSorted && length) {
      i = _.sortedIndex(array, item);
      return array[i] === item ? i : -1;
    }
    if (item !== item) {
      return _.findIndex(slice.call(array, i), _.isNaN);
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    var idx = array ? array.length : 0;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    if (item !== item) {
      return _.findLastIndex(slice.call(array, 0, idx), _.isNaN);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = array != null && array.length;
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createIndexFinder(1);

  _.findLastIndex = createIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    
    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of 
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
  
  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],24:[function(require,module,exports){
'use strict';


// Setup
    // Load and create main settings, and save them to the root global object.
    var mk_settings = require('./modules/mk_settings');
    window.g = mk_settings();

    console.log('settings', g);


    //var version_string = 'Dev';
    //var version_string = 'Alpha201401--';
    var version_string = 'Preview'+moment().format('YYYYMMDD');
    g.state.version_string = version_string;
    // Load and URL query variables
    var query = g.f.query_string();
    //console.log(query);

    var update_webpage = require('./modules/update_webpage');

    g.f.update = function(){
        var settings = g;
        var f = g.f;

        console.log('/--- begin update');
        g.f.clear_drawing();

        settings.select_registry.forEach(function(selector){
            if(selector.value()) selector.input_ref.set(selector.value());
        });

        // recalculate system settings
        g.f.process(settings);

        update_webpage();

        console.log('\\--- end update');
    };


// request external data

    var newtwork_test = false;

    g.f.request_SVG = function(){
    //*
        console.log('sending data to server');
        var url = 'http://localhost:4233/plans_machine';
        var user_input_json = JSON.stringify(g.user_input);
        var data = { user_input_json: user_input_json};
        //var data = {
        //    test:42,
        //    test2:23,
        //};
        $.ajax({
                type: 'POST',
                url: url,
                data: data,
            })
            .done(function(res){
                console.log('server responce?', res);

            })
            .fail(function() {
                console.log( 'error' );
            })
            .always(function() {
                console.log( 'complete' );
            });

    };

    //var database_json_URL = 'http://10.173.64.204:8000/temporary/';
    var database_json_URL = 'data/fsec_copy.json';
    $.getJSON( database_json_URL)
        .done(function(data){
            g.FSEC_database = data;
            //console.log('database loaded', settings.database);
            g.components = g.f.load_database(data);
            g.state.database_loaded = true;
            if( g.state.mode === 'dev'){
                g.f.settings_dev_defaults(g);
            }
            g.f.update();

            ////////
            // TEMP
            //g.f.request_SVG();
            ////////
        });


// Build webpage

    // Set dev mode if requested
    if( query['mode'] === 'dev' ) {
        g.state.mode = 'dev';
    } else {
        g.state.mode = 'release';
    }

    if( query['password'] === 'sd723sfkbgr8yr' ) {
        g.state.password = true;
    } else {
        g.state.password = false;
    }


    if( g.state.mode === 'dev' ){
        g.f.settings_dev_defaults(g);
    }

    if( g.state.password || query['mode'] === 'dev' ){
        g.f.setup_webpage();

        // Add status bar
        var boot_time = moment();
        var status_id = 'status';
        setInterval(function(){ g.f.update_status_bar(status_id, boot_time, version_string);},1000);

        g.f.update();

    } else {
        console.log('no password');
        $('<img>')
            .attr('src', 'data/PlansMachine.png')
            //.attr('class', 'title_image')
            .css('width', '300px')
            .css('padding', '30px')
            .css('display', 'block')
            .css('margin-left', 'auto')
            .css('margin-right', 'auto')
            .appendTo(document.body);
        $('<div>')
            .attr('style', 'text-align: center')
            .html('Password required for demo')
            .appendTo(document.body);
    }

},{"./modules/mk_settings":7,"./modules/update_webpage":22}]},{},[24])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiZGF0YS90YWJsZXMuanNvbiIsImxpYi9rb250YWluZXIuanMiLCJtb2R1bGVzL2Z1bmN0aW9ucy5qcyIsIm1vZHVsZXMvbWtfYmxvY2tzLmpzIiwibW9kdWxlcy9ta19ib3JkZXIuanMiLCJtb2R1bGVzL21rX2RyYXdpbmcuanMiLCJtb2R1bGVzL21rX3NldHRpbmdzLmpzIiwibW9kdWxlcy9ta19zaGVldC5qcyIsIm1vZHVsZXMvbWtfc3ZnLmpzIiwibW9kdWxlcy9wYWdlL0ctMDAxLmpzIiwibW9kdWxlcy9wYWdlL1MtMDAxLmpzIiwibW9kdWxlcy9wYWdlL1ctMDAxLmpzIiwibW9kdWxlcy9wYWdlL1ctMDAyLmpzIiwibW9kdWxlcy9wcmV2aWV3L21rX3ByZXZpZXdfZWxlYy5qcyIsIm1vZHVsZXMvcHJldmlldy9ta19wcmV2aWV3X3Jvb2YuanMiLCJtb2R1bGVzL3Byb2Nlc3MuanMiLCJtb2R1bGVzL3NldHRpbmdzX2Rldl9kZWZhdWx0cy5qcyIsIm1vZHVsZXMvc2V0dGluZ3NfZHJhd2luZy5qcyIsIm1vZHVsZXMvc2V0dGluZ3NfZm9udHMuanMiLCJtb2R1bGVzL3NldHRpbmdzX2xheWVycy5qcyIsIm1vZHVsZXMvc2V0dXBfd2VicGFnZS5qcyIsIm1vZHVsZXMvdXBkYXRlX3dlYnBhZ2UuanMiLCJub2RlX21vZHVsZXMvdW5kZXJzY29yZS91bmRlcnNjb3JlLmpzIiwid2VicGFnZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4eUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hnREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJtb2R1bGUuZXhwb3J0cz17XG5cbiAgICBcIk5FQyAyNTAuMTIyX2hlYWRlclwiOiBbXCJBbXBcIixcIkFXR1wiXSxcbiAgICBcIk5FQyAyNTAuMTIyXCI6IHtcbiAgICAgICAgXCIxNVwiOlwiMTRcIixcbiAgICAgICAgXCIyMFwiOlwiMTJcIixcbiAgICAgICAgXCIzMFwiOlwiMTBcIixcbiAgICAgICAgXCI0MFwiOlwiMTBcIixcbiAgICAgICAgXCI2MFwiOlwiMTBcIixcbiAgICAgICAgXCIxMDBcIjpcIjhcIixcbiAgICAgICAgXCIyMDBcIjpcIjZcIixcbiAgICAgICAgXCIzMDBcIjpcIjRcIixcbiAgICAgICAgXCI0MDBcIjpcIjNcIixcbiAgICAgICAgXCI1MDBcIjpcIjJcIixcbiAgICAgICAgXCI2MDBcIjpcIjFcIixcbiAgICAgICAgXCI4MDBcIjpcIjEvMFwiLFxuICAgICAgICBcIjEwMDBcIjpcIjIvMFwiLFxuICAgICAgICBcIjEyMDBcIjpcIjMvMFwiLFxuICAgICAgICBcIjE2MDBcIjpcIjQvMFwiLFxuICAgICAgICBcIjIwMDBcIjpcIjI1MFwiLFxuICAgICAgICBcIjI1MDBcIjpcIjM1MFwiLFxuICAgICAgICBcIjMwMDBcIjpcIjQwMFwiLFxuICAgICAgICBcIjQwMDBcIjpcIjUwMFwiLFxuICAgICAgICBcIjUwMDBcIjpcIjcwMFwiLFxuICAgICAgICBcIjYwMDBcIjpcIjgwMFwiXG4gICAgfSxcblxuICAgIFwiTkVDIFQ2OTAuN19oZWFkZXJcIjogW1wiQW1iaWVudCBUZW1wZXJhdHVyZSAoQylcIiwgXCJDb3JyZWN0aW9uIEZhY3RvclwiXSxcbiAgICBcIk5FQyBUNjkwLjdcIjoge1xuICAgICAgICBcIjI1IHRvIDIwXCI6XCIxLjAyXCIsXG4gICAgICAgIFwiMTkgdG8gMTVcIjpcIjEuMDRcIixcbiAgICAgICAgXCIxNSB0byAxMFwiOlwiMS4wNlwiLFxuICAgICAgICBcIjkgdG8gNVwiOlwiMS4wOFwiLFxuICAgICAgICBcIjQgdG8gMFwiOlwiMS4xMFwiLFxuICAgICAgICBcIi0xIHRvIC01XCI6XCIxLjEyXCIsXG4gICAgICAgIFwiLTYgdG8gLTEwXCI6XCIxLjE0XCIsXG4gICAgICAgIFwiLTExIHRvIC0xNVwiOlwiMS4xNlwiLFxuICAgICAgICBcIi0xNiB0byAtMjBcIjpcIjEuMThcIixcbiAgICAgICAgXCItMjEgdG8gLTI1XCI6XCIxLjIwXCIsXG4gICAgICAgIFwiLTI2IHRvIC0zMFwiOlwiMS4yMVwiLFxuICAgICAgICBcIi0zMSB0byAtMzVcIjpcIjEuMjNcIixcbiAgICAgICAgXCItMzYgdG8gLTQwXCI6XCIxLjI1XCJcbiAgICB9LFxuXG4gICAgXCJDaCA5IFRhYmxlIDggQ29uZHVjdG9yIFByb3BlcnRpZXNfaGVhZGVyXCI6IFtcIlNpemVcIixcIm9obS9rZnRcIl0sXG4gICAgXCJDaCA5IFRhYmxlIDggQ29uZHVjdG9yIFByb3BlcnRpZXNcIjoge1xuICAgICAgICBcIiMwMVwiOlwiIDAuMTU0XCIsXG4gICAgICAgIFwiIzAxLzBcIjpcIjAuMTIyXCIsXG4gICAgICAgIFwiIzAyXCI6XCIwLjE5NFwiLFxuICAgICAgICBcIiMwMi8wXCI6XCIwLjA5NjdcIixcbiAgICAgICAgXCIjMDNcIjpcIjAuMjQ1XCIsXG4gICAgICAgIFwiIzAzLzBcIjpcIjAuMDc2NlwiLFxuICAgICAgICBcIiMwNFwiOlwiMC4zMDhcIixcbiAgICAgICAgXCIjMDQvMFwiOlwiMC4wNjA4XCIsXG4gICAgICAgIFwiIzA2XCI6XCIwLjQ5MVwiLFxuICAgICAgICBcIiMwOFwiOlwiMC43NzhcIixcbiAgICAgICAgXCIjMTBcIjpcIjEuMjRcIixcbiAgICAgICAgXCIjMTJcIjpcIjEuOThcIixcbiAgICAgICAgXCIjMTRcIjpcIjMuMTRcIlxuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtvbnRhaW5lciA9IHtcbiAgICByZWY6IGZ1bmN0aW9uKHJlZlN0cmluZyl7XG4gICAgICAgIGlmKCB0eXBlb2YgcmVmU3RyaW5nID09PSAndW5kZWZpbmVkJyApe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmU3RyaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWZTdHJpbmcgPSByZWZTdHJpbmc7XG4gICAgICAgICAgICB0aGlzLnJlZkFycmF5ID0gcmVmU3RyaW5nLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBpZiggdHlwZW9mIHRoaXMub2JqZWN0ICE9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG9iajogZnVuY3Rpb24ob2JqKXtcbiAgICAgICAgaWYoIHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnICl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vYmplY3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9iamVjdCA9IG9iajtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgdGhpcy5yZWZTdHJpbmcgIT09ICd1bmRlZmluZWQnKXtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihpbnB1dCl7XG4gICAgICAgIGlmKCB0eXBlb2YgdGhpcy5vYmplY3QgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB0aGlzLnJlZlN0cmluZyA9PT0gJ3VuZGVmaW5lZCcgKXtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5vYmplY3Q7XG4gICAgICAgIHZhciBsYXN0X2xldmVsID0gdGhpcy5yZWZBcnJheVt0aGlzLnJlZkFycmF5Lmxlbmd0aC0xXTtcblxuICAgICAgICB0aGlzLnJlZkFycmF5LmZvckVhY2goZnVuY3Rpb24obGV2ZWxfbmFtZSxpKXtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgcGFyZW50W2xldmVsX25hbWVdID09PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRbbGV2ZWxfbmFtZV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCBsZXZlbF9uYW1lICE9PSBsYXN0X2xldmVsICl7XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50W2xldmVsX25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50W2xhc3RfbGV2ZWxdID0gaW5wdXQ7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ3NldHRpbmc6JywgaW5wdXQsIHRoaXMuZ2V0KCksIHRoaXMucmVmU3RyaW5nICk7XG4gICAgICAgIHJldHVybiBwYXJlbnRbbGFzdF9sZXZlbF07XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBsZXZlbCA9IHRoaXMub2JqZWN0O1xuICAgICAgICB0aGlzLnJlZkFycmF5LmZvckVhY2goZnVuY3Rpb24obGV2ZWxfbmFtZSxpKXtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgbGV2ZWxbbGV2ZWxfbmFtZV0gPT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsID0gbGV2ZWxbbGV2ZWxfbmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgfSxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga29udGFpbmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGtvbnRhaW5lciA9IHJlcXVpcmUoJy4uL2xpYi9rb250YWluZXInKTtcblxudmFyIGYgPSB7fTtcblxuXG5mLnNldHVwX2JvZHkgPSBmdW5jdGlvbih0aXRsZSwgc2VjdGlvbnMpe1xuICAgIGRvY3VtZW50LnRpdGxlID0gdGl0bGU7XG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBzdGF0dXNfYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc3RhdHVzX2Jhci5pZCA9ICdzdGF0dXMnO1xuICAgIHN0YXR1c19iYXIuaW5uZXJIVE1MID0gJ2xvYWRpbmcgc3RhdHVzLi4uJztcbiAgICBib2R5Lmluc2VydEJlZm9yZShzdGF0dXNfYmFyLCBib2R5LmZpcnN0Q2hpbGQpO1xufTtcblxuZi5wYWRfemVybyA9IGZ1bmN0aW9uKG51bSwgc2l6ZSl7XG4gICAgdmFyIHMgPSAnMDAwMDAwMDAwJyArIG51bTtcbiAgICByZXR1cm4gcy5zdWJzdHIocy5sZW5ndGgtc2l6ZSk7XG59O1xuXG5mLnVwdGltZSA9IGZ1bmN0aW9uKGJvb3RfdGltZSl7XG4gICAgdmFyIHVwdGltZV9zZWNvbmRzX3RvdGFsID0gbW9tZW50KCkuZGlmZihib290X3RpbWUsICdzZWNvbmRzJyk7XG4gICAgdmFyIHVwdGltZV9ob3VycyA9IE1hdGguZmxvb3IoICB1cHRpbWVfc2Vjb25kc190b3RhbCAvKDYwKjYwKSApO1xuICAgIHZhciBtaW51dGVzX2xlZnQgPSB1cHRpbWVfc2Vjb25kc190b3RhbCAlKDYwKjYwKTtcbiAgICB2YXIgdXB0aW1lX21pbnV0ZXMgPSBmLnBhZF96ZXJvKCBNYXRoLmZsb29yKCAgbWludXRlc19sZWZ0IC82MCApLCAyICk7XG4gICAgdmFyIHVwdGltZV9zZWNvbmRzID0gZi5wYWRfemVybyggKG1pbnV0ZXNfbGVmdCAlIDYwKSwgMiApO1xuICAgIHJldHVybiB1cHRpbWVfaG91cnMgK1wiOlwiKyB1cHRpbWVfbWludXRlcyArXCI6XCIrIHVwdGltZV9zZWNvbmRzO1xufTtcblxuZi51cGRhdGVfc3RhdHVzX2JhciA9IGZ1bmN0aW9uKHN0YXR1c19pZCwgYm9vdF90aW1lLCBzdHJpbmcpIHtcbiAgICB2YXIgc3RhdHVzX2RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0YXR1c19pZCk7XG4gICAgc3RhdHVzX2Rpdi5pbm5lckhUTUwgPSBzdHJpbmc7XG4gICAgc3RhdHVzX2Rpdi5pbm5lckhUTUwgKz0gJyB8ICc7XG5cbiAgICB2YXIgY2xvY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgY2xvY2suaW5uZXJIVE1MID0gbW9tZW50KCkuZm9ybWF0KCdZWVlZLU1NLUREIEhIOm1tOnNzJyk7XG5cbiAgICB2YXIgdXB0aW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHVwdGltZS5pbm5lckhUTUwgPSAnVXB0aW1lOiAnICsgZi51cHRpbWUoYm9vdF90aW1lKTtcblxuICAgIHN0YXR1c19kaXYuYXBwZW5kQ2hpbGQoY2xvY2spO1xuICAgIHN0YXR1c19kaXYuaW5uZXJIVE1MICs9ICcgfCAnO1xuICAgIHN0YXR1c19kaXYuYXBwZW5kQ2hpbGQodXB0aW1lKTtcbiAgICBzdGF0dXNfZGl2LmlubmVySFRNTCArPSAnIHwgJztcbn07XG5cblxuZi5vYmpfbmFtZXMgPSBmdW5jdGlvbiggb2JqZWN0ICkge1xuICAgIGlmKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgdmFyIGEgPSBbXTtcbiAgICAgICAgZm9yKCB2YXIgaWQgaW4gb2JqZWN0ICkge1xuICAgICAgICAgICAgaWYoIG9iamVjdC5oYXNPd25Qcm9wZXJ0eShpZCkgKSAge1xuICAgICAgICAgICAgICAgIGEucHVzaChpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxufTtcblxuZi5vYmplY3RfZGVmaW5lZCA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gICAgLy9jb25zb2xlLmxvZyhvYmplY3QpO1xuICAgIGZvciggdmFyIGtleSBpbiBvYmplY3QgKXtcbiAgICAgICAgaWYoIG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpICl7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGtleSk7XG4gICAgICAgICAgICBpZiggb2JqZWN0W2tleV0gPT09IG51bGwgfHwgb2JqZWN0W2tleV0gPT09IHVuZGVmaW5lZCApIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmYuc2VjdGlvbl9kZWZpbmVkID0gZnVuY3Rpb24oc2V0dGluZ3MsIHNlY3Rpb25fbmFtZSl7XG4gICAgLy9jb25zb2xlLmxvZyhcIi1cIitzZWN0aW9uX25hbWUpO1xuICAgIC8vdmFyIGlucHV0X3NlY3Rpb24gPSBnLmlucHV0c1tzZWN0aW9uX25hbWVdO1xuICAgIC8vdmFyIG91dHB1dF9zZWN0aW9uID0gZy5zeXN0ZW1bc2VjdGlvbl9uYW1lXTtcbiAgICB2YXIgb3V0cHV0X3NlY3Rpb24gPSBzZXR0aW5ncy51c2VyX2lucHV0W3NlY3Rpb25fbmFtZV07XG4gICAgZm9yKCB2YXIga2V5IGluIG91dHB1dF9zZWN0aW9uICl7XG4gICAgICAgIGlmKCBvdXRwdXRfc2VjdGlvbi5oYXNPd25Qcm9wZXJ0eShrZXkpICl7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGtleSk7XG5cbiAgICAgICAgICAgIGlmKCBvdXRwdXRfc2VjdGlvbltrZXldID09PSB1bmRlZmluZWQgfHwgb3V0cHV0X3NlY3Rpb25ba2V5XSA9PT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5mLm51bGxUb09iamVjdCA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gICAgZm9yKCB2YXIga2V5IGluIG9iamVjdCApe1xuICAgICAgICBpZiggb2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkgKXtcbiAgICAgICAgICAgIGlmKCBvYmplY3Rba2V5XSA9PT0gbnVsbCApe1xuICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0ge307XG4gICAgICAgICAgICB9IGVsc2UgaWYoIHR5cGVvZiBvYmplY3Rba2V5XSA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSBmLm51bGxUb09iamVjdChvYmplY3Rba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmYuYmxhbmtfY29weSA9IGZ1bmN0aW9uKG9iamVjdCl7XG4gICAgdmFyIG5ld09iamVjdCA9IHt9O1xuICAgIGZvciggdmFyIGtleSBpbiBvYmplY3QgKXtcbiAgICAgICAgaWYoIG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpICl7XG4gICAgICAgICAgICBpZiggb2JqZWN0W2tleV0uY29uc3RydWN0b3IgPT09IE9iamVjdCApIHtcbiAgICAgICAgICAgICAgICBuZXdPYmplY3Rba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciggdmFyIGtleTIgaW4gb2JqZWN0W2tleV0gKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoIG9iamVjdFtrZXldLmhhc093blByb3BlcnR5KGtleTIpICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdPYmplY3Rba2V5XVtrZXkyXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld09iamVjdFtrZXldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3T2JqZWN0O1xufTtcblxuZi5hZGRfc2VjdGlvbnMgPSBmdW5jdGlvbihpbnB1dHMpe1xuICAgIHZhciBibGFua191c2VyX2lucHV0ID0ge307XG4gICAgZm9yKCB2YXIgc2VjdGlvbl9uYW1lIGluIGlucHV0cyApe1xuICAgICAgICBpZiggaW5wdXRzLmhhc093blByb3BlcnR5KHNlY3Rpb25fbmFtZSkgKXtcbiAgICAgICAgICAgIGlmKCBpbnB1dHNbc2VjdGlvbl9uYW1lXS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICkge1xuICAgICAgICAgICAgICAgIGJsYW5rX3VzZXJfaW5wdXRbc2VjdGlvbl9uYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciggdmFyIG5hbWUgaW4gaW5wdXRzW3NlY3Rpb25fbmFtZV0gKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoIGlucHV0c1tzZWN0aW9uX25hbWVdLmhhc093blByb3BlcnR5KG5hbWUpICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBibGFua191c2VyX2lucHV0W3NlY3Rpb25fbmFtZV1bbmFtZV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZXJyb3I6IHNlY3Rpb24gbm90IG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBibGFua191c2VyX2lucHV0O1xuXG59O1xuXG5mLmJsYW5rX2NsZWFuX2NvcHkgPSBmdW5jdGlvbihvYmplY3Qpe1xuICAgIHZhciBuZXdPYmplY3QgPSB7fTtcbiAgICBmb3IoIHZhciBrZXkgaW4gb2JqZWN0ICl7XG4gICAgICAgIGlmKCBvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSApe1xuICAgICAgICAgICAgaWYoIG9iamVjdFtrZXldLmNvbnN0cnVjdG9yID09PSBPYmplY3QgKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqZWN0W2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IoIHZhciBrZXkyIGluIG9iamVjdFtrZXldICl7XG4gICAgICAgICAgICAgICAgICAgIGlmKCBvYmplY3Rba2V5XS5oYXNPd25Qcm9wZXJ0eShrZXkyKSApe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsZWFuX2tleSA9IGYuY2xlYW5fbmFtZShrZXkyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld09iamVjdFtrZXldW2NsZWFuX2tleV0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdPYmplY3Rba2V5XSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld09iamVjdDtcbn07XG5cbi8vZi5tZXJnZV9vYmplY3RzID0gZnVuY3Rpb24gbWVyZ2Vfb2JqZWN0cyhvYmplY3QxLCBvYmplY3QyKXtcbi8vICAgIGZvciggdmFyIGtleSBpbiBvYmplY3QxICl7XG4vLyAgICAgICAgaWYoIG9iamVjdDEuaGFzT3duUHJvcGVydHkoa2V5KSApe1xuLy8gICAgICAgICAgICAvL2lmKCBrZXkgPT09ICdtYWtlJyApIGNvbnNvbGUubG9nKGtleSwgb2JqZWN0MSwgdHlwZW9mIG9iamVjdDFba2V5XSwgdHlwZW9mIG9iamVjdDJba2V5XSk7XG4vLyAgICAgICAgICAgIC8vY29uc29sZS5sb2coa2V5LCBvYmplY3QxLCB0eXBlb2Ygb2JqZWN0MVtrZXldLCB0eXBlb2Ygb2JqZWN0MltrZXldKTtcbi8vICAgICAgICAgICAgaWYoIG9iamVjdDFba2V5XSAmJiBvYmplY3QxW2tleV0uY29uc3RydWN0b3IgPT09IE9iamVjdCApIHtcbi8vICAgICAgICAgICAgICAgIGlmKCBvYmplY3QyW2tleV0gPT09IHVuZGVmaW5lZCApIG9iamVjdDJba2V5XSA9IHt9O1xuLy8gICAgICAgICAgICAgICAgbWVyZ2Vfb2JqZWN0cyggb2JqZWN0MVtrZXldLCBvYmplY3QyW2tleV0gKTtcbi8vICAgICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgICAgIGlmKCBvYmplY3QyW2tleV0gPT09IHVuZGVmaW5lZCApIG9iamVjdDJba2V5XSA9IG51bGw7XG4vLyAgICAgICAgICAgIH1cbi8vICAgICAgICB9XG4vLyAgICB9XG4vL307XG5cbmYubWVyZ2Vfb2JqZWN0cyA9IGZ1bmN0aW9uIG1lcmdlX29iamVjdHMob2JqZWN0MSwgb2JqZWN0Mil7XG4gICAgZm9yKCB2YXIga2V5IGluIG9iamVjdDEgKXtcbiAgICAgICAgaWYoIG9iamVjdDEuaGFzT3duUHJvcGVydHkoa2V5KSApe1xuICAgICAgICAgICAgLy9pZigga2V5ID09PSAnbWFrZScgKSBjb25zb2xlLmxvZyhrZXksIG9iamVjdDEsIHR5cGVvZiBvYmplY3QxW2tleV0sIHR5cGVvZiBvYmplY3QyW2tleV0pO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhrZXksIG9iamVjdDEsIHR5cGVvZiBvYmplY3QxW2tleV0sIHR5cGVvZiBvYmplY3QyW2tleV0pO1xuICAgICAgICAgICAgaWYoIG9iamVjdDFba2V5XSAmJiBvYmplY3QxW2tleV0uY29uc3RydWN0b3IgPT09IE9iamVjdCApIHtcbiAgICAgICAgICAgICAgICBpZiggb2JqZWN0MltrZXldID09PSB1bmRlZmluZWQgKSBvYmplY3QyW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICBtZXJnZV9vYmplY3RzKCBvYmplY3QxW2tleV0sIG9iamVjdDJba2V5XSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvYmplY3QyW2tleV0gPSBvYmplY3QxW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5mLmFycmF5X3RvX29iamVjdCA9IGZ1bmN0aW9uKGFycikge1xuICAgIHZhciByID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpXG4gICAgICAgIHJbaV0gPSBhcnJbaV07XG4gICAgcmV0dXJuIHI7XG59O1xuXG5mLm5hbl9jaGVjayA9IGZ1bmN0aW9uIG5hbl9jaGVjayhvYmplY3QsIHBhdGgpe1xuICAgIGlmKCBwYXRoID09PSB1bmRlZmluZWQgKSBwYXRoID0gXCJcIjtcbiAgICBwYXRoID0gcGF0aCtcIi5cIjtcbiAgICBmb3IoIHZhciBrZXkgaW4gb2JqZWN0ICl7XG4gICAgICAgIC8vY29uc29sZS5sb2coIFwiTmFOY2hlY2s6IFwiK3BhdGgra2V5ICk7XG5cbiAgICAgICAgaWYoIG9iamVjdFtrZXldICYmIG9iamVjdFtrZXldLmNvbnN0cnVjdG9yID09PSBBcnJheSApIG9iamVjdFtrZXldID0gZi5hcnJheV90b19vYmplY3Qob2JqZWN0W2tleV0pO1xuXG5cbiAgICAgICAgaWYoICBvYmplY3Rba2V5XSAmJiAoIG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpIHx8IG9iamVjdFtrZXldICE9PSBudWxsICkpe1xuICAgICAgICAgICAgaWYoIG9iamVjdFtrZXldLmNvbnN0cnVjdG9yID09PSBPYmplY3QgKXtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCBcIiAgT2JqZWN0OiBcIitwYXRoK2tleSApO1xuICAgICAgICAgICAgICAgIG5hbl9jaGVjayggb2JqZWN0W2tleV0sIHBhdGgra2V5ICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYoIG9iamVjdFtrZXldID09PSBOYU4gfHwgb2JqZWN0W2tleV0gPT09IG51bGwgKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggXCJOYU46IFwiK3BhdGgra2V5ICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coIFwiRGVmaW5lZDogXCIrcGF0aCtrZXksIG9iamVjdFtrZXldKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG59O1xuXG5mLnN0cl90b19udW0gPSBmdW5jdGlvbiBzdHJfdG9fbnVtKGlucHV0KXtcbiAgICB2YXIgb3V0cHV0O1xuICAgIGlmKCFpc05hTihpbnB1dCkpIG91dHB1dCA9IE51bWJlcihpbnB1dCk7XG4gICAgZWxzZSBvdXRwdXQgPSBpbnB1dDtcbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuXG5mLnByZXR0eV93b3JkID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xufTtcblxuZi5wcmV0dHlfbmFtZSA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHZhciBsID0gbmFtZS5zcGxpdCgnXycpO1xuICAgIGwuZm9yRWFjaChmdW5jdGlvbihuYW1lX3NlcW1lbnQsaSl7XG4gICAgICAgIGxbaV0gPSBmLnByZXR0eV93b3JkKG5hbWVfc2VxbWVudCk7XG4gICAgfSk7XG4gICAgdmFyIHByZXR0eSA9IGwuam9pbignICcpO1xuXG4gICAgcmV0dXJuIHByZXR0eTtcbn07XG5cbmYucHJldHR5X25hbWVzID0gZnVuY3Rpb24ob2JqZWN0KXtcbiAgICB2YXIgbmV3X29iamVjdCA9IHt9O1xuICAgIGZvciggdmFyIGtleSBpbiBvYmplY3QgKXtcbiAgICAgICAgaWYoIG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpICl7XG4gICAgICAgICAgICB2YXIgbmV3X2tleSA9IGYucHJldHR5X25hbWUoa2V5KTtcbiAgICAgICAgICAgIG5ld19vYmplY3RbbmV3X2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3X29iamVjdDtcbn07XG5cbmYuY2xlYW5fbmFtZSA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiBuYW1lLnNwbGl0KCcgJylbMF07XG59O1xuXG5cbmYubWtfZHJhd2VyID0gZnVuY3Rpb24odGl0bGUsIGNvbnRlbnQpe1xuICAgIHZhciBkcmF3ZXJfY29udGFpbmVyID0gJCgnPGRpdj4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdkcmF3ZXJfY29udGFpbmVyJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignaWQnLCAnc2VjdGlvbl8nK3RpdGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy5hdHRyKCdpZCcsIHRpdGxlICk7XG4gICAgLy9kcmF3ZXJfY29udGFpbmVyLmdldCgwKS5zdHlsZS5kaXNwbGF5ID0gZGlzcGxheV90eXBlO1xuICAgIHZhciBzeXN0ZW1fZGl2ID0gJCgnPGRpdj4nKS5hdHRyKCdjbGFzcycsICd0aXRsZV9iYXInKVxuICAgICAgICAuYXR0cignc2VjdGlvbl9ub20nLCB0aXRsZSlcbiAgICAgICAgLmFwcGVuZFRvKGRyYXdlcl9jb250YWluZXIpXG4gICAgICAgIC8qIGpzaGludCAtVzA4MyAqL1xuICAgICAgICAuY2xpY2soZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBuYW1lID0gJCh0aGlzKS5hdHRyKCdzZWN0aW9uX25vbScpO1xuICAgICAgICAgICAgZy53ZWJwYWdlLnNlbGVjdGlvbnNfbWFudWFsX3RvZ2dsZWRbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgJCh0aGlzKS5wYXJlbnQoKS5jaGlsZHJlbignLmRyYXdlcicpLmNoaWxkcmVuKCcuZHJhd2VyX2NvbnRlbnQnKS5zbGlkZVRvZ2dsZSgnZmFzdCcpO1xuICAgICAgICB9KTtcbiAgICB2YXIgc3lzdGVtX3RpdGxlID0gJCgnPGE+JylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3RpdGxlX2Jhcl90ZXh0JylcbiAgICAgICAgLmF0dHIoJ2hyZWYnLCAnIycpXG4gICAgICAgIC50ZXh0KGYucHJldHR5X25hbWUodGl0bGUpKVxuICAgICAgICAuYXBwZW5kVG8oc3lzdGVtX2Rpdik7XG5cbiAgICB2YXIgZHJhd2VyID0gJCgnPGRpdj4nKS5hdHRyKCdjbGFzcycsICdkcmF3ZXInKS5hcHBlbmRUbyhkcmF3ZXJfY29udGFpbmVyKTtcbiAgICBjb250ZW50LmF0dHIoJ2NsYXNzJywgJ2RyYXdlcl9jb250ZW50JykuYXBwZW5kVG8oZHJhd2VyKTtcblxuXG4gICAgcmV0dXJuIGRyYXdlcl9jb250YWluZXI7XG5cblxufTtcblxuXG5mLmFkZF9kcmF3ZXJzID0gZnVuY3Rpb24oc2V0dGluZ3MsIHBhcmVudF9jb250YWluZXIpe1xuICAgIGZvciggdmFyIHNlY3Rpb25fbmFtZSBpbiBzZXR0aW5ncy5pbnB1dHMgKXtcblxuICAgICAgICAvLyQodGhpcykudHJpZ2dlcignY2xpY2snKTtcbiAgICAgICAgdmFyIGRyYXdlcl9jb250ZW50ID0gJCgnPGRpdj4nKTtcbiAgICAgICAgdmFyIHVzZXJfaW5wdXRfY29udGFpbmVyID0gJCgnPGRpdj4nKS5hdHRyKCdjbGFzcycsICd1c2VyX2lucHV0X2NvbnRhaW5lcicpLmFwcGVuZFRvKGRyYXdlcl9jb250ZW50KTtcbiAgICAgICAgZHJhd2VyX2NvbnRlbnQuYXBwZW5kKFxuICAgICAgICAgICAgJCgnPGRpdj4nKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdzdmdfZHJhd2luZ19jb250YWluZXInKVxuICAgICAgICApO1xuXG5cblxuICAgICAgICBmb3IoIHZhciBpbnB1dF9uYW1lIGluIHNldHRpbmdzLmlucHV0c1tzZWN0aW9uX25hbWVdICl7XG4gICAgICAgICAgICB2YXIgdW5pdHM7XG4gICAgICAgICAgICBpZiggKHNldHRpbmdzLmlucHV0c1tzZWN0aW9uX25hbWVdW2lucHV0X25hbWVdICE9PSB1bmRlZmluZWQpICYmIChzZXR0aW5ncy5pbnB1dHNbc2VjdGlvbl9uYW1lXVtpbnB1dF9uYW1lXS51bml0cyAhPT0gdW5kZWZpbmVkKSApIHtcbiAgICAgICAgICAgICAgICB1bml0cyA9IFwiKFwiICsgc2V0dGluZ3MuaW5wdXRzW3NlY3Rpb25fbmFtZV1baW5wdXRfbmFtZV0udW5pdHMgKyBcIilcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdW5pdHMgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vdGU7XG4gICAgICAgICAgICBpZiggKHNldHRpbmdzLmlucHV0c1tzZWN0aW9uX25hbWVdW2lucHV0X25hbWVdICE9PSB1bmRlZmluZWQpICYmIChzZXR0aW5ncy5pbnB1dHNbc2VjdGlvbl9uYW1lXVtpbnB1dF9uYW1lXS5ub3RlICE9PSB1bmRlZmluZWQpICkge1xuICAgICAgICAgICAgICAgIG5vdGUgPSBzZXR0aW5ncy5pbnB1dHNbc2VjdGlvbl9uYW1lXVtpbnB1dF9uYW1lXS5ub3RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3RlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1c2VyX2lucHV0ID0gJCgnPHNwYW4+JykuYXR0cignY2xhc3MnLCAndXNlcl9pbnB1dCcpLmFwcGVuZFRvKHVzZXJfaW5wdXRfY29udGFpbmVyKTtcbiAgICAgICAgICAgIHZhciBpbnB1dF90ZXh0ID0gJCgnPHNwYW4+JykuaHRtbChmLnByZXR0eV9uYW1lKGlucHV0X25hbWUpICsgJzogJyArIHVuaXRzICkuYXBwZW5kVG8odXNlcl9pbnB1dCk7XG4gICAgICAgICAgICBpZiggbm90ZSApIGlucHV0X3RleHQuYXR0cigndGl0bGUnLCBub3RlKTtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBrJCgnc2VsZWN0b3InKVxuICAgICAgICAgICAgICAgIC5zZXRPcHRpb25zUmVmKCAnaW5wdXRzLicgKyBzZWN0aW9uX25hbWUgKyAnLicgKyBpbnB1dF9uYW1lIClcbiAgICAgICAgICAgICAgICAuc2V0UmVmKCAnc3lzdGVtLicgKyBzZWN0aW9uX25hbWUgKyAnLicgKyBpbnB1dF9uYW1lIClcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8odXNlcl9pbnB1dCk7XG4gICAgICAgICAgICBmLmtlbGVtX3NldHVwKHNlbGVjdG9yLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAvLyovXG4gICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSB7XG4gICAgICAgICAgICAgICAgc3lzdGVtX3JlZjogT2JqZWN0LmNyZWF0ZShrb250YWluZXIpLm9iaihnKS5yZWYoJ3N5c3RlbS4nICsgc2VjdGlvbl9uYW1lICsgJy4nICsgaW5wdXRfbmFtZSksXG4gICAgICAgICAgICAgICAgaW5wdXRfcmVmOiBPYmplY3QuY3JlYXRlKGtvbnRhaW5lcikub2JqKGcpLnJlZigndXNlcl9pbnB1dC4nICsgc2VjdGlvbl9uYW1lICsgJy4nICsgaW5wdXRfbmFtZSksXG4gICAgICAgICAgICAgICAgbGlzdF9yZWY6IE9iamVjdC5jcmVhdGUoa29udGFpbmVyKS5vYmooZykucmVmKCdpbnB1dHMuJyArIHNlY3Rpb25fbmFtZSArICcuJyArIGlucHV0X25hbWUgKyAnLm9wdGlvbnMnKSxcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiggKHNldHRpbmdzLmlucHV0c1tzZWN0aW9uX25hbWVdW2lucHV0X25hbWVdICE9PSB1bmRlZmluZWQpICYmIChzZXR0aW5ncy5pbnB1dHNbc2VjdGlvbl9uYW1lXVtpbnB1dF9uYW1lXS50eXBlICE9PSB1bmRlZmluZWQpICkge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yLnR5cGUgPSBzZXR0aW5ncy5pbnB1dHNbc2VjdGlvbl9uYW1lXVtpbnB1dF9uYW1lXS50eXBlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rvci50eXBlID0gJ3NlbGVjdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiggc2VsZWN0b3IudHlwZSA9PT0gJ3NlbGVjdCcgKXtcbiAgICAgICAgICAgICAgICBzZWxlY3Rvci5lbGVtID0gJCgnPHNlbGVjdD4nKVxuICAgICAgICAgICAgICAgICAgICAvLy5hdHRyKCdjbGFzcycsICdzZWxlY3RvcicpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh1c2VyX2lucHV0KVxuICAgICAgICAgICAgICAgICAgICAuZ2V0KClbMF07XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IudmFsdWUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCB0aGlzLnNldF9yZWYucmVmU3RyaW5nLCB0aGlzLmVsZW0uc2VsZWN0ZWRJbmRleCApO1xuICAgICAgICAgICAgICAgICAgICAvL2lmKCB0aGlzLmludGVyYWN0ZWQgKVxuICAgICAgICAgICAgICAgICAgICBpZiggdGhpcy5lbGVtLnNlbGVjdGVkSW5kZXggPj0gMCkgcmV0dXJuIHRoaXMuZWxlbS5vcHRpb25zW3RoaXMuZWxlbS5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmLnNlbGVjdG9yX2FkZF9vcHRpb25zKHNlbGVjdG9yKTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmKCBzZWxlY3Rvci50eXBlID09PSAnbnVtYmVyX2lucHV0JyB8fCBzZWxlY3Rvci50eXBlID09PSAndGV4dF9pbnB1dCcpe1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yLmVsZW0gPSAkKCc8aW5wdXQ+JylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgc2VsZWN0b3IudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3R5cGUnLCAndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh1c2VyX2lucHV0KVxuICAgICAgICAgICAgICAgICAgICAuZ2V0KClbMF07XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IudmFsdWUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCB0aGlzLnNldF9yZWYucmVmU3RyaW5nLCB0aGlzLmVsZW0uc2VsZWN0ZWRJbmRleCApO1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCB0aGlzLmVsZW0sIHRoaXMuZWxlbS52YWx1ZSApO1xuICAgICAgICAgICAgICAgICAgICAvL2lmKCB0aGlzLmludGVyYWN0ZWQgKVxuICAgICAgICAgICAgICAgICAgICAvL2lmKCB0aGlzLmVsZW0uc2VsZWN0ZWRJbmRleCA+PSAwKSByZXR1cm4gdGhpcy5lbGVtLm9wdGlvbnNbdGhpcy5lbGVtLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAvL2Vsc2UgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtLnZhbHVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2VsZWN0b3IuZWxlbS52YWx1ZSA9IHNlbGVjdG9yLmlucHV0X3JlZi5nZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQoc2VsZWN0b3IuZWxlbSkuY2hhbmdlKGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5mLnVwZGF0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXR0aW5ncy5zZWxlY3RfcmVnaXN0cnkucHVzaChzZWxlY3Rvcik7XG4gICAgICAgICAgICAvLyQoJzwvYnI+JykuYXBwZW5kVG8oZHJhd2VyX2NvbnRlbnQpO1xuXG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgdmFyIHNlbGVjdGlvbl9jb250YWluZXIgPSBmLm1rX2RyYXdlcihzZWN0aW9uX25hbWUsIGRyYXdlcl9jb250ZW50KTtcblxuICAgICAgICBzZWxlY3Rpb25fY29udGFpbmVyLmFwcGVuZFRvKHBhcmVudF9jb250YWluZXIpO1xuXG4gICAgICAgICQoc2VsZWN0aW9uX2NvbnRhaW5lcikuY2hpbGRyZW4oJy5kcmF3ZXInKS5jaGlsZHJlbignLmRyYXdlcl9jb250ZW50Jykuc2xpZGVVcCgnZmFzdCcpO1xuICAgIH1cbn07XG5cbmYuc2VsZWN0b3JfYWRkX29wdGlvbnMgPSBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgdmFyIGxpc3QgPSBzZWxlY3Rvci5saXN0X3JlZi5nZXQoKTtcbiAgICBpZiggbGlzdCAmJiBsaXN0LmNvbnN0cnVjdG9yID09PSBPYmplY3QgKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ1wibGlzdFwiJywgbGlzdCk7XG4gICAgICAgIGxpc3QgPSBmLm9ial9uYW1lcyhsaXN0KTtcbiAgICB9XG4gICAgc2VsZWN0b3IuZWxlbS5pbm5lckhUTUwgPSBcIlwiO1xuICAgIGlmKCBsaXN0IGluc3RhbmNlb2YgQXJyYXkgKXtcbiAgICAgICAgdmFyIGN1cnJlbnRfdmFsdWUgPSBzZWxlY3Rvci5pbnB1dF9yZWYuZ2V0KCk7XG4gICAgICAgICQoJzxvcHRpb24+JykuYXR0cignc2VsZWN0ZWQnLHRydWUpLmF0dHIoJ2Rpc2FibGVkJyx0cnVlKS5hdHRyKCdoaWRkZW4nLHRydWUpLmFwcGVuZFRvKHNlbGVjdG9yLmVsZW0pO1xuXG4gICAgICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbihvcHRfbmFtZSl7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKG9wdF9uYW1lKTtcbiAgICAgICAgICAgIHZhciBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICAgICAgICBvLnZhbHVlID0gb3B0X25hbWU7XG4gICAgICAgICAgICBpZiggY3VycmVudF92YWx1ZSApe1xuICAgICAgICAgICAgICAgIGlmKCBvcHRfbmFtZS50b1N0cmluZygpID09PSBjdXJyZW50X3ZhbHVlLnRvU3RyaW5nKCkgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2ZvdW5kIGl0OicsIG9wdF9uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgby5zZWxlY3RlZCA9IFwic2VsZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkb2VzIG5vdCBtYXRjaDogJywgb3B0X25hbWUsIFwiLFwiLCAgY3VycmVudF92YWx1ZSwgXCIuXCIgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9vLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc2VsZWN0b3Jfb3B0aW9uJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ25vIGN1cnJlbnQgdmFsdWUnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgby5pbm5lckhUTUwgPSBvcHRfbmFtZTtcbiAgICAgICAgICAgIHNlbGVjdG9yLmVsZW0uYXBwZW5kQ2hpbGQobyk7XG4gICAgICAgIH0pO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnbGlzdCBub3QgYSBsaXN0JywgbGlzdCwgc2VsZWN0KTtcbiAgICB9XG59O1xuXG5mLmFkZF9vcHRpb25zID0gZnVuY3Rpb24oc2VsZWN0LCBhcnJheSl7XG4gICAgYXJyYXkuZm9yRWFjaCggZnVuY3Rpb24ob3B0aW9uKXtcbiAgICAgICAgJCgnPG9wdGlvbj4nKS5hdHRyKCAndmFsdWUnLCBvcHRpb24gKS50ZXh0KG9wdGlvbikuYXBwZW5kVG8oc2VsZWN0KTtcbiAgICB9KTtcbn07XG5cblxuLy9mLmFkZF9wYXJhbXMgPSBmdW5jdGlvbihzZXR0aW5ncywgcGFyZW50X2NvbnRhaW5lcil7XG4vLyAgICBmb3IoIHZhciBzZWN0aW9uX25hbWUgaW4gc2V0dGluZ3Muc3lzdGVtICl7XG4vLyAgICAgICAgaWYoIHRydWUgfHwgZi5vYmplY3RfZGVmaW5lZChzZXR0aW5ncy5zeXN0ZW1bc2VjdGlvbl9uYW1lXSkgKXtcbi8vICAgICAgICAgICAgdmFyIHNlbGVjdGlvbl9jb250YWluZXIgPSAkKCc8ZGl2PicpLmF0dHIoJ2NsYXNzJywgJ3BhcmFtX3NlY3Rpb24nKS5hdHRyKCdpZCcsIHNlY3Rpb25fbmFtZSApLmFwcGVuZFRvKHBhcmVudF9jb250YWluZXIpO1xuLy8gICAgICAgICAgICAvL3NlbGVjdGlvbl9jb250YWluZXIuZ2V0KDApLnN0eWxlLmRpc3BsYXkgPSBkaXNwbGF5X3R5cGU7XG4vLyAgICAgICAgICAgIHZhciBzeXN0ZW1fZGl2ID0gJCgnPGRpdj4nKVxuLy8gICAgICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ3RpdGxlX2xpbmUnKVxuLy8gICAgICAgICAgICAgICAgLmFwcGVuZFRvKHNlbGVjdGlvbl9jb250YWluZXIpXG4vLyAgICAgICAgICAgICAgICAvKiBqc2hpbnQgLVcwODMgKi9cbi8vICAgICAgICAgICAgICAgIC5jbGljayhmdW5jdGlvbigpe1xuLy8gICAgICAgICAgICAgICAgICAgICQodGhpcykucGFyZW50KCkuY2hpbGRyZW4oJy5kcmF3ZXInKS5jaGlsZHJlbignLmRyYXdlcl9jb250ZW50Jykuc2xpZGVUb2dnbGUoJ2Zhc3QnKTtcbi8vICAgICAgICAgICAgICAgIH0pO1xuLy8gICAgICAgICAgICB2YXIgc3lzdGVtX3RpdGxlID0gJCgnPGE+Jylcbi8vICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd0aXRsZV9saW5lX3RleHQnKVxuLy8gICAgICAgICAgICAgICAgLmF0dHIoJ2hyZWYnLCAnIycpXG4vLyAgICAgICAgICAgICAgICAudGV4dChmLnByZXR0eV9uYW1lKHNlY3Rpb25fbmFtZSkpXG4vLyAgICAgICAgICAgICAgICAuYXBwZW5kVG8oc3lzdGVtX2Rpdik7XG4vLyAgICAgICAgICAgICQodGhpcykudHJpZ2dlcignY2xpY2snKTtcbi8vICAgICAgICAgICAgdmFyIGRyYXdlciA9ICQoJzxkaXY+JykuYXR0cignY2xhc3MnLCAnJykuYXBwZW5kVG8oc2VsZWN0aW9uX2NvbnRhaW5lcik7XG4vLyAgICAgICAgICAgIHZhciBkcmF3ZXJfY29udGVudCA9ICQoJzxkaXY+JykuYXR0cignY2xhc3MnLCAncGFyYW1fc2VjdGlvbl9jb250ZW50JykuYXBwZW5kVG8oZHJhd2VyKTtcbi8vICAgICAgICAgICAgZm9yKCB2YXIgaW5wdXRfbmFtZSBpbiBzZXR0aW5ncy5zeXN0ZW1bc2VjdGlvbl9uYW1lXSApe1xuLy8gICAgICAgICAgICAgICAgJCgnPHNwYW4+JykuaHRtbChmLnByZXR0eV9uYW1lKGlucHV0X25hbWUpICsgJzogJykuYXBwZW5kVG8oZHJhd2VyX2NvbnRlbnQpO1xuLy8gICAgICAgICAgICAgICAgLypcbi8vICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IGskKCd2YWx1ZScpXG4vLyAgICAgICAgICAgICAgICAgICAgLy8uc2V0T3B0aW9uc1JlZiggJ2lucHV0cy4nICsgc2VjdGlvbl9uYW1lICsgJy4nICsgaW5wdXRfbmFtZSApXG4vLyAgICAgICAgICAgICAgICAgICAgLnNldFJlZiggJ3N5c3RlbS4nICsgc2VjdGlvbl9uYW1lICsgJy4nICsgaW5wdXRfbmFtZSApXG4vLyAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKGRyYXdlcl9jb250ZW50KTtcbi8vICAgICAgICAgICAgICAgIGYua2VsZW1fc2V0dXAoc2VsZWN0b3IsIHNldHRpbmdzKTtcbi8vICAgICAgICAgICAgICAgIC8vKi9cbi8vICAgICAgICAgICAgICAgIHZhciB2YWx1ZV9rb250YWluZXIgPSBPYmplY3QuY3JlYXRlKGtvbnRhaW5lcilcbi8vICAgICAgICAgICAgICAgICAgICAub2JqKHNldHRpbmdzKVxuLy8gICAgICAgICAgICAgICAgICAgIC5yZWYoJ3N5c3RlbS4nICsgc2VjdGlvbl9uYW1lICsgJy4nICsgaW5wdXRfbmFtZSk7XG4vLyAgICAgICAgICAgICAgICB2YXIgJGVsZW0gPSAkKCc8c3Bhbj4nKVxuLy8gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICcnKVxuLy8gICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhkcmF3ZXJfY29udGVudClcbi8vICAgICAgICAgICAgICAgICAgICAudGV4dCh2YWx1ZV9rb250YWluZXIuZ2V0KCkpO1xuLy8gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0ge1xuLy8gICAgICAgICAgICAgICAgICAgIGVsZW06ICRlbGVtLmdldCgpWzBdLFxuLy8gICAgICAgICAgICAgICAgICAgIHZhbHVlX3JlZjogdmFsdWVfa29udGFpbmVyXG4vLyAgICAgICAgICAgICAgICB9O1xuLy8gICAgICAgICAgICAgICAgc2V0dGluZ3MudmFsdWVfcmVnaXN0cnkucHVzaCh2YWx1ZSk7XG4vLyAgICAgICAgICAgICAgICAkKCc8L2JyPicpLmFwcGVuZFRvKGRyYXdlcl9jb250ZW50KTtcbi8vICAgICAgICAgICAgfVxuLy8gICAgICAgIH1cbi8vICAgIH1cbi8vfTtcbi8vXG4vL2YudXBkYXRlX3ZhbHVlcyA9IGZ1bmN0aW9uKHNldHRpbmdzKXtcbi8vICAgIHNldHRpbmdzLnZhbHVlX3JlZ2lzdHJ5LmZvckVhY2goZnVuY3Rpb24odmFsdWVfaXRlbSl7XG4vLyAgICAgICAgLy9jb25zb2xlLmxvZyggdmFsdWVfaXRlbSApO1xuLy8gICAgICAgIC8vY29uc29sZS5sb2coIHZhbHVlX2l0ZW0uZWxlbS5vcHRpb25zICk7XG4vLyAgICAgICAgLy9jb25zb2xlLmxvZyggdmFsdWVfaXRlbS5lbGVtLnNlbGVjdGVkSW5kZXggKTtcbi8vICAgICAgICBpZih2YWx1ZV9pdGVtLmVsZW0uc2VsZWN0ZWRJbmRleCl7XG4vLyAgICAgICAgICAgIHZhbHVlX2l0ZW0udmFsdWUgPSB2YWx1ZV9pdGVtLmVsZW0ub3B0aW9uc1t2YWx1ZV9pdGVtLmVsZW0uc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4vLyAgICAgICAgICAgIHZhbHVlX2l0ZW0ua29udGFpbmVyLnNldCh2YWx1ZV9pdGVtLnZhbHVlKTtcbi8vXG4vLyAgICAgICAgfVxuLy8gICAgfSk7XG4vL307XG4vL1xuLy9mLnNob3dfaGlkZV9wYXJhbXMgPSBmdW5jdGlvbihwYWdlX3NlY3Rpb25zLCBzZXR0aW5ncyl7XG4vLyAgICBmb3IoIHZhciBsaXN0X25hbWUgaW4gcGFnZV9zZWN0aW9ucyApe1xuLy8gICAgICAgIHZhciBpZCA9ICcjJytsaXN0X25hbWU7XG4vLyAgICAgICAgdmFyIHNlY3Rpb25fbmFtZSA9IGxpc3RfbmFtZS5zcGxpdCgnXycpWzBdO1xuLy8gICAgICAgIHZhciBzZWN0aW9uID0gayQoaWQpO1xuLy8gICAgICAgIGlmKCBzZXR0aW5ncy5zdGF0dXMuc2VjdGlvbnNbc2VjdGlvbl9uYW1lXS5zZXQgKSBzZWN0aW9uLnNob3coKTtcbi8vICAgICAgICBlbHNlIHNlY3Rpb24uaGlkZSgpO1xuLy8gICAgfVxuLy99O1xuXG4vL2Yuc2hvd19oaWRlX3NlbGVjdGlvbnMgPSBmdW5jdGlvbihzZXR0aW5ncywgYWN0aXZlX3NlY3Rpb25fbmFtZSl7XG4vLyAgICAkKCcjc2VjdGlvblNlbGVjdG9yJykudmFsKGFjdGl2ZV9zZWN0aW9uX25hbWUpO1xuLy8gICAgZm9yKCB2YXIgbGlzdF9uYW1lIGluIHNldHRpbmdzLmlucHV0ICl7XG4vLyAgICAgICAgdmFyIGlkID0gJyMnK2xpc3RfbmFtZTtcbi8vICAgICAgICB2YXIgc2VjdGlvbl9uYW1lID0gbGlzdF9uYW1lLnNwbGl0KCdfJylbMF07XG4vLyAgICAgICAgdmFyIHNlY3Rpb24gPSBrJChpZCk7XG4vLyAgICAgICAgaWYoIHNlY3Rpb25fbmFtZSA9PT0gYWN0aXZlX3NlY3Rpb25fbmFtZSApIHNlY3Rpb24uc2hvdygpO1xuLy8gICAgICAgIGVsc2Ugc2VjdGlvbi5oaWRlKCk7XG4vLyAgICB9XG4vL307XG5cbi8vZi5zZXREb3dubG9hZExpbmsoc2V0dGluZ3Mpe1xuLy9cbi8vICAgIGlmKCBzZXR0aW5ncy5QREYgJiYgc2V0dGluZ3MuUERGLnVybCApe1xuLy8gICAgICAgIHZhciBsaW5rID0gJCgnYScpLmF0dHIoJ2hyZWYnLCBzZXR0aW5ncy5QREYudXJsICkuYXR0cignZG93bmxvYWQnLCAnUFZfZHJhd2luZy5wZGYnKS5odG1sKCdEb3dubG9hZCBEcmF3aW5nJyk7XG4vLyAgICAgICAgJCgnI2Rvd25sb2FkJykuaHRtbCgnJykuYXBwZW5kKGxpbmspO1xuLy8gICAgfVxuLy99XG5cbi8vZi5sb2FkVGFibGVzID0gZnVuY3Rpb24oc3RyaW5nKXtcbi8vICAgIHZhciB0YWJsZXMgPSB7fTtcbi8vICAgIHZhciBsID0gc3RyaW5nLnNwbGl0KCdcXG4nKTtcbi8vICAgIHZhciB0aXRsZTtcbi8vICAgIHZhciBmaWVsZHM7XG4vLyAgICB2YXIgbmVlZF90aXRsZSA9IHRydWU7XG4vLyAgICB2YXIgbmVlZF9maWVsZHMgPSB0cnVlO1xuLy8gICAgbC5mb3JFYWNoKCBmdW5jdGlvbihzdHJpbmcsIGkpe1xuLy8gICAgICAgIHZhciBsaW5lID0gc3RyaW5nLnRyaW0oKTtcbi8vICAgICAgICBpZiggbGluZS5sZW5ndGggPT09IDAgKXtcbi8vICAgICAgICAgICAgbmVlZF90aXRsZSA9IHRydWU7XG4vLyAgICAgICAgICAgIG5lZWRfZmllbGRzID0gdHJ1ZTtcbi8vICAgICAgICB9IGVsc2UgaWYoIG5lZWRfdGl0bGUgKSB7XG4vLyAgICAgICAgICAgIHRpdGxlID0gbGluZTtcbi8vICAgICAgICAgICAgdGFibGVzW3RpdGxlXSA9IFtdO1xuLy8gICAgICAgICAgICBuZWVkX3RpdGxlID0gZmFsc2U7XG4vLyAgICAgICAgfSBlbHNlIGlmKCBuZWVkX2ZpZWxkcyApIHtcbi8vICAgICAgICAgICAgZmllbGRzID0gbGluZS5zcGxpdCgnLCcpO1xuLy8gICAgICAgICAgICB0YWJsZXNbdGl0bGUrXCJfZmllbGRzXCJdID0gZmllbGRzO1xuLy8gICAgICAgICAgICBuZWVkX2ZpZWxkcyA9IGZhbHNlO1xuLy8gICAgICAgIC8vfSBlbHNlIHtcbi8vICAgICAgICAvLyAgICB2YXIgZW50cnkgPSB7fTtcbi8vICAgICAgICAvLyAgICB2YXIgbGluZV9hcnJheSA9IGxpbmUuc3BsaXQoJywnKTtcbi8vICAgICAgICAvLyAgICBmaWVsZHMuZm9yRWFjaCggZnVuY3Rpb24oZmllbGQsIGlkKXtcbi8vICAgICAgICAvLyAgICAgICAgZW50cnlbZmllbGQudHJpbSgpXSA9IGxpbmVfYXJyYXlbaWRdLnRyaW0oKTtcbi8vICAgICAgICAvLyAgICB9KTtcbi8vICAgICAgICAvLyAgICB0YWJsZXNbdGl0bGVdLnB1c2goIGVudHJ5ICk7XG4vLyAgICAgICAgLy99XG4vLyAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICAgdmFyIGxpbmVfYXJyYXkgPSBsaW5lLnNwbGl0KCcsJyk7XG4vLyAgICAgICAgICAgIHRhYmxlc1t0aXRsZV1bbGluZV9hcnJheVswXS50cmltKCldID0gbGluZV9hcnJheVsxXS50cmltKCk7XG4vLyAgICAgICAgfVxuLy8gICAgfSk7XG4vL1xuLy8gICAgcmV0dXJuIHRhYmxlcztcbi8vfTtcbi8vXG4vL2YubG9hZENvbXBvbmVudHMgPSBmdW5jdGlvbihzdHJpbmcpe1xuLy8gICAgdmFyIGRiID0gay5wYXJzZUNTVihzdHJpbmcpO1xuLy8gICAgdmFyIG9iamVjdCA9IHt9O1xuLy8gICAgZm9yKCB2YXIgaSBpbiBkYiApe1xuLy8gICAgICAgIHZhciBjb21wb25lbnQgPSBkYltpXTtcbi8vICAgICAgICBpZiggb2JqZWN0W2NvbXBvbmVudC5NYWtlXSA9PT0gdW5kZWZpbmVkICl7XG4vLyAgICAgICAgICAgIG9iamVjdFtjb21wb25lbnQuTWFrZV0gPSB7fTtcbi8vICAgICAgICB9XG4vLyAgICAgICAgaWYoIG9iamVjdFtjb21wb25lbnQuTWFrZV1bY29tcG9uZW50Lk1vZGVsXSA9PT0gdW5kZWZpbmVkICl7XG4vLyAgICAgICAgICAgIG9iamVjdFtjb21wb25lbnQuTWFrZV1bY29tcG9uZW50Lk1vZGVsXSA9IHt9O1xuLy8gICAgICAgIH1cbi8vXG4vLyAgICAgICAgdmFyIGZpZWxkcyA9IGsub2JqSWRBcnJheShjb21wb25lbnQpO1xuLy8gICAgICAgIGZpZWxkcy5mb3JFYWNoKCBmdW5jdGlvbiggZmllbGQgKXtcbi8vICAgICAgICAgICAgdmFyIHBhcmFtID0gY29tcG9uZW50W2ZpZWxkXTtcbi8vICAgICAgICAgICAgaWYoICEoIGZpZWxkIGluIFsnTWFrZScsICdNb2RlbCddICkgJiYgISggaXNOYU4ocGFyc2VGbG9hdChwYXJhbSkpICkgKXtcbi8vICAgICAgICAgICAgICAgIGNvbXBvbmVudFtmaWVsZF0gPSBwYXJzZUZsb2F0KHBhcmFtKTtcbi8vICAgICAgICAgICAgfVxuLy8gICAgICAgIH0pXG4vLyAgICAgICAgb2JqZWN0W2NvbXBvbmVudC5NYWtlXVtjb21wb25lbnQuTW9kZWxdID0gY29tcG9uZW50O1xuLy8gICAgfVxuLy8gICAgcmV0dXJuIG9iamVjdDtcbi8vfTtcblxuXG5cblxuZi5sb2FkX2RhdGFiYXNlID0gZnVuY3Rpb24oRlNFQ19kYXRhYmFzZV9vYmope1xuICAgIEZTRUNfZGF0YWJhc2Vfb2JqID0gZi5sb3dlcmNhc2VfcHJvcGVydGllcyhGU0VDX2RhdGFiYXNlX29iaik7XG4gICAgdmFyIGNvbXBvbmVudHMgPSB7fTtcbiAgICBjb21wb25lbnRzLmludmVydGVycyA9IHt9O1xuICAgIEZTRUNfZGF0YWJhc2Vfb2JqLmludmVydGVycy5mb3JFYWNoKGZ1bmN0aW9uKGNvbXBvbmVudCl7XG4gICAgICAgIGlmKCBjb21wb25lbnRzLmludmVydGVyc1tjb21wb25lbnQubWFrZV0gPT09IHVuZGVmaW5lZCApIGNvbXBvbmVudHMuaW52ZXJ0ZXJzW2NvbXBvbmVudC5tYWtlXSA9IHt9O1xuICAgICAgICAvL2NvbXBvbmVudHMuaW52ZXJ0ZXJzW2NvbXBvbmVudC5tYWtlXVtjb21wb25lbnQubWFrZV0gPSBmLnByZXR0eV9uYW1lcyhjb21wb25lbnQpO1xuICAgICAgICBjb21wb25lbnRzLmludmVydGVyc1tjb21wb25lbnQubWFrZV1bY29tcG9uZW50Lm1vZGVsXSA9IGNvbXBvbmVudDtcbiAgICB9KTtcbiAgICBjb21wb25lbnRzLm1vZHVsZXMgPSB7fTtcbiAgICBGU0VDX2RhdGFiYXNlX29iai5tb2R1bGVzLmZvckVhY2goZnVuY3Rpb24oY29tcG9uZW50KXtcbiAgICAgICAgaWYoIGNvbXBvbmVudHMubW9kdWxlc1tjb21wb25lbnQubWFrZV0gPT09IHVuZGVmaW5lZCApIGNvbXBvbmVudHMubW9kdWxlc1tjb21wb25lbnQubWFrZV0gPSB7fTtcbiAgICAgICAgLy9jb21wb25lbnRzLm1vZHVsZXNbY29tcG9uZW50Lm1ha2VdW2NvbXBvbmVudC5tYWtlXSA9IGYucHJldHR5X25hbWVzKGNvbXBvbmVudCk7XG4gICAgICAgIGNvbXBvbmVudHMubW9kdWxlc1tjb21wb25lbnQubWFrZV1bY29tcG9uZW50Lm1vZGVsXSA9IGNvbXBvbmVudDtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb21wb25lbnRzO1xufTtcblxuXG5mLmdldF9yZWYgPSBmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl7XG4gICAgdmFyIHJlZl9hcnJheSA9IHN0cmluZy5zcGxpdCgnLicpO1xuICAgIHZhciBsZXZlbCA9IG9iamVjdDtcbiAgICByZWZfYXJyYXkuZm9yRWFjaChmdW5jdGlvbihsZXZlbF9uYW1lLGkpe1xuICAgICAgICBpZiggdHlwZW9mIGxldmVsW2xldmVsX25hbWVdID09PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXZlbCA9IGxldmVsW2xldmVsX25hbWVdO1xuICAgIH0pO1xuICAgIHJldHVybiBsZXZlbDtcbn07XG5mLnNldF9yZWYgPSBmdW5jdGlvbiggb2JqZWN0LCByZWZfc3RyaW5nLCB2YWx1ZSApe1xuICAgIHZhciByZWZfYXJyYXkgPSByZWZfc3RyaW5nLnNwbGl0KCcuJyk7XG4gICAgdmFyIGxldmVsID0gb2JqZWN0O1xuICAgIHJlZl9hcnJheS5mb3JFYWNoKGZ1bmN0aW9uKGxldmVsX25hbWUsaSl7XG4gICAgICAgIGlmKCB0eXBlb2YgbGV2ZWxbbGV2ZWxfbmFtZV0gPT09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldmVsID0gbGV2ZWxbbGV2ZWxfbmFtZV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbGV2ZWw7XG59O1xuXG5cblxuXG5mLmxvZ19pZl9kYXRhYmFzZV9sb2FkZWQgPSBmdW5jdGlvbihlKXtcbiAgICBpZihmLmcuc3RhdGUuZGF0YWJhc2VfbG9hZGVkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgIH1cbn07XG5cblxuXG5mLmxvd2VyY2FzZV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24gbG93ZXJjYXNlX3Byb3BlcnRpZXMob2JqKSB7XG4gICAgdmFyIG5ld19vYmplY3QgPSBuZXcgb2JqLmNvbnN0cnVjdG9yKCk7XG4gICAgZm9yKCB2YXIgb2xkX25hbWUgaW4gb2JqICl7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkob2xkX25hbWUpKSB7XG4gICAgICAgICAgICB2YXIgbmV3X25hbWUgPSBvbGRfbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYoIG9ialtvbGRfbmFtZV0uY29uc3RydWN0b3IgPT09IE9iamVjdCB8fCBvYmpbb2xkX25hbWVdLmNvbnN0cnVjdG9yID09PSBBcnJheSApe1xuICAgICAgICAgICAgICAgIG5ld19vYmplY3RbbmV3X25hbWVdID0gbG93ZXJjYXNlX3Byb3BlcnRpZXMob2JqW29sZF9uYW1lXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld19vYmplY3RbbmV3X25hbWVdID0gb2JqW29sZF9uYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiBuZXdfb2JqZWN0O1xufTtcblxuXG5mLnRvZ2dsZV9tb2R1bGUgPSBmdW5jdGlvbihlbGVtZW50KXtcbiAgICAvL2NvbnNvbGUubG9nKCdzd2l0Y2gnLCBlbGVtZW50LCBlbGVtZW50LmNsYXNzTGlzICk7XG5cbiAgICAvL2VsZW1lbnQuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBudWxsKTtcblxuICAgIHZhciBlbGVtID0gJChlbGVtZW50KTtcbiAgICAvL2NvbnNvbGUubG9nKCdzd2l0Y2gnLCBlbGVtWzBdLmNsYXNzTGlzdC5jb250YWlucygncHJldmlld19zdHJ1Y3R1cmFsX21vZHVsZScpICk7XG5cbiAgICB2YXIgciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtb2R1bGVfSUQnKS5zcGxpdCgnLCcpWzBdO1xuICAgIHZhciBjID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21vZHVsZV9JRCcpLnNwbGl0KCcsJylbMV07XG5cbiAgICBpZiggZy53ZWJwYWdlLnNlbGVjdGVkX21vZHVsZXNbcl1bY10gKXtcbiAgICAgICAgZy53ZWJwYWdlLnNlbGVjdGVkX21vZHVsZXNbcl1bY10gPSBmYWxzZTtcbiAgICAgICAgZy53ZWJwYWdlLnNlbGVjdGVkX21vZHVsZXNfdG90YWwtLTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnLndlYnBhZ2Uuc2VsZWN0ZWRfbW9kdWxlc1tyXVtjXSA9IHRydWU7XG4gICAgICAgIGcud2VicGFnZS5zZWxlY3RlZF9tb2R1bGVzX3RvdGFsKys7XG4gICAgfVxuXG4gICAgLypcbiAgICB2YXIgbGF5ZXI7XG4gICAgaWYoIGVsZW1bMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdzdmdfcHJldmlld19zdHJ1Y3R1cmFsX21vZHVsZV9zZWxlY3RlZCcpICl7XG4gICAgICAgIC8vZy53ZWJwYWdlLnNlbGVjdGVkX21vZHVsZXNbcl1bY10gPSB0cnVlO1xuICAgICAgICAvL2xheWVyID0gZy5kcmF3aW5nX3NldHRpbmdzLmxheWVyX2F0dHIucHJldmlld19zdHJ1Y3R1cmFsX21vZHVsZTtcbiAgICAgICAgLy9lbGVtZW50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwic3ZnX3ByZXZpZXdfc3RydWN0dXJhbF9tb2R1bGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZy53ZWJwYWdlLnNlbGVjdGVkX21vZHVsZXMgPSBnLndlYnBhZ2Uuc2VsZWN0ZWRfbW9kdWxlcyArMSB8fCAxO1xuICAgICAgICAvL2xheWVyID0gZy5kcmF3aW5nX3NldHRpbmdzLmxheWVyX2F0dHIucHJldmlld19zdHJ1Y3R1cmFsX21vZHVsZV9zZWxlY3RlZDtcbiAgICAgICAgLy9lbGVtZW50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFwic3ZnX3ByZXZpZXdfc3RydWN0dXJhbF9tb2R1bGVfc2VsZWN0ZWRcIik7XG4gICAgfVxuICAgIC8vKi9cbiAgICAvL2NvbnNvbGUubG9nKCBnLndlYnBhZ2Uuc2VsZWN0ZWRfbW9kdWxlcyk7XG4gICAgLy9mb3IoIHZhciBhdHRyX25hbWUgaW4gbGF5ZXIgKXtcbiAgICAvLyAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyX25hbWUsIGxheWVyW2F0dHJfbmFtZV0pO1xuXG4gICAgLy99XG5cbiAgICBnLmYudXBkYXRlKCk7XG5cbiAgICAvKlxuICAgIGlmKCBlbGVtLmhhc0NsYXNzKFwic3ZnX3ByZXZpZXdfc3RydWN0dXJhbF9tb2R1bGVcIikgKXtcbiAgICAgICAgZWxlbS5yZW1vdmVDbGFzcyhcInN2Z19wcmV2aWV3X3N0cnVjdHVyYWxfbW9kdWxlXCIpO1xuICAgICAgICBlbGVtLmFkZENsYXNzKFwic3ZnX3ByZXZpZXdfc3RydWN0dXJhbF9tb2R1bGVfc2VsZWN0ZWRcIik7XG4gICAgfSBlbHNlIGlmKCBlbGVtLmhhc0NsYXNzKFwic3ZnX3ByZXZpZXdfc3RydWN0dXJhbF9tb2R1bGVfc2VsZWN0ZWRcIikgKXtcbiAgICAgICAgZWxlbS5yZW1vdmVDbGFzcyhcInN2Z19wcmV2aWV3X3N0cnVjdHVyYWxfbW9kdWxlX3NlbGVjdGVkXCIpO1xuICAgICAgICBlbGVtLmFkZENsYXNzKFwic3ZnX3ByZXZpZXdfc3RydWN0dXJhbF9tb2R1bGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbS5hZGRDbGFzcyhcInN2Z19wcmV2aWV3X3N0cnVjdHVyYWxfbW9kdWxlXCIpO1xuICAgIH1cbiAgICAqL1xufTtcblxuXG5mLmNsZWFyX29iamVjdCA9IGZ1bmN0aW9uKG9iail7XG4gICAgZm9yKCB2YXIgaWQgaW4gb2JqICl7XG4gICAgICAgIGlmKCBvYmouaGFzT3duUHJvcGVydHkoaWQpKXtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpbaWRdO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gY2xlYXIgZHJhd2luZ1xuZi5jbGVhcl9kcmF3aW5nID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yKCB2YXIgaWQgaW4gZy5kcmF3aW5nICl7XG4gICAgICAgIGlmKCBnLmRyYXdpbmcuaGFzT3duUHJvcGVydHkoaWQpKXtcbiAgICAgICAgICAgIGYuY2xlYXJfb2JqZWN0KGcuZHJhd2luZ1tpZF0pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG5cbmYucXVlcnlfc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAvLyBCYXNlZCBvblxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85Nzk5OTVcbiAgdmFyIHF1ZXJ5X3N0cmluZyA9IHt9O1xuICB2YXIgcXVlcnkgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKTtcbiAgdmFyIHZhcnMgPSBxdWVyeS5zcGxpdChcIiZcIik7XG4gIHZhciBpO1xuICBmb3IgKCBpPTA7IGk8dmFycy5sZW5ndGg7IGkrKyApIHtcbiAgICB2YXIgcGFpciA9IHZhcnNbaV0uc3BsaXQoXCI9XCIpO1xuICAgICAgICAvLyBJZiBmaXJzdCBlbnRyeSB3aXRoIHRoaXMgbmFtZVxuICAgIGlmICh0eXBlb2YgcXVlcnlfc3RyaW5nW3BhaXJbMF1dID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHF1ZXJ5X3N0cmluZ1twYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICAgIC8vIElmIHNlY29uZCBlbnRyeSB3aXRoIHRoaXMgbmFtZVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHF1ZXJ5X3N0cmluZ1twYWlyWzBdXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXIgYXJyID0gWyBxdWVyeV9zdHJpbmdbcGFpclswXV0sIHBhaXJbMV0gXTtcbiAgICAgICAgcXVlcnlfc3RyaW5nW3BhaXJbMF1dID0gYXJyO1xuICAgICAgICAvLyBJZiB0aGlyZCBvciBsYXRlciBlbnRyeSB3aXRoIHRoaXMgbmFtZVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5X3N0cmluZ1twYWlyWzBdXS5wdXNoKHBhaXJbMV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcXVlcnlfc3RyaW5nO1xufTtcblxuZi5yZXF1ZXN0X2dlb2NvZGUgPSBmdW5jdGlvbigpe1xuICAgIGlmKCBmLnNlY3Rpb25fZGVmaW5lZChnLCAnbG9jYXRpb24nKSApe1xuICAgICAgICB2YXIgYWRkcmVzc19uZXcgPSBnLnBlcm0ubG9jYXRpb24ubmV3X2FkZHJlc3M7XG5cbiAgICAgICAgaWYoIGFkZHJlc3NfbmV3IHx8IGcucGVybS5sb2NhdGlvbi5sYXQgPT09IHVuZGVmaW5lZCB8fCBnLnBlcm0ubG9jYXRpb24ubGF0ID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbmV3IGFkZHJlc3MnKTtcbiAgICAgICAgICAgIHZhciBhZGRyZXNzID0gZW5jb2RlVVJJQ29tcG9uZW50KFtcbiAgICAgICAgICAgICAgICAgICAgZy5wZXJtLmxvY2F0aW9uLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIGcucGVybS5sb2NhdGlvbi5jaXR5LFxuICAgICAgICAgICAgICAgICAgICAnRkwnLFxuICAgICAgICAgICAgICAgICAgICBnLnBlcm0ubG9jYXRpb24uemlwXG4gICAgICAgICAgICAgICAgXS5qb2luKCcsICcpICk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGFkZHJlc3MpO1xuICAgICAgICAgICAgJCgnI2dlb2NvZGVfZGlzcGxheScpLnRleHQoJ1JlcXVlc3RpbmcgY29vcmRpbmF0ZXMuLi4nKTtcbiAgICAgICAgICAgICQuZ2V0SlNPTignaHR0cDovL25vbWluYXRpbS5vcGVuc3RyZWV0bWFwLm9yZy9zZWFyY2g/Zm9ybWF0PWpzb24mbGltaXQ9NSZxPScgKyBhZGRyZXNzLCBmLnNldF9jb29yZGluYXRlc19mcm9tX2dlb2NvZGUgKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJCgnI2dlb2NvZGVfZGlzcGxheScpLnRleHQoJ0FkZHJlc3MgdW5jaGFuZ2VkJyk7XG4gICAgICAgICAgICBmLnNldF9jb29yZGluYXRlc19mcm9tX2dlb2NvZGUoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgICQoJyNnZW9jb2RlX2Rpc3BsYXknKS50ZXh0KCdQbGVhc2UgZW50ZXIgYWRkcmVzcycpO1xuICAgIH1cbn07XG5cblxuZi5zZXRfc2F0X21hcF9tYXJrZXIgPSBmdW5jdGlvbigpe1xuICAgIHZhciBsYXRsbmcgPSBMLmxhdExuZyggZy5wZXJtLmxvY2F0aW9uLmxhdCwgZy5wZXJtLmxvY2F0aW9uLmxvbiApO1xuICAgIGcucGVybS5tYXBzLm1hcmtlcl9zYXQuc2V0TGF0TG5nKCBsYXRsbmcgKTtcbiAgICBnLnBlcm0ubWFwcy5tYXJrZXJfcm9hZC5zZXRMYXRMbmcoIGxhdGxuZyApO1xuICAgIGcucGVybS5tYXBzLm1hcF9zYXQuc2V0VmlldyggbGF0bG5nICk7XG59O1xuXG5mLnNldF9jb29yZGluYXRlc19mcm9tX21hcCA9IGZ1bmN0aW9uKGUpe1xuICAgIGcucGVybS5sb2NhdGlvbi5sYXQgPSBlLmxhdGxuZy5sYXQ7XG4gICAgZy5wZXJtLmxvY2F0aW9uLmxvbiA9IGUubGF0bG5nLmxuZztcbiAgICBmLnVwZGF0ZSgpO1xufTtcblxuZi5zZXRfY29vcmRpbmF0ZXNfZnJvbV9nZW9jb2RlID0gZnVuY3Rpb24oZGF0YSl7XG4gICAgaWYoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBnLnBlcm0ubG9jYXRpb24ubGF0ICE9PSB1bmRlZmluZWQgKXsgLy8gbG9hZGluZyBsYXN0IGxvY2F0aW9uc1xuICAgICAgICBnLnBlcm0ubG9jYXRpb24ubGF0ID0gZy5wZXJtLmdlb2NvZGUubGF0O1xuICAgICAgICBnLnBlcm0ubG9jYXRpb24ubG9uID0gZy5wZXJtLmdlb2NvZGUubG9uO1xuICAgICAgICBmLnVwZGF0ZSgpO1xuICAgIH0gZWxzZSBpZiggZGF0YVswXSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICQoJyNnZW9jb2RlX2Rpc3BsYXknKS50ZXh0KCdBZGRyZXNzIGxvYWRlZCcpO1xuICAgICAgICBjb25zb2xlLmxvZygnTmV3IGxvY2F0aW9uIGZyb20gYWRkcmVzcycsIGRhdGEpO1xuICAgICAgICBnLnBlcm0uZ2VvY29kZS5kYXRhID0gZGF0YTtcbiAgICAgICAgZy5wZXJtLmdlb2NvZGUubGF0ID0gZGF0YVswXS5sYXQ7XG4gICAgICAgIGcucGVybS5nZW9jb2RlLmxvbiA9IGRhdGFbMF0ubG9uO1xuICAgICAgICBnLnBlcm0ubG9jYXRpb24ubGF0ID0gZy5wZXJtLmdlb2NvZGUubGF0O1xuICAgICAgICBnLnBlcm0ubG9jYXRpb24ubG9uID0gZy5wZXJtLmdlb2NvZGUubG9uO1xuICAgICAgICBmLnVwZGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICQoJyNnZW9jb2RlX2Rpc3BsYXknKS50ZXh0KCdBZGRyZXNzIG5vdCBmb3VuZCcpO1xuICAgIH1cbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGY7XG4iLCJ2YXIgbWtfZHJhd2luZyA9IHJlcXVpcmUoJy4vbWtfZHJhd2luZycpO1xuXG4vL3ZhciBkcmF3aW5nX3BhcnRzID0gW107XG4vL2QubGlua19kcmF3aW5nX3BhcnRzKGRyYXdpbmdfcGFydHMpO1xuXG52YXIgcGFnZSA9IGZ1bmN0aW9uKHNldHRpbmdzKXtcbiAgICBjb25zb2xlLmxvZyhcIioqIE1ha2luZyBibG9ja3NcIik7XG4gICAgZCA9IG1rX2RyYXdpbmcoc2V0dGluZ3MpO1xuXG4gICAgdmFyIGYgPSBzZXR0aW5ncy5mO1xuXG4gICAgLy92YXIgY29tcG9uZW50cyA9IHNldHRpbmdzLmNvbXBvbmVudHM7XG4gICAgLy92YXIgc3lzdGVtID0gc2V0dGluZ3Muc3lzdGVtO1xuICAgIHZhciBzeXN0ZW0gPSBzZXR0aW5ncy5zeXN0ZW07XG5cbiAgICB2YXIgc2l6ZSA9IHNldHRpbmdzLmRyYXdpbmdfc2V0dGluZ3Muc2l6ZTtcbiAgICB2YXIgbG9jID0gc2V0dGluZ3MuZHJhd2luZ19zZXR0aW5ncy5sb2M7XG5cblxuXG5cbiAgICB2YXIgeCwgeSwgaCwgdztcbiAgICB2YXIgb2Zmc2V0O1xuXG4vLyBEZWZpbmUgZC5ibG9ja3NcblxuLy8gbW9kdWxlIGQuYmxvY2tcbiAgICB3ID0gc2l6ZS5tb2R1bGUuZnJhbWUudztcbiAgICBoID0gc2l6ZS5tb2R1bGUuZnJhbWUuaDtcblxuICAgIGQuYmxvY2tfc3RhcnQoJ21vZHVsZScpO1xuXG4gICAgLy8gZnJhbWVcbiAgICBkLmxheWVyKCdtb2R1bGUnKTtcbiAgICB4ID0gMDtcbiAgICB5ID0gMCtzaXplLm1vZHVsZS5sZWFkO1xuICAgIGQucmVjdCggW3gseStoLzJdLCBbdyxoXSApO1xuICAgIC8vIGZyYW1lIHRyaWFuZ2xlP1xuICAgIGQubGluZShbXG4gICAgICAgIFt4LXcvMix5XSxcbiAgICAgICAgW3gseSt3LzJdLFxuICAgIF0pO1xuICAgIGQubGluZShbXG4gICAgICAgIFt4LHkrdy8yXSxcbiAgICAgICAgW3grdy8yLHldLFxuICAgIF0pO1xuICAgIC8vIGxlYWRzXG4gICAgZC5sYXllcignRENfcG9zJyk7XG4gICAgZC5saW5lKFtcbiAgICAgICAgW3gsIHldLFxuICAgICAgICBbeCwgeS1zaXplLm1vZHVsZS5sZWFkXVxuICAgIF0pO1xuICAgIGQubGF5ZXIoJ0RDX25lZycpO1xuICAgIGQubGluZShbXG4gICAgICAgIFt4LCB5K2hdLFxuICAgICAgICBbeCwgeStoKyhzaXplLm1vZHVsZS5sZWFkKV1cbiAgICBdKTtcbiAgICAvLyBwb3Mgc2lnblxuICAgIGQubGF5ZXIoJ3RleHQnKTtcbiAgICBkLnRleHQoXG4gICAgICAgIFt4K3NpemUubW9kdWxlLmxlYWQvMiwgeS1zaXplLm1vZHVsZS5sZWFkLzJdLFxuICAgICAgICAnKycsXG4gICAgICAgIG51bGwsXG4gICAgICAgICdzaWducydcbiAgICApO1xuICAgIC8vIG5lZyBzaWduXG4gICAgZC50ZXh0KFxuICAgICAgICBbeCtzaXplLm1vZHVsZS5sZWFkLzIsIHkraCtzaXplLm1vZHVsZS5sZWFkLzJdLFxuICAgICAgICAnLScsXG4gICAgICAgIG51bGwsXG4gICAgICAgICdzaWducydcbiAgICApO1xuICAgIC8vIGdyb3VuZFxuICAgIGQubGF5ZXIoJ0RDX2dyb3VuZCcpO1xuICAgIGQubGluZShbXG4gICAgICAgIFt4LXcvMiwgeStoLzJdLFxuICAgICAgICBbeC13LzItdy80LCB5K2gvMl0sXG4gICAgXSk7XG5cbiAgICBkLmxheWVyKCk7XG4gICAgZC5ibG9ja19lbmQoKTtcblxuLy8jc3RyaW5nXG4gICAgZC5ibG9ja19zdGFydCgnc3RyaW5nJyk7XG5cbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcblxuXG5cblxuXG4gICAgdmFyIG1heF9kaXNwbGF5ZWRfbW9kdWxlcyA9IDk7XG4gICAgdmFyIGJyZWFrX3N0cmluZyA9IGZhbHNlO1xuXG4gICAgaWYoIHN5c3RlbS5hcnJheS5tb2R1bGVzX3Blcl9zdHJpbmcgPiBtYXhfZGlzcGxheWVkX21vZHVsZXMgKXtcbiAgICAgICAgZGlzcGxheWVkX21vZHVsZXMgPSBtYXhfZGlzcGxheWVkX21vZHVsZXMgLSAxO1xuICAgICAgICBicmVha19zdHJpbmcgPSB0cnVlO1xuICAgICAgICBzaXplLnN0cmluZy5oID0gKHNpemUubW9kdWxlLmggKiAoZGlzcGxheWVkX21vZHVsZXMrMSkgKSArIHNpemUuc3RyaW5nLmdhcF9taXNzaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BsYXllZF9tb2R1bGVzID0gc3lzdGVtLmFycmF5Lm1vZHVsZXNfcGVyX3N0cmluZztcbiAgICAgICAgc2l6ZS5zdHJpbmcuaCA9IChzaXplLm1vZHVsZS5oICogZGlzcGxheWVkX21vZHVsZXMpO1xuICAgIH1cbiAgICBsb2MuYXJyYXkubG93ZXIgPSBsb2MuYXJyYXkudXBwZXIgKyBzaXplLnN0cmluZy5oO1xuXG4gICAgc2l6ZS5zdHJpbmcuaF9tYXggPSAoc2l6ZS5tb2R1bGUuaCAqIG1heF9kaXNwbGF5ZWRfbW9kdWxlcykgKyBzaXplLnN0cmluZy5nYXBfbWlzc2luZztcbiAgICBsb2MuYXJyYXkubG93ZXJfbGltaXQgPSBsb2MuYXJyYXkudXBwZXIgKyBzaXplLnN0cmluZy5oX21heDtcblxuXG5cbiAgICBmb3IoIHZhciByPTA7IHI8ZGlzcGxheWVkX21vZHVsZXM7IHIrKyl7XG4gICAgICAgIGQuYmxvY2soJ21vZHVsZScsIFt4LHldKTtcbiAgICAgICAgeSArPSBzaXplLm1vZHVsZS5oO1xuXG4gICAgfVxuICAgIGlmKCBicmVha19zdHJpbmcgKSB7XG4gICAgICAgIGQubGluZShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBbeCx5XSxcbiAgICAgICAgICAgICAgICBbeCx5K3NpemUuc3RyaW5nLmdhcF9taXNzaW5nXSxcbiAgICAgICAgICAgIC8vW3gtc2l6ZS5tb2R1bGUuZnJhbWUudyozLzQsIHkrc2l6ZS5zdHJpbmcuaCArIHNpemUud2lyZV9vZmZzZXQuZ3JvdW5kIF0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ0RDX2ludGVybW9kdWxlJ1xuICAgICAgICApO1xuXG4gICAgICAgIHkgKz0gc2l6ZS5zdHJpbmcuZ2FwX21pc3Npbmc7XG4gICAgICAgIGQuYmxvY2soJ21vZHVsZScsIFt4LHldKTtcbiAgICB9XG5cbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcblxuICAgIC8vVE9ETzogYWRkIGxvb3AgdG8ganVtcCBvdmVyIG5lZ2F0aXZlIHJldHVybiB3aXJlc1xuICAgIGQubGF5ZXIoJ0RDX2dyb3VuZCcpO1xuICAgIGQubGluZShbXG4gICAgICAgIFt4LXNpemUubW9kdWxlLmZyYW1lLncqMy80LCB5K3NpemUubW9kdWxlLmgvMl0sXG4gICAgICAgIFt4LXNpemUubW9kdWxlLmZyYW1lLncqMy80LCB5K3NpemUuc3RyaW5nLmhfbWF4ICsgc2l6ZS53aXJlX29mZnNldC5ncm91bmRdLFxuICAgICAgICAvL1t4LXNpemUubW9kdWxlLmZyYW1lLncqMy80LCB5K3NpemUuc3RyaW5nLmggKyBzaXplLndpcmVfb2Zmc2V0Lmdyb3VuZCBdLFxuICAgIF0pO1xuICAgIGQubGF5ZXIoKTtcblxuXG4gICAgZC5ibG9ja19lbmQoKTtcblxuXG4vLyB0ZXJtaW5hbFxuICAgIGQuYmxvY2tfc3RhcnQoJ3Rlcm1pbmFsJyk7XG4gICAgeCA9IDA7XG4gICAgeSA9IDA7XG5cbiAgICBkLmxheWVyKCd0ZXJtaW5hbCcpO1xuICAgIGQuY2lyYyhcbiAgICAgICAgW3gseV0sXG4gICAgICAgIHNpemUudGVybWluYWxfZGlhbVxuICAgICk7XG4gICAgZC5sYXllcigpO1xuICAgIGQuYmxvY2tfZW5kKCk7XG5cbi8vIGZ1c2VcblxuICAgIGQuYmxvY2tfc3RhcnQoJ2Z1c2UnKTtcbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcbiAgICB3ID0gMTA7XG4gICAgaCA9IDU7XG5cbiAgICBkLmxheWVyKCd0ZXJtaW5hbCcpO1xuICAgIGQucmVjdChcbiAgICAgICAgW3gseV0sXG4gICAgICAgIFt3LGhdXG4gICAgKTtcbiAgICBkLmxpbmUoIFtcbiAgICAgICAgW3cvMix5XSxcbiAgICAgICAgW3cvMitzaXplLmZ1c2UudywgeV1cbiAgICBdKTtcbiAgICBkLmJsb2NrKCd0ZXJtaW5hbCcsIFtzaXplLmZ1c2UudywgeV0gKTtcblxuICAgIGQubGluZSggW1xuICAgICAgICBbLXcvMix5XSxcbiAgICAgICAgWy13LzItc2l6ZS5mdXNlLncsIHldXG4gICAgXSk7XG4gICAgZC5ibG9jaygndGVybWluYWwnLCBbLXNpemUuZnVzZS53LCB5XSApO1xuXG4gICAgZC5sYXllcigpO1xuICAgIGQuYmxvY2tfZW5kKCk7XG5cbi8vIGdyb3VuZCBzeW1ib2xcbiAgICBkLmJsb2NrX3N0YXJ0KCdncm91bmQnKTtcbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcblxuICAgIGQubGF5ZXIoJ0FDX2dyb3VuZCcpO1xuICAgIGQubGluZShbXG4gICAgICAgIFt4LHldLFxuICAgICAgICBbeCx5KzQwXSxcbiAgICBdKTtcbiAgICB5ICs9IDI1O1xuICAgIGQubGluZShbXG4gICAgICAgIFt4LTcuNSx5XSxcbiAgICAgICAgW3grNy41LHldLFxuICAgIF0pO1xuICAgIHkgKz0gNTtcbiAgICBkLmxpbmUoW1xuICAgICAgICBbeC01LHldLFxuICAgICAgICBbeCs1LHldLFxuICAgIF0pO1xuICAgIHkgKz0gNTtcbiAgICBkLmxpbmUoW1xuICAgICAgICBbeC0yLjUseV0sXG4gICAgICAgIFt4KzIuNSx5XSxcbiAgICBdKTtcbiAgICBkLmxheWVyKCk7XG5cbiAgICBkLmJsb2NrX2VuZCgpO1xuXG5cblxuLy8gTm9ydGggYXJyb3dcbiAgICB4ID0gMDtcbiAgICB5ID0gMDtcblxuICAgIHZhciBhcnJvd193ID0gNztcbiAgICB2YXIgbGV0dGVyX2ggPSAxNDtcbiAgICB2YXIgYXJyb3dfaCA9IDUwO1xuXG4gICAgZC5ibG9ja19zdGFydCgnbm9ydGggYXJyb3dfdXAnKTtcbiAgICBkLmxheWVyKCdub3J0aF9sZXR0ZXInKTtcbiAgICBkLmxpbmUoW1xuICAgICAgICBbeCwgeStsZXR0ZXJfaF0sXG4gICAgICAgIFt4LCB5XSxcbiAgICAgICAgW3grYXJyb3dfdywgeStsZXR0ZXJfaF0sXG4gICAgICAgIFt4K2Fycm93X3csIHldLFxuICAgIF0pO1xuICAgIGQubGF5ZXIoJ25vcnRoX2Fycm93Jyk7XG4gICAgZC5saW5lKFtcbiAgICAgICAgW3gsIHkrYXJyb3dfaF0sXG4gICAgICAgIFt4LCB5XSxcbiAgICAgICAgW3grYXJyb3dfdy8yLCB5K2xldHRlcl9oLzJdLFxuICAgIF0pO1xuICAgIGQubGluZShbXG4gICAgICAgIFt4LCB5XSxcbiAgICAgICAgW3gtYXJyb3dfdy8yLCB5K2xldHRlcl9oLzJdLFxuICAgIF0pO1xuICAgIGQubGF5ZXIoKTtcbiAgICBkLmJsb2NrX2VuZCgnbm9ydGggYXJyb3cnKTtcblxuICAgIGQuYmxvY2tfc3RhcnQoJ25vcnRoIGFycm93X2xlZnQnKTtcbiAgICBkLmxheWVyKCdub3J0aF9sZXR0ZXInKTtcbiAgICBkLmxpbmUoW1xuICAgICAgICBbeCtsZXR0ZXJfaCwgeV0sXG4gICAgICAgIFt4LCB5XSxcbiAgICAgICAgW3grbGV0dGVyX2gsIHktYXJyb3dfd10sXG4gICAgICAgIFt4LCAgICAgICAgICB5LWFycm93X3ddLFxuICAgIF0pO1xuICAgIGQubGF5ZXIoJ25vcnRoX2Fycm93Jyk7XG4gICAgZC5saW5lKFtcbiAgICAgICAgW3grYXJyb3dfaCwgeV0sXG4gICAgICAgIFt4LCB5XSxcbiAgICAgICAgW3grbGV0dGVyX2gvMiwgeS1hcnJvd193LzJdLFxuICAgIF0pO1xuICAgIGQubGluZShbXG4gICAgICAgIFt4LCB5XSxcbiAgICAgICAgW3grbGV0dGVyX2gvMiwgeSthcnJvd193LzJdLFxuICAgIF0pO1xuICAgIGQubGF5ZXIoKTtcbiAgICBkLmJsb2NrX2VuZCgnbm9ydGggYXJyb3cnKTtcblxuLy8qL1xuXG4gICAgcmV0dXJuIGQuZHJhd2luZ19wYXJ0cztcbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhZ2U7XG4iLCJ2YXIgbWtfZHJhd2luZyA9IHJlcXVpcmUoJy4vbWtfZHJhd2luZycpO1xuXG4vL3ZhciBkcmF3aW5nX3BhcnRzID0gW107XG4vL2QubGlua19kcmF3aW5nX3BhcnRzKGRyYXdpbmdfcGFydHMpO1xuXG4vKlxudmFyIGZzZWNfbG9nb19iNjQgPSAgJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaFhBQmNBTlVBQUlXUlpVOWtkeVpEaFdwN2JuZUdhcnUrVTNDRHRrRlpmRFJPZ0ttMTA5L2YzL3o4L05iVzFseHZvanBUbHVUZlJjREN4MXh2YzY2elY5YlVTc25KVHFDblhKT2NZT3pzN1BIeitFUmRvTGpCMisvdjc5M2Y1SDZQdmZMeTh2THJRUms0aXN6TXpQLy8vd0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFDSDVCQUFBQUFBQUxBQUFBQUJjQUZ3QUFBYi9RSkZ3U0N3YWo4aWtjc2xzT3AvUXFIUktyVnF2Mkt4Mnl6MTJFdDF3MkFBQ2djWG9LN2xzVHJ1bGEzYjdUVi9HNWZPNm5uakg1L2QxZlg1L2dHbUNnNFNGWFllSWlZcFpqSTJPajFXUmtwT1VVWmFYbUpsTm01eWRua21nb2FLalJhV21wNmdpb0FKNENDQ3dpR2V0U0pZSUFTQUVlQUFnQTVLMnQzeWN2eFo0RmdLL3dzVEZmclJzRWlBVmNnZ0FBN3R5RVg3RHJZS3d6R3dBRVFYYUlBQUFFdWNnQWNIc3JIcUhBd2NCdld3V0ZnQUZaUUlQQXcvT0NlQkg0RUMzYjQwa0hDZ1FyQXdGaGg4a0FLRHdJY0NIZXdJb0RCaHc3NkNuWEJRT2ZBQ0FnTUNIQWdJK3FQd3d3V0xBQUE4UFRHaEdDVlFGaVN0UGdwQ3dNbHZPL3djeU85WjZkQWplZ0lvVlZ2SkQ4T0FEaFRJNUJ3Q29pSWRBdERMZTZEQ1NHaTJDenFRZmtJRW9TV3ZDaDM4Z21ob3NFNkRDVlRaWkRRMFNZSUhlQkFBQklqVDlJTXZkdFFJRkhrb29HQUNXUmFjUkNBUVdNRUNaeHplV0ZKZkxTUlZCQWNvNUM4aWFtdE1DVEc1RDNZQTY4QUFiUlpVSGptTEdURUIxeEFBV2dGNktxMFdWU1pTcEk3aGVUZGxDUFFFWlA0Q2VMVVlWVkowZ3ZQTG0zZkR5VEZPMEs2MENJVkxsQUgvTGVUOWd2RktXdFViUjRWeXlwdzlBN0pYcHNpK3Z3UGtzZTNWNGFhb3h4YmhDZ2FZVEpHQlh2L29CQWdsN0ZWREJkYUdFOTBrb1VrbFF3R0RldGNQZmNzTWRRSUNDRWpVa24zalQvYWRTQVFhMTkvOGdaYjhFWUZaWURSWTRSUUxUeVdHU1NoRjQrT0ZLRlNoM1VZcFlUV0djSEllTjVPS0xKN1VIenlvYTJKaGljRTR0d3lPSUI1eEd3VnVoWklBQkZhb3dadFpkc0t4NHBFcjNBR0JXYVNWZTRxUVZteENRRHphNkZFYmRsU3NaVktZNzZWZ2dGQ0pmV25GQkE1eEVVTUdJS3JXRUo0OFQ2SlhUQkRFMithU2NJWVJBSnlLSlJSQ0FPNWVwaEEyYWphMmswYUl0cm9XSUF4eGNjVUdoaFI3S1NVcW9nZERvaTA4ZHR0MHFEa0FRd2dWVmJNcHBwNkdBMmhCVEwvcFhSbExQaFpJcXA2eEs0Y0dycjNyYVNGTEJ0RWhBQUh1cEYxQTYxeVVsamlTN3Z0cHJGQW9BeTZtd2ZsalEwZ0I0RW1DWmVwcForUUFCZWxsNHFhcldiakQvUmJYV0dqcklmOTZldHRJOUE4aWJrMFpsN0hiU0FRQzRkVzY3REN4QUJidldZa3RXQkJRQWNJQUFQUEhGeXpvSXRKaE9CQWdzQklBQTFWWERXRWdDV09WSHRNQUdiQVhCd0dJTHpNVnNXSVJTbzg5RklBRm9TZ3BnVmpSMG1jc0d5SytLZkFYSndjb2hBRHdXQmRDd1NtT3BaR3RtWGxsYVJwY2c0TXlwemxqd2ZLMGtGckRIMGw0N3dRaENuaFR0OCt3Z1RoY0tkUlpTd3pvWGh6UEt6TmRQVy9PVEhGQVRNSGt6dWlFTDNFWFo3dnBSd1FFRHNrSEFCRWRabFJTeUhmSE43Ny9XanMwRjN0Z2VjTUExT0VvMFRSa0ZxTU1PU2ZSOFRIZk9kcVBCdUI5dkpxWlF5bTRPVjhhYlpZUWRndUppZkM0SlNkWElJUUhrbDZqT3RMcm43ZWFOeUM5di92SzE1Z0IzWG9mcmd4Z0VqMEZ5engyOElzVFRDUGJtVHdzUFNQUE9LNSs0OUlWUTc3enQyRE9mdThuVGNYK0w5cWFJVHd6NXRVTXZkdmVqb0k5NDNjNFE0VDRlNXNjL3hQeXBxNzg2Kzg3TVg3LzlSVURmL3dBWXdPOEI3M29FVkVMekJwaEFJN2lPZ1ExMDRQY2dHRUVKdGt0L3Q2dmdFZkNHUUEwNmdZUFI4eUFVUUpoQkVTWUJieVUwNFFrN3FFSnFjYTZGQTFzZkRLdWdnQlRPa0FuOHU2RU9kOGpESHFJaUNBQTcnO1xuLy8qL1xuXG5cbnZhciBhZGRfYm9yZGVyID0gZnVuY3Rpb24oc2V0dGluZ3MsIHNoZWV0X2luZm8pe1xuICAgIGQgPSBta19kcmF3aW5nKHNldHRpbmdzKTtcbiAgICB2YXIgZiA9IHNldHRpbmdzLmY7XG5cbiAgICAvL3ZhciBjb21wb25lbnRzID0gc2V0dGluZ3MuY29tcG9uZW50cztcbiAgICAvL3ZhciBzeXN0ZW0gPSBzZXR0aW5ncy5zeXN0ZW07XG4gICAgdmFyIHN5c3RlbSA9IHNldHRpbmdzLnN5c3RlbTtcblxuICAgIHZhciBzaXplID0gc2V0dGluZ3MuZHJhd2luZ19zZXR0aW5ncy5zaXplO1xuICAgIHZhciBsb2MgPSBzZXR0aW5ncy5kcmF3aW5nX3NldHRpbmdzLmxvYztcblxuXG5cblxuICAgIHZhciB4LCB5LCBoLCB3O1xuICAgIHZhciBvZmZzZXQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRnJhbWVcbiAgICBkLnNlY3Rpb24oJ0ZyYW1lJyk7XG5cbiAgICB3ID0gc2l6ZS5kcmF3aW5nLnc7XG4gICAgaCA9IHNpemUuZHJhd2luZy5oO1xuICAgIHZhciBwYWRkaW5nID0gc2l6ZS5kcmF3aW5nLmZyYW1lX3BhZGRpbmc7XG5cbiAgICBkLmxheWVyKCdib3JkZXJfbGluZXMnKTtcblxuICAgIC8vYm9yZGVyXG4gICAgZC5yZWN0KCBbdy8yICwgaC8yXSwgW3cgLSBwYWRkaW5nKjIsIGggLSBwYWRkaW5nKjIgXSApO1xuXG4gICAgdmFyIHJpZ2h0X29mZnNldCA9IHNpemUuZHJhd2luZy50aXRsZWJveDtcblxuXG4vLyBQcm9qZWN0L0ZTRUMgbG9nb1xuICAgIHggPSB3IC0gcGFkZGluZztcbiAgICB5ID0gMCArIHBhZGRpbmc7XG4gICAgdmFyIEZTRUNfbG9nb193aWR0aCA9IDMyO1xuICAgIHggKz0gLUZTRUNfbG9nb193aWR0aDtcblxuICAgIGQuaW1hZ2UoXG4gICAgICAgIFt4LTIseSsyXSxcbiAgICAgICAgW0ZTRUNfbG9nb193aWR0aCxGU0VDX2xvZ29fd2lkdGhdLFxuICAgICAgICAnZGF0YS9sb2dvL0ZTRUMuZ2lmJ1xuICAgICk7XG4gICAgZC5saW5lKFtcbiAgICAgICAgW3gtNCx5XSxcbiAgICAgICAgW3gtNCwgICAgICAgICAgICAgICAgeSs0K0ZTRUNfbG9nb193aWR0aF0sXG4gICAgICAgIFt3LXBhZGRpbmcseSs0K0ZTRUNfbG9nb193aWR0aF0sXG4gICAgXSk7XG5cblxuLy8gdGl0bGUgYm94ZXNcblxuICAgIC8vIHRpdGxlIGJveFxuICAgIHZhciB0aXRsZWJveCA9IHNpemUuZHJhd2luZy50aXRsZWJveDtcblxuICAgIC8vIHNpZGVcbiAgICB4ID0gdyAtIHBhZGRpbmcgLSB0aXRsZWJveC5zaWRlLnc7XG4gICAgeSA9IGggLSBwYWRkaW5nO1xuICAgIGQubGluZShbXG4gICAgICAgIFsgeCwgeV0sXG4gICAgICAgIFsgeCwgICAgICAgICAgICAgICAgIHkgLSB0aXRsZWJveC5zaWRlLmhdLFxuICAgICAgICBbIHgrdGl0bGVib3guc2lkZS53LCB5IC0gdGl0bGVib3guc2lkZS5oXVxuICAgIF0pO1xuXG4gICAgLy9ib3R0b21cbiAgICB4ID0gdyAtIHBhZGRpbmcgLSB0aXRsZWJveC5zaWRlLncgLSB0aXRsZWJveC5ib3R0b20udztcbiAgICB5ID0gaCAtIHBhZGRpbmc7XG4gICAgZC5saW5lKFtcbiAgICAgICAgWyB4LCB5XSxcbiAgICAgICAgWyB4LCB5IC0gdGl0bGVib3guYm90dG9tLmhdLFxuICAgICAgICBbIHggKyB0aXRsZWJveC5ib3R0b20udyAsIHkgLSB0aXRsZWJveC5ib3R0b20uaF0sXG4gICAgXSk7XG5cblxuLy8gYm90dG9tIGJhciBjb250ZW50XG5cblxuICAgIHggPSB3IC0gcGFkZGluZyAtIHRpdGxlYm94LmJvdHRvbS53IC0gdGl0bGVib3guc2lkZS53O1xuICAgIHkgPSBoIC0gcGFkZGluZyAtIHRpdGxlYm94LmJvdHRvbS5oO1xuXG5cbiAgICBpZiggc2V0dGluZ3MuZi5zZWN0aW9uX2RlZmluZWQoc2V0dGluZ3MsICdsb2NhdGlvbicpICApe1xuICAgICAgICBkLnRleHQoW3grMTAseSt0aXRsZWJveC5ib3R0b20uaCAqMS80XSwgW1xuICAgICAgICAgICAgJ1BWIFN5c3RlbSBEZXNpZ24nLFxuICAgICAgICAgICAgc2V0dGluZ3MucGVybS5sb2NhdGlvbi5hZGRyZXNzLFxuICAgICAgICAgICAgc2V0dGluZ3MucGVybS5sb2NhdGlvbi5jaXR5ICsgJywgJyArIHNldHRpbmdzLnBlcm0ubG9jYXRpb24uY291bnR5ICsgJywgRkwsICcgKyBzZXR0aW5ncy5wZXJtLmxvY2F0aW9uLnppcCxcblxuICAgICAgICBdLCAndGV4dCcsICdib3JkZXJfaW5mbycpO1xuICAgIH1cblxuXG4gICAgeCArPSAxNTA7XG4gICAgZC5saW5lKFtcbiAgICAgICAgWyB4ICwgeSBdLFxuICAgICAgICBbIHggLCB5K3RpdGxlYm94LmJvdHRvbS5oIF0sXG4gICAgXSk7XG4gICAgZC50ZXh0KFt4KzEwLHkrdGl0bGVib3guYm90dG9tLmggKjEvNF0sXG4gICAgICAgICBbICdQViBTeXN0ZW0gRGVzaWduJyBdLFxuICAgICAgICAndGV4dCcsXG4gICAgICAgICdib3JkZXJfaW5mbydcbiAgICAgICAgKTtcblxuXG5cblxuLy8gU2lkZSBiYXIgY29udGVudFxuXG4gICAgeCA9IHcgLSBwYWRkaW5nIC0gdGl0bGVib3guc2lkZS53O1xuICAgIHkgPSBoIC0gcGFkZGluZyAtIHRpdGxlYm94LnNpZGUuaDtcblxuICAgIC8vIENvbnRyYWN0b3IgbmFtZSBib3hcbiAgICBkLnRleHQoW3grdGl0bGVib3guc2lkZS53LzIseSsxMF0sIFtcbiAgICAgICAgICAgICBbICdTb2xhciBJbnN0YWxsZXIgSW5jLicgXSxcbiAgICAgICAgICAgICBbICcxMjM0IFllbGxvdyBTdWIgTG4uJyBdLFxuICAgICAgICAgICAgIFsgJ0NvY29hLCBGbCAzMjkyMicgXSxcbiAgICAgICAgIF0sXG4gICAgICAgICAndGV4dCcsXG4gICAgICAgICdpbnN0YWxsZXJfaW5mbydcbiAgICAgICAgKTtcblxuXG4gICAgeSArPSB0aXRsZWJveC5zaWRlLncvMjtcbiAgICBkLmxpbmUoW1xuICAgICAgICBbIHggLCB5IF0sXG4gICAgICAgIFsgeCt0aXRsZWJveC5zaWRlLncgLCB5IF0sXG4gICAgXSk7XG5cbiAgICAvLyBtYW51ZmFjdHVyZXIgbG9nbyBib3hcbiAgICB2YXIgbG9nb19nYXAgPSAyO1xuICAgIHZhciBsb2dvX3dpZHRoID0gKHRpdGxlYm94LnNpZGUudy1sb2dvX2dhcCozKS8yO1xuXG4gICAgdmFyIGxvZ29zID0gW1xuICAgICAgICAnZGF0YS9sb2dvL1NNQS5wbmcnLFxuICAgICAgICAnZGF0YS9sb2dvL3N1bml2YS5qcGcnLFxuICAgICAgICAnZGF0YS9sb2dvL3NjaGxldHRlci5zdmcnLFxuICAgIF07XG4gICAgZC5pbWFnZShcbiAgICAgICAgW3grbG9nb19nYXAseStsb2dvX2dhcF0sXG4gICAgICAgIFtsb2dvX3dpZHRoLGxvZ29fd2lkdGhdLFxuICAgICAgICBsb2dvc1swXVxuICAgICk7XG4gICAgZC5pbWFnZShcbiAgICAgICAgW3grbG9nb19nYXAseStsb2dvX2dhcCtsb2dvX3dpZHRoK2xvZ29fZ2FwXSxcbiAgICAgICAgW2xvZ29fd2lkdGgsbG9nb193aWR0aF0sXG4gICAgICAgIGxvZ29zWzFdXG4gICAgKTtcbiAgICBkLmltYWdlKFxuICAgICAgICBbeCtsb2dvX2dhcCtsb2dvX3dpZHRoK2xvZ29fZ2FwLHkrbG9nb19nYXBdLFxuICAgICAgICBbbG9nb193aWR0aCxsb2dvX3dpZHRoXSxcbiAgICAgICAgbG9nb3NbMl1cbiAgICApO1xuXG4gICAgeSArPSB0aXRsZWJveC5zaWRlLnc7XG4gICAgZC5saW5lKFtcbiAgICAgICAgWyB4ICwgeSBdLFxuICAgICAgICBbIHgrdGl0bGVib3guc2lkZS53ICwgeSBdLFxuICAgIF0pO1xuXG5cbiAgICB5ICs9IHRpdGxlYm94LnNpZGUudztcbiAgICBkLmxpbmUoW1xuICAgICAgICBbIHggLCB5IF0sXG4gICAgICAgIFsgeCt0aXRsZWJveC5zaWRlLncgLCB5IF0sXG4gICAgXSk7XG5cbiAgICB5ICs9IHRpdGxlYm94LnNpZGUudyAvODtcbiAgICBkLnRleHQoW3grdGl0bGVib3guc2lkZS53LzIseSsxMF0sIFtcbiAgICAgICAgICAgICBbIHNoZWV0X2luZm8ubnVtIF0sXG4gICAgICAgIF0sXG4gICAgICAgICd0ZXh0JyxcbiAgICAgICAgJ3NoZWV0X251bSdcbiAgICAgICAgKTtcblxuICAgIC8qXG4gICAgZC5pbWFnZShcbiAgICAgICAgW3grMzIseSszMl0sXG4gICAgICAgIFszMiwzMl0sXG4gICAgICAgIGxvZ29zWzNdXG4gICAgKTtcbiAgICAvLyovXG5cblxuXG4gICAgLypcbiAgICB4ID0gdyAtIHBhZGRpbmcgKiAzO1xuICAgIHkgPSBwYWRkaW5nICogMztcblxuICAgIHcgPSBzaXplLmRyYXdpbmcudGl0bGVib3g7XG4gICAgaCA9IHNpemUuZHJhd2luZy50aXRsZWJveDtcblxuICAgIC8vIGJveCB0b3AtcmlnaHRcbiAgICAvL2QucmVjdCggW3gtdy8yLCB5K2gvMl0sIFt3LGhdICk7XG5cbiAgICB5ICs9IGggKyBwYWRkaW5nO1xuXG4gICAgdyA9IHNpemUuZHJhd2luZy50aXRsZWJveDtcbiAgICBoID0gc2l6ZS5kcmF3aW5nLmggLSBwYWRkaW5nKjggLSBzaXplLmRyYXdpbmcudGl0bGVib3gqMi41O1xuXG4gICAgLy90aXRsZSBib3hcbiAgICAvL2QucmVjdCggW3gtdy8yLCB5K2gvMl0sIFt3LGhdICk7XG5cbiAgICB2YXIgdGl0bGUgPSB7fTtcbiAgICB0aXRsZS50b3AgPSB5O1xuICAgIHRpdGxlLmJvdHRvbSA9IHkraDtcbiAgICB0aXRsZS5yaWdodCA9IHg7XG4gICAgdGl0bGUubGVmdCA9IHgtdyA7XG5cblxuICAgIC8vIGJveCBib3R0b20tcmlnaHRcbiAgICBoID0gc2l6ZS5kcmF3aW5nLnRpdGxlYm94ICogMS41O1xuICAgIHkgPSB0aXRsZS5ib3R0b20gKyBwYWRkaW5nO1xuICAgIHggPSB4LXcvMjtcbiAgICB5ID0geStoLzI7XG4gICAgZC5yZWN0KCBbeCwgeV0sIFt3LGhdICk7XG5cbiAgICB5IC09IDIwKjIvMztcbiAgICBkLnRleHQoW3gseV0sXG4gICAgICAgIFsgc2hlZXRfc2VjdGlvbiwgc2hlZXRfbnVtIF0sXG4gICAgICAgICd0ZXh0JyxcbiAgICAgICAgJ3BhZ2UnXG4gICAgICAgICk7XG5cblxuICAgIHZhciBwYWdlID0ge307XG4gICAgcGFnZS5yaWdodCA9IHRpdGxlLnJpZ2h0O1xuICAgIHBhZ2UubGVmdCA9IHRpdGxlLmxlZnQ7XG4gICAgcGFnZS50b3AgPSB0aXRsZS5ib3R0b20gKyBwYWRkaW5nO1xuICAgIHBhZ2UuYm90dG9tID0gcGFnZS50b3AgKyBzaXplLmRyYXdpbmcudGl0bGVib3gqMS41O1xuICAgIC8vIGQudGV4dFxuXG4gICAgeCA9IHRpdGxlLmxlZnQgKyBwYWRkaW5nO1xuICAgIHkgPSB0aXRsZS5ib3R0b20gLSBwYWRkaW5nO1xuXG4gICAgeCArPSAxMDtcbiAgICBpZiggc3lzdGVtLmludmVydGVyLm1ha2UgJiYgc3lzdGVtLmludmVydGVyLm1vZGVsICl7XG4gICAgICAgIGQudGV4dChbeCx5XSxcbiAgICAgICAgICAgICBbICdQViBTeXN0ZW0gRGVzaWduJyBdLFxuICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgJ3RpdGxlMSdcbiAgICAgICAgICAgICkucm90YXRlKC05MCk7XG5cbiAgICB9XG5cbiAgICB4ICs9IDE0O1xuICAgIGlmKCBzZXR0aW5ncy5mLnNlY3Rpb25fZGVmaW5lZChzZXR0aW5ncywgJ2xvY2F0aW9uJykgICl7XG4gICAgICAgIGQudGV4dChbeCx5XSwgW1xuICAgICAgICAgICAgc2V0dGluZ3MucGVybS5sb2NhdGlvbi5hZGRyZXNzLFxuICAgICAgICAgICAgc2V0dGluZ3MucGVybS5sb2NhdGlvbi5jaXR5ICsgJywgJyArIHNldHRpbmdzLnBlcm0ubG9jYXRpb24uY291bnR5ICsgJywgRkwsICcgKyBzZXR0aW5ncy5wZXJtLmxvY2F0aW9uLnppcCxcblxuICAgICAgICBdLCAndGV4dCcsICd0aXRsZTMnKS5yb3RhdGUoLTkwKTtcbiAgICB9XG5cbiAgICB4ID0gcGFnZS5sZWZ0ICsgcGFkZGluZztcbiAgICB5ID0gcGFnZS50b3AgKyBwYWRkaW5nO1xuICAgIHkgKz0gc2l6ZS5kcmF3aW5nLnRpdGxlYm94ICogMS41ICogMy80O1xuXG5cblxuICAgIC8vKi9cblxuXG5cbiAgICByZXR1cm4gZC5kcmF3aW5nX3BhcnRzO1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRkX2JvcmRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cblxudmFyIG1rX2RyYXdpbmcgPSBmdW5jdGlvbihnKXtcblxuICAgIHZhciBkcmF3aW5nID0ge307XG5cblxuICAgIHZhciBsYXllcl9hdHRyID0gcmVxdWlyZSgnLi9zZXR0aW5nc19sYXllcnMnKTtcbiAgICB2YXIgZm9udHMgPSByZXF1aXJlKCcuL3NldHRpbmdzX2ZvbnRzJyk7XG5cblxuXG5cblxuXG5cbiAgICAvLyBCTE9DS1NcblxuICAgIHZhciBCbGsgPSB7XG4gICAgICAgIHR5cGU6ICdibG9jaycsXG4gICAgfTtcbiAgICBCbGsubW92ZSA9IGZ1bmN0aW9uKHgsIHkpe1xuICAgICAgICBmb3IoIHZhciBpIGluIHRoaXMuZHJhd2luZ19wYXJ0cyApe1xuICAgICAgICAgICAgdGhpcy5kcmF3aW5nX3BhcnRzW2ldLm1vdmUoeCx5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEJsay5hZGQgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiggdHlwZW9mIHRoaXMuZHJhd2luZ19wYXJ0cyA9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgICAgICB0aGlzLmRyYXdpbmdfcGFydHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoIHZhciBpIGluIGFyZ3VtZW50cyl7XG4gICAgICAgICAgICB0aGlzLmRyYXdpbmdfcGFydHMucHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQmxrLnJvdGF0ZSA9IGZ1bmN0aW9uKGRlZyl7XG4gICAgICAgIHRoaXMucm90YXRlID0gZGVnO1xuICAgIH07XG5cblxuICAgIHZhciBibG9ja19hY3RpdmUgPSBmYWxzZTtcbiAgICAvLyBDcmVhdGUgZGVmYXVsdCBsYXllcixibG9jayBjb250YWluZXIgYW5kIGZ1bmN0aW9uc1xuXG4gICAgLy8gTGF5ZXJzXG5cbiAgICB2YXIgbGF5ZXJfYWN0aXZlID0gZmFsc2U7XG5cbiAgICBkcmF3aW5nLmxheWVyID0gZnVuY3Rpb24obmFtZSl7IC8vIHNldCBjdXJyZW50IGxheWVyXG4gICAgICAgIGlmKCB0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgKXsgLy8gaWYgbm8gbGF5ZXIgbmFtZSBnaXZlbiwgcmVzZXQgdG8gZGVmYXVsdFxuICAgICAgICAgICAgbGF5ZXJfYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoICEgKG5hbWUgaW4gbGF5ZXJfYXR0cikgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yOiB1bmtub3duIGxheWVyIFwiJytuYW1lKydcIiwgdXNpbmcgYmFzZScpO1xuICAgICAgICAgICAgbGF5ZXJfYWN0aXZlID0gJ2Jhc2UnIDtcbiAgICAgICAgfSBlbHNlIHsgLy8gZmluYWx5IGFjdGl2YXRlIHJlcXVlc3RlZCBsYXllclxuICAgICAgICAgICAgbGF5ZXJfYWN0aXZlID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICAvLyovXG4gICAgfTtcblxuICAgIHZhciBzZWN0aW9uX2FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgZHJhd2luZy5zZWN0aW9uID0gZnVuY3Rpb24obmFtZSl7IC8vIHNldCBjdXJyZW50IHNlY3Rpb25cbiAgICAgICAgaWYoIHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyApeyAvLyBpZiBubyBzZWN0aW9uIG5hbWUgZ2l2ZW4sIHJlc2V0IHRvIGRlZmF1bHRcbiAgICAgICAgICAgIHNlY3Rpb25fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7IC8vIGZpbmFseSBhY3RpdmF0ZSByZXF1ZXN0ZWQgc2VjdGlvblxuICAgICAgICAgICAgc2VjdGlvbl9hY3RpdmUgPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIC8vKi9cbiAgICB9O1xuXG5cbiAgICBkcmF3aW5nLmJsb2NrX3N0YXJ0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiggdHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnICl7IC8vIGlmIG5hbWUgYXJndW1lbnQgaXMgc3VibWl0dGVkXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3I6IG5hbWUgcmVxdWlyZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBibGs7XG4gICAgICAgICAgICBibG9ja19hY3RpdmUgPSBuYW1lO1xuICAgICAgICAgICAgaWYoIGcuZHJhd2luZy5ibG9ja3NbYmxvY2tfYWN0aXZlXSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0Vycm9yOiBibG9jayBhbHJlYWR5IGV4aXN0cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxrID0gT2JqZWN0LmNyZWF0ZShCbGspO1xuICAgICAgICAgICAgZy5kcmF3aW5nLmJsb2Nrc1tibG9ja19hY3RpdmVdID0gYmxrO1xuICAgICAgICAgICAgcmV0dXJuIGJsaztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAgICAgLypcbiAgICAgICAgeCA9IGxvYy53aXJlX3RhYmxlLnggLSB3LzI7XG4gICAgICAgIHkgPSBsb2Mud2lyZV90YWJsZS55IC0gaC8yO1xuICAgICAgICBpZiggdHlwZW9mIGxheWVyX25hbWUgIT09ICd1bmRlZmluZWQnICYmIChsYXllcl9uYW1lIGluIGxheWVycykgKSB7XG4gICAgICAgICAgICB2YXIgbGF5ZXJfc2VsZWN0ZWQgPSBsYXllcnNbbGF5ZXJfbmFtZV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCAhIChsYXllcl9uYW1lIGluIGxheWVycykgKXsgY29uc29sZS5sb2coXCJlcnJvciwgbGF5ZXIgZG9lcyBub3QgZXhpc3QsIHVzaW5nIGN1cnJlbnRcIik7fVxuICAgICAgICAgICAgdmFyIGxheWVyX3NlbGVjdGVkID0gIGxheWVyX2FjdGl2ZVxuICAgICAgICB9XG4gICAgICAgICovXG4gICAgZHJhd2luZy5ibG9ja19lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJsayA9IGcuZHJhd2luZy5ibG9ja3NbYmxvY2tfYWN0aXZlXTtcbiAgICAgICAgYmxvY2tfYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBibGs7XG4gICAgfTtcblxuXG5cblxuXG5cbiAgICAvLy8vLy9cbiAgICAvLyBidWlsZCBwcm90b3R5cGUgZWxlbWVudFxuXG4gICAgICAgIC8qXG4gICAgICAgIGlmKCB0eXBlb2YgbGF5ZXJfbmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgKGxheWVyX25hbWUgaW4gbGF5ZXJzKSApIHtcbiAgICAgICAgICAgIHZhciBsYXllcl9zZWxlY3RlZCA9IGxheWVyc1tsYXllcl9uYW1lXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoICEgKGxheWVyX25hbWUgaW4gbGF5ZXJzKSApeyBjb25zb2xlLmxvZyhcImVycm9yLCBsYXllciBkb2VzIG5vdCBleGlzdCwgdXNpbmcgY3VycmVudFwiKTt9XG4gICAgICAgICAgICB2YXIgbGF5ZXJfc2VsZWN0ZWQgPSAgbGF5ZXJfYWN0aXZlXG4gICAgICAgIH1cbiAgICAgICAgKi9cblxuXG4gICAgdmFyIFN2Z0VsZW0gPSB7XG4gICAgICAgIG9iamVjdDogJ1N2Z0VsZW0nXG4gICAgfTtcbiAgICBTdmdFbGVtLm1vdmUgPSBmdW5jdGlvbih4LCB5KXtcbiAgICAgICAgaWYoIHR5cGVvZiB0aGlzLnBvaW50cyAhPSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgICAgIGZvciggdmFyIGkgaW4gdGhpcy5wb2ludHMgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludHNbaV1bMF0gKz0geDtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50c1tpXVsxXSArPSB5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgU3ZnRWxlbS5yb3RhdGUgPSBmdW5jdGlvbihkZWcpe1xuICAgICAgICB0aGlzLnJvdGF0ZWQgPSBkZWc7XG4gICAgfTtcblxuICAgIC8vLy8vLy9cbiAgICAvLyBmdW5jdGlvbnMgZm9yIGFkZGluZyBkcmF3aW5nX3BhcnRzXG5cbiAgICBkcmF3aW5nLmFkZCA9IGZ1bmN0aW9uKHR5cGUsIHBvaW50cywgbGF5ZXJfbmFtZSwgYXR0cnMpIHtcbiAgICAgICAgaWYoIHBvaW50c1swXSA9PT0gdW5kZWZpbmVkICkgY29uc29sZS53YXJuKFwicG9pbnRzIG5vdCBkZWZmaW5lZFwiLCB0eXBlLCBwb2ludHMsIGxheWVyX25hbWUgKTtcblxuICAgICAgICBpZiggISBsYXllcl9uYW1lICkgeyBsYXllcl9uYW1lID0gbGF5ZXJfYWN0aXZlOyB9XG4gICAgICAgIGlmKCAhIChsYXllcl9uYW1lIGluIGxheWVyX2F0dHIpICkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvcjogTGF5ZXIgXCInKyBsYXllcl9uYW1lICsnXCIgbmFtZSBub3QgZm91bmQsIHVzaW5nIGJhc2UnKTtcbiAgICAgICAgICAgIGxheWVyX25hbWUgPSAnYmFzZSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggdHlwZW9mIHBvaW50cyA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHBvaW50c19hID0gcG9pbnRzLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBmb3IoIHZhciBpIGluIHBvaW50c19hICkge1xuICAgICAgICAgICAgICAgIHBvaW50c19hW2ldID0gcG9pbnRzX2FbaV0uc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICBmb3IoIHZhciBjIGluIHBvaW50c19hW2ldICkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNfYVtpXVtjXSA9IE51bWJlcihwb2ludHNfYVtpXVtjXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuXG4gICAgICAgIHZhciBlbGVtID0gT2JqZWN0LmNyZWF0ZShTdmdFbGVtKTtcbiAgICAgICAgZWxlbS50eXBlID0gdHlwZTtcbiAgICAgICAgZWxlbS5sYXllcl9uYW1lID0gbGF5ZXJfbmFtZTtcbiAgICAgICAgZWxlbS5zZWN0aW9uX25hbWUgPSBzZWN0aW9uX2FjdGl2ZTtcbiAgICAgICAgaWYoIGF0dHJzICE9PSB1bmRlZmluZWQgKSBlbGVtLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIGlmKCB0eXBlID09PSAnbGluZScgKSB7XG4gICAgICAgICAgICBlbGVtLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgfSBlbHNlIGlmKCB0eXBlID09PSAncG9seScgKSB7XG4gICAgICAgICAgICBlbGVtLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgfSBlbHNlIGlmKCB0eXBlb2YgcG9pbnRzWzBdLnggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBlbGVtLnggPSBwb2ludHNbMF1bMF07XG4gICAgICAgICAgICBlbGVtLnkgPSBwb2ludHNbMF1bMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtLnggPSBwb2ludHNbMF0ueDtcbiAgICAgICAgICAgIGVsZW0ueSA9IHBvaW50c1swXS55O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoYmxvY2tfYWN0aXZlKSB7XG4gICAgICAgICAgICBlbGVtLmJsb2NrX25hbWUgPSBibG9ja19hY3RpdmU7XG4gICAgICAgICAgICBnLmRyYXdpbmcuYmxvY2tzW2Jsb2NrX2FjdGl2ZV0uYWRkKGVsZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmF3aW5nX3BhcnRzLnB1c2goZWxlbSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIFRlbXAuIE5hTiBjaGVja1xuICAgICAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbihwb2ludCl7XG4gICAgICAgICAgICBpZiggcG9pbnQuY29uc3RydWN0b3IgPT09IEFycmF5ICl7XG4gICAgICAgICAgICAgICAgcG9pbnQuZm9yRWFjaChmdW5jdGlvbihudW0pe1xuICAgICAgICAgICAgICAgICAgICBpZiggaXNOYU4obnVtKSApe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coICdOYU4gYWxlcnQ6JywgZWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYoIGlzTmFOKHBvaW50LngpIHx8IGlzTmFOKHBvaW50LnkpICl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCAnTmFOIGFsZXJ0OicsIGVsZW0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZWxlbTtcbiAgICB9O1xuXG4gICAgZHJhd2luZy5saW5lID0gZnVuY3Rpb24ocG9pbnRzLCBsYXllciwgYXR0cnMpeyAvLyAocG9pbnRzLCBbbGF5ZXJdKVxuICAgICAgICAvL3JldHVybiBhZGQoJ2xpbmUnLCBwb2ludHMsIGxheWVyKVxuICAgICAgICB2YXIgbGluZSA9ICB0aGlzLmFkZCgnbGluZScsIHBvaW50cywgbGF5ZXIsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcblxuICAgIGRyYXdpbmcucG9seSA9IGZ1bmN0aW9uKHBvaW50cywgbGF5ZXIsIGF0dHJzKXsgLy8gKHBvaW50cywgW2xheWVyXSlcbiAgICAgICAgLy9yZXR1cm4gYWRkKCdwb2x5JywgcG9pbnRzLCBsYXllcilcbiAgICAgICAgdmFyIHBvbHkgPSAgdGhpcy5hZGQoJ3BvbHknLCBwb2ludHMsIGxheWVyLCBhdHRycyk7XG4gICAgICAgIHJldHVybiBwb2x5O1xuICAgIH07XG5cbiAgICBkcmF3aW5nLnJlY3QgPSBmdW5jdGlvbihsb2MsIHNpemUsIGxheWVyLCBhdHRycyl7XG4gICAgICAgIHZhciByZWMgPSB0aGlzLmFkZCgncmVjdCcsIFtsb2NdLCBsYXllciwgYXR0cnMpO1xuICAgICAgICByZWMudyA9IHNpemVbMF07XG4gICAgICAgIC8qXG4gICAgICAgIGlmKCB0eXBlb2YgbGF5ZXJfbmFtZSAhPT0gJ3VuZGVmaW5lZCcgJiYgKGxheWVyX25hbWUgaW4gbGF5ZXJzKSApIHtcbiAgICAgICAgICAgIHZhciBsYXllcl9zZWxlY3RlZCA9IGxheWVyc1tsYXllcl9uYW1lXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoICEgKGxheWVyX25hbWUgaW4gbGF5ZXJzKSApeyBjb25zb2xlLmxvZyhcImVycm9yLCBsYXllciBkb2VzIG5vdCBleGlzdCwgdXNpbmcgY3VycmVudFwiKTt9XG4gICAgICAgICAgICB2YXIgbGF5ZXJfc2VsZWN0ZWQgPSAgbGF5ZXJfYWN0aXZlXG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgcmVjLmggPSBzaXplWzFdO1xuICAgICAgICByZXR1cm4gcmVjO1xuICAgIH07XG5cbiAgICBkcmF3aW5nLmNpcmMgPSBmdW5jdGlvbihsb2MsIGRpYW1ldGVyLCBsYXllciwgYXR0cnMpe1xuICAgICAgICB2YXIgY2lyID0gdGhpcy5hZGQoJ2NpcmMnLCBbbG9jXSwgbGF5ZXIsIGF0dHJzKTtcbiAgICAgICAgY2lyLmQgPSBkaWFtZXRlcjtcbiAgICAgICAgcmV0dXJuIGNpcjtcbiAgICB9O1xuXG4gICAgZHJhd2luZy50ZXh0ID0gZnVuY3Rpb24obG9jLCBzdHJpbmdzLCBsYXllciwgZm9udCwgYXR0cnMpe1xuICAgICAgICB2YXIgdHh0ID0gdGhpcy5hZGQoJ3RleHQnLCBbbG9jXSwgbGF5ZXIsIGF0dHJzKTtcbiAgICAgICAgaWYoIHR5cGVvZiBzdHJpbmdzID09ICdzdHJpbmcnKXtcbiAgICAgICAgICAgIHN0cmluZ3MgPSBbc3RyaW5nc107XG4gICAgICAgIH1cbiAgICAgICAgdHh0LnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgICAgICB0eHQuZm9udCA9IGZvbnQ7XG4gICAgICAgIHJldHVybiB0eHQ7XG4gICAgfTtcblxuICAgIGRyYXdpbmcuaW1hZ2UgPSBmdW5jdGlvbihsb2MsIHNpemUsIGhyZWYsIGxheWVyLCBhdHRycyl7XG4gICAgICAgIHZhciBpbWcgPSB0aGlzLmFkZCgnaW1hZ2UnLCBbbG9jXSwgJ2ltYWdlJywgYXR0cnMpO1xuICAgICAgICBpbWcudyA9IHNpemVbMF07XG4gICAgICAgIGltZy5oID0gc2l6ZVsxXTtcbiAgICAgICAgaW1nLmhyZWYgPSBocmVmO1xuICAgICAgICByZXR1cm4gaW1nO1xuICAgIH07XG5cbiAgICBkcmF3aW5nLmJsb2NrID0gZnVuY3Rpb24obmFtZSkgey8vIHNldCBjdXJyZW50IGJsb2NrXG4gICAgICAgIHZhciB4LHk7XG4gICAgICAgIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSAyICl7IC8vIGlmIGNvb3IgaXMgcGFzc2VkXG4gICAgICAgICAgICBpZiggdHlwZW9mIGFyZ3VtZW50c1sxXS54ICE9PSAndW5kZWZpbmVkJyApe1xuICAgICAgICAgICAgICAgIHggPSBhcmd1bWVudHNbMV0ueDtcbiAgICAgICAgICAgICAgICB5ID0gYXJndW1lbnRzWzFdLnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSBhcmd1bWVudHNbMV1bMF07XG4gICAgICAgICAgICAgICAgeSA9IGFyZ3VtZW50c1sxXVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKCBhcmd1bWVudHMubGVuZ3RoID09PSAzICl7IC8vIGlmIHgseSBpcyBwYXNzZWRcbiAgICAgICAgICAgIHggPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB5ID0gYXJndW1lbnRzWzJdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogd2hhdCBpZiBibG9jayBkb2VzIG5vdCBleGlzdD8gcHJpbnQgbGlzdCBvZiBibG9ja3M/XG4gICAgICAgIHZhciBibGsgPSBPYmplY3QuY3JlYXRlKGcuZHJhd2luZy5ibG9ja3NbbmFtZV0pO1xuICAgICAgICBibGsueCA9IHg7XG4gICAgICAgIGJsay55ID0geTtcblxuICAgICAgICBpZihibG9ja19hY3RpdmUpe1xuICAgICAgICAgICAgZy5kcmF3aW5nLmJsb2Nrc1tibG9ja19hY3RpdmVdLmFkZChibGspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kcmF3aW5nX3BhcnRzLnB1c2goYmxrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxrO1xuICAgIH07XG5cblxuXG5cblxuXG5cblxuXG5cbiAgICAvLy8vLy8vLy8vLy8vL1xuICAgIC8vIFRhYmxlc1xuXG4gICAgdmFyIENlbGwgPSB7XG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKHRhYmxlLCBSLCBDKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMudGFibGUgPSB0YWJsZTtcbiAgICAgICAgICAgIHRoaXMuUiA9IFI7XG4gICAgICAgICAgICB0aGlzLkMgPSBDO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIHRoaXMuYm9yZGVycyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5ib3JkZXJfb3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNpZGUpe1xuICAgICAgICAgICAgICAgIHNlbGYuYm9yZGVyc1tzaWRlXSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyovXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgLypcbiAgICAgICAgYm9yZGVyX29wdGlvbnM6IFsnVCcsICdCJywgJ0wnLCAnUiddLFxuICAgICAgICAvLyovXG4gICAgICAgIHRleHQ6IGZ1bmN0aW9uKHRleHQpe1xuICAgICAgICAgICAgdGhpcy5jZWxsX3RleHQgPSB0ZXh0O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgfSxcbiAgICAgICAgZm9udDogZnVuY3Rpb24oZm9udF9uYW1lKXtcbiAgICAgICAgICAgIHRoaXMuY2VsbF9mb250X25hbWUgPSBmb250X25hbWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBib3JkZXI6IGZ1bmN0aW9uKGJvcmRlcl9zdHJpbmcsIHN0YXRlKXtcbiAgICAgICAgICAgIHRoaXMudGFibGUuYm9yZGVyKCB0aGlzLlIsIHRoaXMuQywgYm9yZGVyX3N0cmluZywgc3RhdGUgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBUYWJsZSA9IHtcbiAgICAgICAgaW5pdDogZnVuY3Rpb24oIGRyYXdpbmcsIG51bV9yb3dzLCBudW1fY29scyApe1xuICAgICAgICAgICAgdGhpcy5kcmF3aW5nID0gZHJhd2luZztcbiAgICAgICAgICAgIHRoaXMubnVtX3Jvd3MgPSBudW1fcm93cztcbiAgICAgICAgICAgIHRoaXMubnVtX2NvbHMgPSBudW1fY29scztcbiAgICAgICAgICAgIHZhciByLGM7XG5cbiAgICAgICAgICAgIC8vIHNldHVwIGJvcmRlciBjb250YWluZXJzXG4gICAgICAgICAgICB0aGlzLmJvcmRlcnNfcm93cyA9IFtdO1xuICAgICAgICAgICAgZm9yKCByPTA7IHI8PW51bV9yb3dzOyByKyspe1xuICAgICAgICAgICAgICAgIHRoaXMuYm9yZGVyc19yb3dzW3JdID0gW107XG4gICAgICAgICAgICAgICAgZm9yKCBjPTE7IGM8PW51bV9jb2xzOyBjKyspe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJvcmRlcnNfcm93c1tyXVtjXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYm9yZGVyc19jb2xzID0gW107XG4gICAgICAgICAgICBmb3IoIGM9MDsgYzw9bnVtX2NvbHM7IGMrKyl7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3JkZXJzX2NvbHNbY10gPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IoIHI9MTsgcjw9bnVtX3Jvd3M7IHIrKyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYm9yZGVyc19jb2xzW2NdW3JdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXQgY29sdW1uIGFuZCByb3cgc2l6ZSBjb250YWluZXJzXG4gICAgICAgICAgICB0aGlzLnJvd19zaXplcyA9IFtdO1xuICAgICAgICAgICAgZm9yKCByPTE7IHI8PW51bV9yb3dzOyByKyspe1xuICAgICAgICAgICAgICAgIHRoaXMucm93X3NpemVzW3JdID0gMTU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbF9zaXplcyA9IFtdO1xuICAgICAgICAgICAgZm9yKCBjPTE7IGM8PW51bV9jb2xzOyBjKyspe1xuICAgICAgICAgICAgICAgIHRoaXMuY29sX3NpemVzW2NdID0gNjA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldHVwIGNlbGwgY29udGFpbmVyXG4gICAgICAgICAgICB0aGlzLmNlbGxzID0gW107XG4gICAgICAgICAgICBmb3IoIHI9MTsgcjw9bnVtX3Jvd3M7IHIrKyl7XG4gICAgICAgICAgICAgICAgdGhpcy5jZWxsc1tyXSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciggYz0xOyBjPD1udW1fY29sczsgYysrKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxsc1tyXVtjXSA9IE9iamVjdC5jcmVhdGUoQ2VsbCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2VsbHNbcl1bY10uaW5pdCggdGhpcywgciwgYyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyovXG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBsb2M6IGZ1bmN0aW9uKCB4LCB5KXtcbiAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGNlbGw6IGZ1bmN0aW9uKCBSLCBDICl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsc1tSXVtDXTtcbiAgICAgICAgfSxcbiAgICAgICAgYWxsX2NlbGxzOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgdmFyIGNlbGxfYXJyYXkgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2VsbHMuZm9yRWFjaChmdW5jdGlvbihyb3cpe1xuICAgICAgICAgICAgICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwpe1xuICAgICAgICAgICAgICAgICAgICBjZWxsX2FycmF5LnB1c2goY2VsbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjZWxsX2FycmF5O1xuICAgICAgICB9LFxuICAgICAgICBjb2xfc2l6ZTogZnVuY3Rpb24oY29sLCBzaXplKXtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgY29sID09PSAnc3RyaW5nJyApe1xuICAgICAgICAgICAgICAgIGlmKCBjb2wgPT09ICdhbGwnKXtcbiAgICAgICAgICAgICAgICAgICAgXy5yYW5nZSh0aGlzLm51bV9jb2xzKS5mb3JFYWNoKGZ1bmN0aW9uKGMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xfc2l6ZXNbYysxXSA9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgIH0sdGhpcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IE51bWJlcihzaXplKTtcbiAgICAgICAgICAgICAgICAgICAgaWYoIGlzTmFOKHNpemUpICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3I6IGNvbHVtbiB3cm9uZycpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xfc2l6ZXNbY29sXSA9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBpcyBudW1iZXJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbF9zaXplc1tjb2xdID0gc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICAvLyovXG4gICAgICAgIHJvd19zaXplOiBmdW5jdGlvbihyb3csIHNpemUpe1xuICAgICAgICAgICAgaWYoIHR5cGVvZiByb3cgPT09ICdzdHJpbmcnICl7XG4gICAgICAgICAgICAgICAgaWYoIHJvdyA9PT0gJ2FsbCcpe1xuICAgICAgICAgICAgICAgICAgICBfLnJhbmdlKHRoaXMubnVtX3Jvd3MpLmZvckVhY2goZnVuY3Rpb24ocil7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd19zaXplc1tyKzFdID0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfSx0aGlzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaXplID0gTnVtYmVyKHNpemUpO1xuICAgICAgICAgICAgICAgICAgICBpZiggaXNOYU4oc2l6ZSkgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvcjogY29sdW1uIHdyb25nJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd19zaXplc1tyb3ddID0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGlzIG51bWJlclxuICAgICAgICAgICAgICAgIHRoaXMucm93X3NpemVzW3Jvd10gPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vKi9cblxuICAgICAgICAvKlxuICAgICAgICBhZGRfY2VsbDogZnVuY3Rpb24oKXtcblxuICAgICAgICB9LFxuICAgICAgICBhZGRfcm93czogZnVuY3Rpb24obil7XG4gICAgICAgICAgICB0aGlzLm51bV9jb2xtbnMgKz0gbjtcbiAgICAgICAgICAgIHRoaXMubnVtX3Jvd3MgKz0gbjtcbiAgICAgICAgICAgIF8ucmFuZ2UobikuZm9yRWFjaChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHRoaXMucm93cy5wdXNoKFtdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXy5yYW5nZShuKS5mb3JFYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0X3Jvd3MucHVzaChbXSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuICAgICAgICB0ZXh0OiBmdW5jdGlvbiggUiwgQywgdGV4dCl7XG4gICAgICAgICAgICB0aGlzLnRleHRfcm93c1tSXVtDXSA9IHRleHQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8vKi9cbiAgICAgICAgYm9yZGVyOiBmdW5jdGlvbiggUiwgQywgYm9yZGVyX3N0cmluZywgc3RhdGUpe1xuICAgICAgICAgICAgaWYoIHN0YXRlID09PSB1bmRlZmluZWQgKSBzdGF0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGJvcmRlcl9zdHJpbmcgPSBib3JkZXJfc3RyaW5nLnRvVXBwZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICAgICAgdmFyIGJvcmRlcnM7XG4gICAgICAgICAgICBpZiggYm9yZGVyX3N0cmluZyA9PT0gJ0FMTCcgKXtcbiAgICAgICAgICAgICAgICBib3JkZXJzID0gWydUJywgJ0InLCAnTCcsICdSJ107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvcmRlcnMgPSBib3JkZXJfc3RyaW5nLnNwbGl0KC9bXFxzLF0rLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib3JkZXJzLmZvckVhY2goZnVuY3Rpb24oc2lkZSl7XG4gICAgICAgICAgICAgICAgc3dpdGNoKHNpZGUpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdUJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm9yZGVyc19yb3dzW1ItMV1bQ10gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdCJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYm9yZGVyc19yb3dzW1JdW0NdID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvcmRlcnNfY29sc1tDLTFdW1JdID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUic6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvcmRlcnNfY29sc1tDXVtSXSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY29ybmVyOiBmdW5jdGlvbihSLEMpe1xuICAgICAgICAgICAgdmFyIHggPSB0aGlzLng7XG4gICAgICAgICAgICB2YXIgeSA9IHRoaXMueTtcbiAgICAgICAgICAgIHZhciByLGM7XG4gICAgICAgICAgICBmb3IoIHI9MTsgcjw9UjsgcisrICl7XG4gICAgICAgICAgICAgICAgeSArPSB0aGlzLnJvd19zaXplc1tyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciggYz0xOyBjPD1DOyBjKysgKXtcbiAgICAgICAgICAgICAgICB4ICs9IHRoaXMuY29sX3NpemVzW2NdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt4LHldO1xuICAgICAgICB9LFxuICAgICAgICBjZW50ZXI6IGZ1bmN0aW9uKFIsQyl7XG4gICAgICAgICAgICB2YXIgeCA9IHRoaXMueDtcbiAgICAgICAgICAgIHZhciB5ID0gdGhpcy55O1xuICAgICAgICAgICAgdmFyIHIsYztcbiAgICAgICAgICAgIGZvciggcj0xOyByPD1SOyByKysgKXtcbiAgICAgICAgICAgICAgICB5ICs9IHRoaXMucm93X3NpemVzW3JdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKCBjPTE7IGM8PUM7IGMrKyApe1xuICAgICAgICAgICAgICAgIHggKz0gdGhpcy5jb2xfc2l6ZXNbY107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5IC09IHRoaXMucm93X3NpemVzW1JdLzI7XG4gICAgICAgICAgICB4IC09IHRoaXMuY29sX3NpemVzW0NdLzI7XG4gICAgICAgICAgICByZXR1cm4gW3gseV07XG4gICAgICAgIH0sXG4gICAgICAgIGxlZnQ6IGZ1bmN0aW9uKFIsQyl7XG4gICAgICAgICAgICB2YXIgY29vciA9IHRoaXMuY2VudGVyKFIsQyk7XG4gICAgICAgICAgICBjb29yWzBdID0gY29vclswXSAtIHRoaXMuY29sX3NpemVzW0NdLzIgKyB0aGlzLnJvd19zaXplc1tSXS8yO1xuICAgICAgICAgICAgcmV0dXJuIGNvb3I7XG4gICAgICAgIH0sXG4gICAgICAgIHJpZ2h0OiBmdW5jdGlvbihSLEMpe1xuICAgICAgICAgICAgdmFyIGNvb3IgPSB0aGlzLmNlbnRlcihSLEMpO1xuICAgICAgICAgICAgY29vclswXSA9IGNvb3JbMF0gKyB0aGlzLmNvbF9zaXplc1tDXS8yIC0gdGhpcy5yb3dfc2l6ZXNbUl0vMjtcbiAgICAgICAgICAgIHJldHVybiBjb29yO1xuICAgICAgICB9LFxuICAgICAgICBtazogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciByLGM7XG4gICAgICAgICAgICBmb3IoIHI9MDsgcjw9dGhpcy5udW1fcm93czsgcisrICl7XG4gICAgICAgICAgICAgICAgZm9yKCBjPTE7IGM8PXRoaXMubnVtX2NvbHM7IGMrKyApe1xuICAgICAgICAgICAgICAgICAgICBpZiggdGhpcy5ib3JkZXJzX3Jvd3Nbcl1bY10gPT09IHRydWUgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd2luZy5saW5lKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcm5lcihyLGMtMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3JuZXIocixjKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLCAnYm9yZGVyJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciggYz0wOyBjPD10aGlzLm51bV9jb2xzOyBjKysgKXtcbiAgICAgICAgICAgICAgICBmb3IoIHI9MTsgcjw9dGhpcy5udW1fcm93czsgcisrICl7XG4gICAgICAgICAgICAgICAgICAgIGlmKCB0aGlzLmJvcmRlcnNfY29sc1tjXVtyXSA9PT0gdHJ1ZSApe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3aW5nLmxpbmUoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29ybmVyKHItMSxjKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcm5lcihyLGMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sICdib3JkZXInKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yKCByPTE7IHI8PXRoaXMubnVtX3Jvd3M7IHIrKyApe1xuICAgICAgICAgICAgICAgIGZvciggYz0xOyBjPD10aGlzLm51bV9jb2xzOyBjKysgKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoIHR5cGVvZiB0aGlzLmNlbGwocixjKS5jZWxsX3RleHQgPT09ICdzdHJpbmcnICl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbChyLGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvbnRfbmFtZSA9IGNlbGwuY2VsbF9mb250X25hbWUgfHwgJ3RhYmxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb29yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIGZvbnRzW2ZvbnRfbmFtZV1bJ3RleHQtYW5jaG9yJ10gPT09ICdjZW50ZXInKSBjb29yID0gdGhpcy5jZW50ZXIocixjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoIGZvbnRzW2ZvbnRfbmFtZV1bJ3RleHQtYW5jaG9yJ10gPT09ICdyaWdodCcpIGNvb3IgPSB0aGlzLnJpZ2h0KHIsYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKCBmb250c1tmb250X25hbWVdWyd0ZXh0LWFuY2hvciddID09PSAnbGVmdCcpIGNvb3IgPSB0aGlzLmxlZnQocixjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgY29vciA9IHRoaXMuY2VudGVyKHIsYyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd2luZy50ZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxsKHIsYykuY2VsbF90ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250X25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIGRyYXdpbmcudGFibGUgPSBmdW5jdGlvbiggbnVtX3Jvd3MsIG51bV9jb2xzICl7XG4gICAgICAgIHZhciBuZXdfdGFibGUgPSBPYmplY3QuY3JlYXRlKFRhYmxlKTtcbiAgICAgICAgbmV3X3RhYmxlLmluaXQoIHRoaXMsIG51bV9yb3dzLCBudW1fY29scyApO1xuXG4gICAgICAgIHJldHVybiBuZXdfdGFibGU7XG5cbiAgICB9O1xuXG5cbiAgICBkcmF3aW5nLmFwcGVuZCA9ICBmdW5jdGlvbihkcmF3aW5nX3BhcnRzKXtcbiAgICAgICAgdmFyIGJsayA9IE9iamVjdC5jcmVhdGUoQmxrKTtcbiAgICAgICAgYmxrLmRyYXdpbmdfcGFydHMgPSBkcmF3aW5nX3BhcnRzO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5kcmF3aW5nX3BhcnRzID0gdGhpcy5kcmF3aW5nX3BhcnRzLmNvbmNhdChkcmF3aW5nX3BhcnRzKTtcbiAgICAgICAgLy90aGlzLmRyYXdpbmdfcGFydHMgPSB0aGlzLmRyYXdpbmdfcGFydHMuY29uY2F0KGRyYXdpbmdfcGFydHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5cblxuXG4gICAgdmFyIHBhZ2UgPSBPYmplY3QuY3JlYXRlKGRyYXdpbmcpO1xuICAgIC8vY29uc29sZS5sb2cocGFnZSk7XG4gICAgcGFnZS5kcmF3aW5nX3BhcnRzID0gW107XG4gICAgcmV0dXJuIHBhZ2U7XG5cblxuXG5cbn07XG5cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IG1rX2RyYXdpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBmID0gcmVxdWlyZSgnLi9mdW5jdGlvbnMnKTtcblxuXG5cbnZhciBta19zZXR0aW5ncyA9IGZ1bmN0aW9uKCkge1xuXG5cbiAgICB2YXIgaTtcbiAgICAvL3ZhciBzZXR0aW5nc0NhbGN1bGF0ZWQgPSByZXF1aXJlKCcuL3NldHRpbmdzQ2FsY3VsYXRlZC5qcycpO1xuXG4gICAgLy8gTG9hZCAndXNlcicgZGVmaW5lZCBzZXR0aW5nc1xuICAgIC8vdmFyIG1rX3NldHRpbmdzID0gcmVxdWlyZSgnLi4vZGF0YS9zZXR0aW5ncy5qc29uLmpzJyk7XG4gICAgLy9mLm1rX3NldHRpbmdzID0gbWtfc2V0dGluZ3M7XG5cbiAgICB2YXIgc2V0dGluZ3MgPSB7fTtcblxuXG5cblxuICAgIHNldHRpbmdzLnRlbXAgPSB7fTtcblxuICAgIHNldHRpbmdzLnBlcm0gPSB7fTtcbiAgICBzZXR0aW5ncy5wZXJtLmdlb2NvZGUgPSB7fTtcbiAgICBzZXR0aW5ncy5wZXJtLmxvY2F0aW9uID0ge307XG4gICAgc2V0dGluZ3MucGVybS5sb2NhdGlvbi5uZXdfYWRkcmVzcyA9IGZhbHNlO1xuICAgIHNldHRpbmdzLnBlcm0ubWFwcyA9IHt9O1xuXG4gICAgc2V0dGluZ3MuY29uZmlnX29wdGlvbnMgPSB7fTtcbiAgICBzZXR0aW5ncy5jb25maWdfb3B0aW9ucy5ORUNfdGFibGVzID0gcmVxdWlyZSgnLi4vZGF0YS90YWJsZXMuanNvbicpO1xuICAgIC8vY29uc29sZS5sb2coc2V0dGluZ3MuY29uZmlnX29wdGlvbnMuTkVDX3RhYmxlcyk7XG5cbiAgICBzZXR0aW5ncy5zdGF0ZSA9IHt9O1xuICAgIHNldHRpbmdzLnN0YXRlLmRhdGFiYXNlX2xvYWRlZCA9IGZhbHNlO1xuXG4gICAgc2V0dGluZ3MuaW4gPSB7fTtcblxuICAgIHNldHRpbmdzLmluLm9wdCA9IHt9O1xuICAgIHNldHRpbmdzLmluLm9wdC5BQyA9IHt9O1xuICAgIHNldHRpbmdzLmluLm9wdC5BQy50eXBlcyA9IHt9O1xuICAgIHNldHRpbmdzLmluLm9wdC5BQy50eXBlc1tcIjEyMFZcIl0gPSBbXCJncm91bmRcIixcIm5ldXRyYWxcIixcIkwxXCJdO1xuICAgIHNldHRpbmdzLmluLm9wdC5BQy50eXBlc1tcIjI0MFZcIl0gPSBbXCJncm91bmRcIixcIm5ldXRyYWxcIixcIkwxXCIsXCJMMlwiXTtcbiAgICBzZXR0aW5ncy5pbi5vcHQuQUMudHlwZXNbXCIyMDhWXCJdID0gW1wiZ3JvdW5kXCIsXCJuZXV0cmFsXCIsXCJMMVwiLFwiTDJcIl07XG4gICAgc2V0dGluZ3MuaW4ub3B0LkFDLnR5cGVzW1wiMjc3VlwiXSA9IFtcImdyb3VuZFwiLFwibmV1dHJhbFwiLFwiTDFcIl07XG4gICAgc2V0dGluZ3MuaW4ub3B0LkFDLnR5cGVzW1wiNDgwViBXeWVcIl0gPSBbXCJncm91bmRcIixcIm5ldXRyYWxcIixcIkwxXCIsXCJMMlwiLFwiTDNcIl07XG4gICAgc2V0dGluZ3MuaW4ub3B0LkFDLnR5cGVzW1wiNDgwViBEZWx0YVwiXSA9IFtcImdyb3VuZFwiLFwiTDFcIixcIkwyXCIsXCJMM1wiXTtcblxuXG4gICAgc2V0dGluZ3MuaW5wdXRzID0ge307XG4gICAgc2V0dGluZ3MuaW5wdXRzLmxvY2F0aW9uID0ge307XG4gICAgc2V0dGluZ3MuaW5wdXRzLmxvY2F0aW9uLmNvdW50eSA9IHt9O1xuICAgIHNldHRpbmdzLmlucHV0cy5sb2NhdGlvbi5jb3VudHkudHlwZSA9ICd0ZXh0X2lucHV0JztcbiAgICBzZXR0aW5ncy5pbnB1dHMubG9jYXRpb24uYWRkcmVzcyA9IHt9O1xuICAgIHNldHRpbmdzLmlucHV0cy5sb2NhdGlvbi5hZGRyZXNzLnR5cGUgPSAndGV4dF9pbnB1dCc7XG4gICAgc2V0dGluZ3MuaW5wdXRzLmxvY2F0aW9uLmNpdHkgPSB7fTtcbiAgICBzZXR0aW5ncy5pbnB1dHMubG9jYXRpb24uY2l0eS50eXBlID0gJ3RleHRfaW5wdXQnO1xuICAgIHNldHRpbmdzLmlucHV0cy5sb2NhdGlvbi56aXAgPSB7fTtcbiAgICBzZXR0aW5ncy5pbnB1dHMubG9jYXRpb24uemlwLnR5cGUgPSAndGV4dF9pbnB1dCc7XG5cbiAgICBzZXR0aW5ncy5pbnB1dHMucm9vZiA9IHt9O1xuICAgIHNldHRpbmdzLmlucHV0cy5yb29mLndpZHRoID0ge307XG4gICAgc2V0dGluZ3MuaW5wdXRzLnJvb2Yud2lkdGgub3B0aW9ucyA9IFtdO1xuICAgIC8vZm9yKCBpPTE1OyBpPD03MDsgaSs9NSApIHNldHRpbmdzLmlucHV0cy5yb29mLndpZHRoLm9wdGlvbnMucHVzaChpKTtcbiAgICBzZXR0aW5ncy5pbnB1dHMucm9vZi53aWR0aC51bml0cyA9ICdmdC4nO1xuICAgIHNldHRpbmdzLmlucHV0cy5yb29mLndpZHRoLm5vdGUgPSAnVGhpcyB0aGUgZnVsbCBzaXplIG9mIHRoZSByb29mLCBwZXJwZW5kaWN0dWxhciB0byB0aGUgc2xvcGUuJztcbiAgICBzZXR0aW5ncy5pbnB1dHMucm9vZi53aWR0aC50eXBlID0gJ251bWJlcl9pbnB1dCc7XG4gICAgc2V0dGluZ3MuaW5wdXRzLnJvb2YubGVuZ3RoID0ge307XG4gICAgc2V0dGluZ3MuaW5wdXRzLnJvb2YubGVuZ3RoLm9wdGlvbnMgPSBbXTtcbiAgICAvL2ZvciggaT0xMDsgaTw9NjA7IGkrPTUgKSBzZXR0aW5ncy5pbnB1dHMucm9vZi5sZW5ndGgub3B0aW9ucy5wdXNoKGkpO1xuICAgIHNldHRpbmdzLmlucHV0cy5yb29mLmxlbmd0aC51bml0cyA9ICdmdC4nO1xuICAgIHNldHRpbmdzLmlucHV0cy5yb29mLmxlbmd0aC5ub3RlID0gJ1RoaXMgdGhlIGZ1bGwgbGVuZ3RoIG9mIHRoZSByb29mLCBtZWFzdXJlZCBmcm9tIGxvdyB0byBoaWdoLic7XG4gICAgc2V0dGluZ3MuaW5wdXRzLnJvb2YubGVuZ3RoLnR5cGUgPSAnbnVtYmVyX2lucHV0JztcbiAgICBzZXR0aW5ncy5pbnB1dHMucm9vZi5zbG9wZSA9IHt9O1xuICAgIHNldHRpbmdzLmlucHV0cy5yb29mLnNsb3BlLm9wdGlvbnMgPSBbJzE6MTInLCcyOjEyJywnMzoxMicsJzQ6MTInLCc1OjEyJywnNjoxMicsJzc6MTInLCc4OjEyJywnOToxMicsJzEwOjEyJywnMTE6MTInLCcxMjoxMiddO1xuICAgIHNldHRpbmdzLmlucHV0cy5yb29mLnR5cGUgPSB7fTtcbiAgICBzZXR0aW5ncy5pbnB1dHMucm9vZi50eXBlLm9wdGlvbnMgPSBbJ0dhYmxlJywnU2hlZCcsJ0hpcHBlZCddO1xuICAgIHNldHRpbmdzLmlucHV0cy5tb2R1bGUgPSB7fTtcbiAgICBzZXR0aW5ncy5pbnB1dHMubW9kdWxlLm1ha2UgPSB7fTtcbiAgICAvL3NldHRpbmdzLmlucHV0cy5tb2R1bGUubWFrZS5vcHRpb25zID0gbnVsbDtcbiAgICBzZXR0aW5ncy5pbnB1dHMubW9kdWxlLm1vZGVsID0ge307XG4gICAgLy9zZXR0aW5ncy5pbnB1dHMubW9kdWxlLm1vZGVsLm9wdGlvbnMgPSBudWxsO1xuICAgIHNldHRpbmdzLmlucHV0cy5tb2R1bGUub3JpZW50YXRpb24gPSB7fTtcbiAgICBzZXR0aW5ncy5pbnB1dHMubW9kdWxlLm9yaWVudGF0aW9uLm9wdGlvbnMgPSBbJ1BvcnRyYWl0JywnTGFuZHNjYXBlJ107XG4gICAgc2V0dGluZ3MuaW5wdXRzLmFycmF5ID0ge307XG4gICAgc2V0dGluZ3MuaW5wdXRzLmFycmF5Lm1vZHVsZXNfcGVyX3N0cmluZyA9IHt9O1xuICAgIHNldHRpbmdzLmlucHV0cy5hcnJheS5tb2R1bGVzX3Blcl9zdHJpbmcub3B0aW9ucyA9IFsxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwxNiwxNywxOCwxOSwyMF07XG4gICAgc2V0dGluZ3MuaW5wdXRzLmFycmF5Lm51bV9zdHJpbmdzID0ge307XG4gICAgc2V0dGluZ3MuaW5wdXRzLmFycmF5Lm51bV9zdHJpbmdzLm9wdGlvbnMgPSBbMSwyLDMsNCw1LDZdO1xuICAgIHNldHRpbmdzLmlucHV0cy5EQyA9IHt9O1xuICAgIHNldHRpbmdzLmlucHV0cy5EQy5ob21lX3J1bl9sZW5ndGggPSB7fTtcbiAgICAvL3NldHRpbmdzLmlucHV0cy5EQy5ob21lX3J1bl9sZW5ndGgub3B0aW9ucyA9IFsyNSw1MCw3NSwxMDAsMTI1LDE1MF07XG4gICAgc2V0dGluZ3MuaW5wdXRzLkRDLmhvbWVfcnVuX2xlbmd0aC50eXBlID0gJ251bWJlcl9pbnB1dCc7XG4gICAgc2V0dGluZ3MuaW5wdXRzLmludmVydGVyID0ge307XG4gICAgc2V0dGluZ3MuaW5wdXRzLmludmVydGVyLm1ha2UgPSB7fTtcbiAgICAvL3NldHRpbmdzLmlucHV0cy5pbnZlcnRlci5tYWtlLm9wdGlvbnMgPSBudWxsO1xuICAgIHNldHRpbmdzLmlucHV0cy5pbnZlcnRlci5tb2RlbCA9IHt9O1xuICAgIHNldHRpbmdzLmlucHV0cy5pbnZlcnRlci5sb2NhdGlvbiA9IHt9O1xuICAgIHNldHRpbmdzLmlucHV0cy5pbnZlcnRlci5sb2NhdGlvbi5vcHRpb25zID0gWydJbnNpZGUnLCAnT3V0c2lkZSddO1xuICAgIC8vc2V0dGluZ3MuaW5wdXRzLmludmVydGVyLm1vZGVsLm9wdGlvbnMgPSBudWxsO1xuICAgIHNldHRpbmdzLmlucHV0cy5BQyA9IHt9O1xuICAgIHNldHRpbmdzLmlucHV0cy5BQy5sb2FkY2VudGVyX3R5cGVzID0ge307XG4gICAgc2V0dGluZ3MuaW5wdXRzLkFDLmxvYWRjZW50ZXJfdHlwZXNbJzI0MFYnXSA9IHt9O1xuICAgIHNldHRpbmdzLmlucHV0cy5BQy5sb2FkY2VudGVyX3R5cGVzWycyNDBWJ10gPSBbJzI0MFYnLCcxMjBWJ107XG4gICAgc2V0dGluZ3MuaW5wdXRzLkFDLmxvYWRjZW50ZXJfdHlwZXNbJzIwOC8xMjBWJ10gPSB7fTtcbiAgICBzZXR0aW5ncy5pbnB1dHMuQUMubG9hZGNlbnRlcl90eXBlc1snMjA4LzEyMFYnXSA9IFsnMjA4VicsJzEyMFYnXTtcbiAgICBzZXR0aW5ncy5pbnB1dHMuQUMubG9hZGNlbnRlcl90eXBlc1snNDgwLzI3N1YnXSA9IHt9O1xuICAgIHNldHRpbmdzLmlucHV0cy5BQy5sb2FkY2VudGVyX3R5cGVzWyc0ODAvMjc3ViddID0gWyc0ODBWIFd5ZScsJzQ4MFYgRGVsdGEnLCcyNzdWJ107XG4gICAgc2V0dGluZ3MuaW5wdXRzLkFDLnR5cGUgPSB7fTtcbiAgICAvL3NldHRpbmdzLmlucHV0cy5BQy50eXBlLm9wdGlvbnMgPSBudWxsO1xuICAgIHNldHRpbmdzLmlucHV0cy5BQy5kaXN0YW5jZV90b19sb2FkY2VudGVyID0ge307XG4gICAgLy9zZXR0aW5ncy5pbnB1dHMuQUMuZGlzdGFuY2VfdG9fbG9hZGNlbnRlci5vcHRpb25zID0gWzMsNSwxMCwxNSwyMCwzMF07XG4gICAgc2V0dGluZ3MuaW5wdXRzLkFDLmRpc3RhbmNlX3RvX2xvYWRjZW50ZXIudHlwZSA9ICdudW1iZXJfaW5wdXQnO1xuXG4gICAgc2V0dGluZ3MuaW5wdXRzLmF0dGFjaG1lbnRfc3lzdGVtID0ge307XG4gICAgc2V0dGluZ3MuaW5wdXRzLmF0dGFjaG1lbnRfc3lzdGVtLm1ha2UgPSB7XG4gICAgICAgIG9wdGlvbnM6IFsnVU5JUkFDJ10sXG4gICAgICAgIHR5cGU6ICdzZWxlY3QnLFxuICAgIH07XG4gICAgc2V0dGluZ3MuaW5wdXRzLmF0dGFjaG1lbnRfc3lzdGVtLm1vZGVsID0ge1xuICAgICAgICBvcHRpb25zOiBbJ1NPTEFSTU9VTlQnXSxcbiAgICAgICAgdHlwZTogJ3NlbGVjdCcsXG4gICAgfTtcblxuXG5cbiAgICBzZXR0aW5ncy51c2VyX2lucHV0ID0gZi5hZGRfc2VjdGlvbnMoc2V0dGluZ3MuaW5wdXRzKTtcbmNvbnNvbGUubG9nKHNldHRpbmdzLnVzZXJfaW5wdXQpO1xuXG5cblxuICAgIC8vc2V0dGluZ3MuaW5wdXRzID0gc2V0dGluZ3MuaW5wdXRzOyAvLyBjb3B5IGlucHV0IHJlZmVyZW5jZSB3aXRoIG9wdGlvbnMgdG8gaW5wdXRzXG4gICAgLy9zZXR0aW5ncy5pbnB1dHMgPSBmLmJsYW5rX2NvcHkoc2V0dGluZ3MuaW5wdXRzKTsgLy8gbWFrZSBpbnB1dCBzZWN0aW9uIGJsYW5rXG4gICAgLy9zZXR0aW5ncy5zeXN0ZW1fZm9ybXVsYXMgPSBzZXR0aW5ncy5zeXN0ZW07IC8vIGNvcHkgc3lzdGVtIHJlZmVyZW5jZSB0byBzeXN0ZW1fZm9ybXVsYXNcbiAgICBzZXR0aW5ncy5zeXN0ZW0gPSBmLmJsYW5rX2NvcHkoc2V0dGluZ3MuaW5wdXRzKTsgLy8gbWFrZSBzeXN0ZW0gc2VjdGlvbiBibGFua1xuICAgIC8vZi5tZXJnZV9vYmplY3RzKCBzZXR0aW5ncy5pbnB1dHMsIHNldHRpbmdzLnN5c3RlbSApO1xuXG5cbiAgICAvLyBsb2FkIGxheWVyc1xuXG4gICAgc2V0dGluZ3MuZHJhd2luZyA9IHt9O1xuXG4gICAgc2V0dGluZ3MuZHJhd2luZ19zZXR0aW5ncyA9IHt9O1xuICAgIHNldHRpbmdzLmRyYXdpbmdfc2V0dGluZ3MubGF5ZXJfYXR0ciA9IHJlcXVpcmUoJy4vc2V0dGluZ3NfbGF5ZXJzJyk7XG4gICAgc2V0dGluZ3MuZHJhd2luZ19zZXR0aW5ncy5mb250cyA9IHJlcXVpcmUoJy4vc2V0dGluZ3NfZm9udHMnKTtcblxuICAgIHNldHRpbmdzLmRyYXdpbmcuYmxvY2tzID0ge307XG5cbiAgICAvLyBMb2FkIGRyYXdpbmcgc3BlY2lmaWMgc2V0dGluZ3NcbiAgICAvLyBUT0RPIEZpeCBzZXR0aW5nc19kcmF3aW5nIHdpdGggbmV3IHZhcmlhYmxlIGxvY2F0aW9uc1xuICAgIHZhciBzZXR0aW5nc19kcmF3aW5nID0gcmVxdWlyZSgnLi9zZXR0aW5nc19kcmF3aW5nJyk7XG4gICAgc2V0dGluZ3MgPSBzZXR0aW5nc19kcmF3aW5nKHNldHRpbmdzKTtcblxuICAgIC8vc2V0dGluZ3Muc3RhdGVfYXBwLnZlcnNpb25fc3RyaW5nID0gdmVyc2lvbl9zdHJpbmc7XG5cbiAgICAvL3NldHRpbmdzID0gZi5udWxsVG9PYmplY3Qoc2V0dGluZ3MpO1xuXG4gICAgc2V0dGluZ3Muc2VsZWN0X3JlZ2lzdHJ5ID0gW107XG4gICAgLy9zZXR0aW5ncy52YWx1ZV9yZWdpc3RyeSA9IFtdO1xuXG5cbiAgICAvL3ZhciBjb25maWdfb3B0aW9ucyA9IHNldHRpbmdzLmNvbmZpZ19vcHRpb25zID0gc2V0dGluZ3MuY29uZmlnX29wdGlvbnMgfHwge307XG5cbiAgICBzZXR0aW5ncy53ZWJwYWdlID0ge307XG4gICAgc2V0dGluZ3Mud2VicGFnZS5zZWxlY3Rpb25zX21hbnVhbF90b2dnbGVkID0ge307XG4gICAgc2V0dGluZ3Mud2VicGFnZS5zZWN0aW9ucyA9IE9iamVjdC5rZXlzKHNldHRpbmdzLmlucHV0cyk7XG5cblxuICAgIHNldHRpbmdzLndlYnBhZ2Uuc2VjdGlvbnMuZm9yRWFjaCggZnVuY3Rpb24oc2VjdGlvbl9uYW1lKXtcbiAgICAgICAgc2V0dGluZ3Mud2VicGFnZS5zZWxlY3Rpb25zX21hbnVhbF90b2dnbGVkW3NlY3Rpb25fbmFtZV0gPSBmYWxzZTtcbiAgICB9KTtcblxuICAgIHNldHRpbmdzLndlYnBhZ2Uuc2VsZWN0ZWRfbW9kdWxlc190b3RhbCA9IDA7XG4gICAgc2V0dGluZ3Mud2VicGFnZS5zZWxlY3RlZF9tb2R1bGVzID0ge307XG5cblxuXG5cbiAgICBzZXR0aW5ncy5jb21wb25lbnRzID0ge307XG5cblxuXG5cblxuICAgIC8vIExvYWQgZnVuY3Rpb25zIGFuZCBhZGQgdGhlbSB0aGUgdGhlIGdsb2JhbCBvYmplY3RcbiAgICBmLmcgPSBzZXR0aW5ncztcbiAgICBzZXR0aW5ncy5mID0gZjtcblxuXG5cblxuICAgIC8vIExvYWQgbW9kdWxlc1xuXG4gICAgZi5zZXR1cF93ZWJwYWdlID0gcmVxdWlyZSgnLi9zZXR1cF93ZWJwYWdlJyk7XG5cbiAgICBmLnByb2Nlc3MgPSByZXF1aXJlKCcuL3Byb2Nlc3MnKTtcbiAgICBmLnNldHRpbmdzX2Rldl9kZWZhdWx0cyA9IHJlcXVpcmUoJy4vc2V0dGluZ3NfZGV2X2RlZmF1bHRzJyk7XG5cblxuICAgIGYubWtfYmxvY2tzID0gcmVxdWlyZSgnLi9ta19ibG9ja3MnKTtcblxuICAgIGYubWtfc2hlZXRfbnVtID0ge307XG4gICAgZi5ta19zaGVldF9udW1bJ0ctMDAxJ10gPSByZXF1aXJlKCcuL3BhZ2UvRy0wMDEnKTtcbiAgICBmLm1rX3NoZWV0X251bVsnUy0wMDEnXSA9IHJlcXVpcmUoJy4vcGFnZS9TLTAwMScpO1xuICAgIGYubWtfc2hlZXRfbnVtWydXLTAwMSddID0gcmVxdWlyZSgnLi9wYWdlL1ctMDAxJyk7XG4gICAgZi5ta19zaGVldF9udW1bJ1ctMDAyJ10gPSByZXF1aXJlKCcuL3BhZ2UvVy0wMDInKTtcblxuICAgIGYubWtfcHJldmlldyA9IHt9O1xuICAgIGYubWtfcHJldmlld1sncm9vZiddID0gcmVxdWlyZSgnLi9wcmV2aWV3L21rX3ByZXZpZXdfcm9vZicpO1xuICAgIGYubWtfcHJldmlld1snZWxlYyddID0gcmVxdWlyZSgnLi9wcmV2aWV3L21rX3ByZXZpZXdfZWxlYycpO1xuXG4gICAgZi5ta19zdmc9IHJlcXVpcmUoJy4vbWtfc3ZnJyk7XG5cblxuXG4gICAgc2V0dGluZ3MuZHJhd2luZ19zZXR0aW5ncy5zaGVldHMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIG51bTogJ0ctMDAxJyxcbiAgICAgICAgICAgIGRlc2M6ICdUaXRsZSBTaGVldCdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbnVtOiAnVy0wMDEnLFxuICAgICAgICAgICAgZGVzYzogJ1BWIHN5c3RlbSB3aXJpbmcgZGlhZ3JhbSdcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbnVtOiAnVy0wMDInLFxuICAgICAgICAgICAgZGVzYzogJ1BWIHN5c3RlbSBzcGVjaWZpY2F0aW9ucydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbnVtOiAnUy0wMDEnLFxuICAgICAgICAgICAgZGVzYzogJ1Jvb2YgZGV0YWlscydcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbnVtOiAnWC0wNDInLFxuICAgICAgICAgICAgZGVzYzogJ0wuVS5FLidcbiAgICAgICAgfSxcbiAgICBdO1xuXG5cblxuXG5cbiAgICByZXR1cm4gc2V0dGluZ3M7XG5cbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IG1rX3NldHRpbmdzO1xuIiwidmFyIG1rX2RyYXdpbmcgPSByZXF1aXJlKCcuL21rX2RyYXdpbmcnKTtcbnZhciBta19ib3JkZXIgPSByZXF1aXJlKCcuL21rX2JvcmRlcicpO1xuXG52YXIgcGFnZSA9IGZ1bmN0aW9uKHNldHRpbmdzLCBzaGVldF9pbmZvKXtcbiAgICBjb25zb2xlLmxvZyhcIioqIE1ha2luZyBwYWdlIFwiK3NoZWV0X2luZm8ubnVtKTtcblxuICAgIC8vdmFyIHBhZ2VfbWFrZXIgPSByZXF1aXJlKClcblxuICAgIHZhciBkID0gbWtfZHJhd2luZyhzZXR0aW5ncyk7XG5cbiAgICBkLmFwcGVuZChta19ib3JkZXIoc2V0dGluZ3MsIHNoZWV0X2luZm8gKSk7XG5cblxuXG4gICAgaWYoIHNldHRpbmdzLmYubWtfc2hlZXRfbnVtW3NoZWV0X2luZm8ubnVtXSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ1NoZWV0IGRlZmluZWQnKTtcbiAgICAgICAgZC5hcHBlbmQoIHNldHRpbmdzLmYubWtfc2hlZXRfbnVtW3NoZWV0X2luZm8ubnVtXShzZXR0aW5ncykgKTtcbiAgICAgICAgZC5hcHBlbmQoIHNldHRpbmdzLmYubWtfc2hlZXRfbnVtW3NoZWV0X2luZm8ubnVtXShzZXR0aW5ncykgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnRXJyb3I6IFNoZWV0IG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQuZHJhd2luZ19wYXJ0cztcbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhZ2U7XG4iLCIndXNlIHN0cmljdCc7XG4vL3ZhciBzZXR0aW5ncyA9IHJlcXVpcmUoJy4vc2V0dGluZ3MuanMnKTtcbi8vdmFyIHNuYXBzdmcgPSByZXF1aXJlKCdzbmFwc3ZnJyk7XG4vL2xvZyhzZXR0aW5ncyk7XG5cblxuXG52YXIgbWtfc3ZnID0gZnVuY3Rpb24oZHJhd2luZ19wYXJ0cywgZHJhd2luZ19zZXR0aW5ncyl7XG4gICAgLy9jb25zb2xlLmxvZygnZGlzcGxheWluZyBzdmcnKTtcbiAgICAvL2NvbnNvbGUubG9nKCdkcmF3aW5nX3BhcnRzOiAnLCBkcmF3aW5nX3BhcnRzKTtcbiAgICAvL2NvbnRhaW5lci5lbXB0eSgpXG4gICAgdmFyIGRyYXdpbmdfc2l6ZSA9IGRyYXdpbmdfc2V0dGluZ3Muc2l6ZS5kcmF3aW5nO1xuICAgIHZhciBsYXllcl9hdHRyID0gZHJhd2luZ19zZXR0aW5ncy5sYXllcl9hdHRyO1xuICAgIHZhciBmb250cyA9IGRyYXdpbmdfc2V0dGluZ3MuZm9udHM7XG5cbiAgICAvL3ZhciBzdmdfZG9jdW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnU3ZnanNTdmcxMDAwJylcbiAgICB2YXIgc3ZnX2RvY3VtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgJ3N2ZycpO1xuICAgIC8vc3ZnX2RvY3VtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCdzdmdfZHJhd2luZycpO1xuXG5cblxuICAgIC8vc3ZnX2RvY3VtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzZXR0aW5ncy5kcmF3aW5nX3NldHRpbmdzLnNpemUuZHJhd2luZy53KTtcbiAgICAvL3N2Z19kb2N1bWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNldHRpbmdzLmRyYXdpbmdfc2V0dGluZ3Muc2l6ZS5kcmF3aW5nLmgpO1xuICAgIHZhciB2aWV3X2JveCA9ICcwIDAgJyArIGRyYXdpbmdfc2l6ZS53ICsgJyAnICsgZHJhd2luZ19zaXplLmggKyAnICc7XG4gICAgc3ZnX2RvY3VtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIHZpZXdfYm94KTtcbiAgICBzdmdfZG9jdW1lbnQuc2V0QXR0cmlidXRlKCd4bWxucycsJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyk7XG4gICAgc3ZnX2RvY3VtZW50LnNldEF0dHJpYnV0ZSgneG1sbnM6eGxpbmsnLCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyk7XG4gICAgLy92YXIgc3ZnID0gc25hcHN2ZyhzdmdfZG9jdW1lbnQpLnNpemUoc2l6ZS5kcmF3aW5nLncsIHNpemUuZHJhd2luZy5oKTtcbiAgICAvL3ZhciBzdmcgPSBzbmFwc3ZnKCcjc3ZnX2RyYXdpbmcnKTtcblxuICAgIC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIGRyYXdpbmcgY29udGVudHMsIGNhbGwgdGhlIGZ1bmN0aW9uIGJlbG93LlxuICAgIGRyYXdpbmdfcGFydHMuZm9yRWFjaCggZnVuY3Rpb24oaXRlbSxpZCkge1xuICAgICAgICBzdmdfZG9jdW1lbnQuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICBta19zdmdfZWxlbShpdGVtKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWtfc3ZnX2VsZW0oaXRlbSl7XG4gICAgICAgIHZhciB4LHksYXR0cl9uYW1lO1xuICAgICAgICBpZiggdHlwZW9mIGl0ZW0ueCAhPT0gJ3VuZGVmaW5lZCcgKSB7IHggPSBpdGVtLng7IH1cbiAgICAgICAgaWYoIHR5cGVvZiBpdGVtLnkgIT09ICd1bmRlZmluZWQnICkgeyB5ID0gaXRlbS55OyB9XG5cbiAgICAgICAgdmFyIGF0dHJzID0gbGF5ZXJfYXR0cltpdGVtLmxheWVyX25hbWVdO1xuICAgICAgICBpZiggaXRlbS5hdHRycyAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgICAgIGZvciggYXR0cl9uYW1lIGluIGl0ZW0uYXR0cnMgKXtcbiAgICAgICAgICAgICAgICBhdHRyc1thdHRyX25hbWVdID0gaXRlbS5hdHRyc1thdHRyX25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzdmdfZWxlbTtcblxuICAgICAgICBpZiggaXRlbS50eXBlID09PSAncmVjdCcpIHtcbiAgICAgICAgICAgIC8vc3ZnLnJlY3QoIGl0ZW0udywgaXRlbS5oICkubW92ZSggeC1pdGVtLncvMiwgeS1pdGVtLmgvMiApLmF0dHIoIGxheWVyX2F0dHJbaXRlbS5sYXllcl9uYW1lXSApO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZWxlbTonLCBlbGVtICk7XG4gICAgICAgICAgICAvL2lmKCBpc05hTihpdGVtLncpICkge1xuICAgICAgICAgICAgLy8gICAgY29uc29sZS5sb2coJ2Vycm9yOiBlbGVtIG5vdCBmdWxseSBkZWZpbmVkJywgZWxlbSlcbiAgICAgICAgICAgIC8vICAgIGl0ZW0udyA9IDEwO1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICAvL2lmKCBpc05hTihpdGVtLmgpICkge1xuICAgICAgICAgICAgLy8gICAgY29uc29sZS5sb2coJ2Vycm9yOiBlbGVtIG5vdCBmdWxseSBkZWZpbmVkJywgZWxlbSlcbiAgICAgICAgICAgIC8vICAgIGl0ZW0uaCA9IDEwO1xuICAgICAgICAgICAgLy99XG4gICAgICAgICAgICBzdmdfZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsICdyZWN0Jyk7XG4gICAgICAgICAgICBzdmdfZWxlbS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgaXRlbS53KTtcbiAgICAgICAgICAgIHN2Z19lbGVtLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaXRlbS5oKTtcbiAgICAgICAgICAgIHN2Z19lbGVtLnNldEF0dHJpYnV0ZSgneCcsIHgtaXRlbS53LzIpO1xuICAgICAgICAgICAgc3ZnX2VsZW0uc2V0QXR0cmlidXRlKCd5JywgeS1pdGVtLmgvMik7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGl0ZW0ubGF5ZXJfbmFtZSk7XG4gICAgICAgICAgICBmb3IoIGF0dHJfbmFtZSBpbiBhdHRycyApe1xuICAgICAgICAgICAgICAgIHN2Z19lbGVtLnNldEF0dHJpYnV0ZShhdHRyX25hbWUsIGF0dHJzW2F0dHJfbmFtZV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiggaXRlbS50eXBlID09PSAnbGluZScpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMyID0gW107XG4gICAgICAgICAgICBpdGVtLnBvaW50cy5mb3JFYWNoKCBmdW5jdGlvbihwb2ludCl7XG4gICAgICAgICAgICAgICAgaWYoICEgaXNOYU4ocG9pbnRbMF0pICYmICEgaXNOYU4ocG9pbnRbMV0pICl7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50czIucHVzaChbIHBvaW50WzBdLCBwb2ludFsxXSBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZXJyb3I6IGVsZW0gbm90IGZ1bGx5IGRlZmluZWQnLCBpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vc3ZnLnBvbHlsaW5lKCBwb2ludHMyICkuYXR0ciggbGF5ZXJfYXR0cltpdGVtLmxheWVyX25hbWVdICk7XG5cbiAgICAgICAgICAgIHN2Z19lbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgJ3BvbHlsaW5lJyk7XG4gICAgICAgICAgICBzdmdfZWxlbS5zZXRBdHRyaWJ1dGUoICdwb2ludHMnLCBwb2ludHMyLmpvaW4oJyAnKSApO1xuICAgICAgICAgICAgZm9yKCBhdHRyX25hbWUgaW4gYXR0cnMgKXtcbiAgICAgICAgICAgICAgICBzdmdfZWxlbS5zZXRBdHRyaWJ1dGUoYXR0cl9uYW1lLCBhdHRyc1thdHRyX25hbWVdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYoIGl0ZW0udHlwZSA9PT0gJ3BvbHknKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzMiA9IFtdO1xuICAgICAgICAgICAgaXRlbS5wb2ludHMuZm9yRWFjaCggZnVuY3Rpb24ocG9pbnQpe1xuICAgICAgICAgICAgICAgIGlmKCAhIGlzTmFOKHBvaW50WzBdKSAmJiAhIGlzTmFOKHBvaW50WzFdKSApe1xuICAgICAgICAgICAgICAgICAgICBwb2ludHMyLnB1c2goWyBwb2ludFswXSwgcG9pbnRbMV0gXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yOiBlbGVtIG5vdCBmdWxseSBkZWZpbmVkJywgaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvL3N2Zy5wb2x5bGluZSggcG9pbnRzMiApLmF0dHIoIGxheWVyX2F0dHJbaXRlbS5sYXllcl9uYW1lXSApO1xuXG4gICAgICAgICAgICBzdmdfZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsICdwb2x5bGluZScpO1xuICAgICAgICAgICAgc3ZnX2VsZW0uc2V0QXR0cmlidXRlKCAncG9pbnRzJywgcG9pbnRzMi5qb2luKCcgJykgKTtcbiAgICAgICAgICAgIGZvciggYXR0cl9uYW1lIGluIGF0dHJzICl7XG4gICAgICAgICAgICAgICAgc3ZnX2VsZW0uc2V0QXR0cmlidXRlKGF0dHJfbmFtZSwgYXR0cnNbYXR0cl9uYW1lXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmKCBpdGVtLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgLy92YXIgdCA9IHN2Zy50ZXh0KCBpdGVtLnN0cmluZ3MgKS5tb3ZlKCBpdGVtLnBvaW50c1swXVswXSwgaXRlbS5wb2ludHNbMF1bMV0gKS5hdHRyKCBsYXllcl9hdHRyW2l0ZW0ubGF5ZXJfbmFtZV0gKVxuICAgICAgICAgICAgdmFyIGZvbnQ7XG4gICAgICAgICAgICBpZiggaXRlbS5mb250ICYmIGZvbnRzW2l0ZW0uZm9udF0gKXtcbiAgICAgICAgICAgICAgICBmb250ID0gZm9udHNbaXRlbS5mb250XTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihmb250c1thdHRycy5mb250XSl7XG4gICAgICAgICAgICAgICAgZm9udCA9IGZvbnRzW2F0dHJzLmZvbnRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb250ID0gZm9udHNbJ2Jhc2UnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCBmb250ID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGb250IG5vdCBmb3VuZCcsIGZvbnQsIGZvbnRzWydiYXNlJ11bJ2ZvbnQtc2l6ZSddKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdmdfZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsICd0ZXh0Jyk7XG4gICAgICAgICAgICBpZihpdGVtLnJvdGF0ZWQpe1xuICAgICAgICAgICAgICAgIC8vdC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIFwicm90YXRlKFwiICsgaXRlbS5yb3RhdGVkICsgXCIgXCIgKyB4ICsgXCIgXCIgKyB5ICsgXCIpXCIgKTtcbiAgICAgICAgICAgICAgICBzdmdfZWxlbS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIFwicm90YXRlKFwiICsgaXRlbS5yb3RhdGVkICsgXCIgXCIgKyB4ICsgXCIgXCIgKyB5ICsgXCIpXCIgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9pZiggZm9udFsndGV4dC1hbmNob3InXSA9PT0gJ21pZGRsZScgKSB5ICs9IGZvbnRbJ2ZvbnQtc2l6ZSddKjEvMztcbiAgICAgICAgICAgICAgICB5ICs9IGZvbnRbJ2ZvbnQtc2l6ZSddKjEvMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkeSA9IGZvbnRbJ2ZvbnQtc2l6ZSddKjEuNTtcbiAgICAgICAgICAgIHN2Z19lbGVtLnNldEF0dHJpYnV0ZSgneCcsIHgpO1xuICAgICAgICAgICAgLy9zdmdfZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCB5ICsgZm9udFsnZm9udC1zaXplJ10vMiApO1xuICAgICAgICAgICAgc3ZnX2VsZW0uc2V0QXR0cmlidXRlKCd5JywgeS1keSApO1xuXG4gICAgICAgICAgICBmb3IoIGF0dHJfbmFtZSBpbiBhdHRycyApe1xuICAgICAgICAgICAgICAgIGlmKCBhdHRyX25hbWUgPT09ICdzdHJva2UnICkge1xuICAgICAgICAgICAgICAgICAgICBzdmdfZWxlbS5zZXRBdHRyaWJ1dGUoICdmaWxsJywgYXR0cnNbYXR0cl9uYW1lXSApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiggYXR0cl9uYW1lID09PSAnZmlsbCcgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vc3ZnX2VsZW0uc2V0QXR0cmlidXRlKCAnc3Ryb2tlJywgJ25vbmUnICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3ZnX2VsZW0uc2V0QXR0cmlidXRlKCBhdHRyX25hbWUsIGF0dHJzW2F0dHJfbmFtZV0gKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciggYXR0cl9uYW1lIGluIGZvbnQgKXtcbiAgICAgICAgICAgICAgICBzdmdfZWxlbS5zZXRBdHRyaWJ1dGUoIGF0dHJfbmFtZSwgZm9udFthdHRyX25hbWVdICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IoIGF0dHJfbmFtZSBpbiBpdGVtLnN0cmluZ3MgKXtcbiAgICAgICAgICAgICAgICB2YXIgdHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCAndHNwYW4nKTtcbiAgICAgICAgICAgICAgICB0c3Bhbi5zZXRBdHRyaWJ1dGUoJ2R5JywgZHkgKTtcbiAgICAgICAgICAgICAgICB0c3Bhbi5zZXRBdHRyaWJ1dGUoJ3gnLCB4KTtcbiAgICAgICAgICAgICAgICB0c3Bhbi5pbm5lckhUTUwgPSBpdGVtLnN0cmluZ3NbYXR0cl9uYW1lXTtcbiAgICAgICAgICAgICAgICBzdmdfZWxlbS5hcHBlbmRDaGlsZCh0c3Bhbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmKCBpdGVtLnR5cGUgPT09ICdjaXJjJykge1xuICAgICAgICAgICAgdmFyIHN2Z19lbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgJ2VsbGlwc2UnKTtcbiAgICAgICAgICAgIHN2Z19lbGVtLnNldEF0dHJpYnV0ZSgncngnLCBpdGVtLmQvMik7XG4gICAgICAgICAgICBzdmdfZWxlbS5zZXRBdHRyaWJ1dGUoJ3J5JywgaXRlbS5kLzIpO1xuICAgICAgICAgICAgc3ZnX2VsZW0uc2V0QXR0cmlidXRlKCdjeCcsIHgpO1xuICAgICAgICAgICAgc3ZnX2VsZW0uc2V0QXR0cmlidXRlKCdjeScsIHkpO1xuICAgICAgICAgICAgZm9yKCBhdHRyX25hbWUgaW4gYXR0cnMgKXtcbiAgICAgICAgICAgICAgICBzdmdfZWxlbS5zZXRBdHRyaWJ1dGUoYXR0cl9uYW1lLCBhdHRyc1thdHRyX25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBjLmF0dHJpYnV0ZXMoIGxheWVyX2F0dHJbaXRlbS5sYXllcl9uYW1lXSApXG4gICAgICAgICAgICBjLmF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHJ4OiA1LFxuICAgICAgICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAgICAgcnk6IDUsXG4gICAgICAgICAgICAgICAgY3g6IGl0ZW0ucG9pbnRzWzBdWzBdLWl0ZW0uZC8yLFxuICAgICAgICAgICAgICAgIGN5OiBpdGVtLnBvaW50c1swXVsxXS1pdGVtLmQvMlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHZhciBjMiA9IHN2Zy5lbGxpcHNlKCBpdGVtLnIsIGl0ZW0uciApXG4gICAgICAgICAgICBjMi5tb3ZlKCBpdGVtLnBvaW50c1swXVswXS1pdGVtLmQvMiwgaXRlbS5wb2ludHNbMF1bMV0taXRlbS5kLzIgKVxuICAgICAgICAgICAgYzIuYXR0cih7cng6NSwgcnk6NX0pXG4gICAgICAgICAgICBjMi5hdHRyKCBsYXllcl9hdHRyW2l0ZW0ubGF5ZXJfbmFtZV0gKVxuICAgICAgICAgICAgLy8qL1xuICAgICAgICB9IGVsc2UgaWYoIGl0ZW0udHlwZSA9PT0gJ2ltYWdlJykge1xuXG4gICAgICAgICAgICBzdmdfZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsICdnJyk7XG4gICAgICAgICAgICB2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCAnaW1hZ2UnKTtcbiAgICAgICAgICAgIGltYWdlLnNldEF0dHJpYnV0ZSgneCcsIHgpO1xuICAgICAgICAgICAgaW1hZ2Uuc2V0QXR0cmlidXRlKCd5JywgeSk7XG4gICAgICAgICAgICBpbWFnZS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgaXRlbS53KTtcbiAgICAgICAgICAgIGltYWdlLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaXRlbS5oKTtcbiAgICAgICAgICAgIGltYWdlLnNldEF0dHJpYnV0ZSgneGxpbms6aHJlZicsIGl0ZW0uaHJlZik7XG4gICAgICAgICAgICBmb3IoIGF0dHJfbmFtZSBpbiBhdHRycyApe1xuICAgICAgICAgICAgICAgIGltYWdlLnNldEF0dHJpYnV0ZShhdHRyX25hbWUsIGF0dHJzW2F0dHJfbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9nLmFwcGVuZENoaWxkKHN2Z19lbGVtKTtcbiAgICAgICAgICAgIC8vc3ZnX2VsZW0uYXBwZW5kQ2hpbGQoZyk7XG4gICAgICAgICAgICBzdmdfZWxlbS5pbm5lckhUTUwgKz0gaW1hZ2Uub3V0ZXJIVE1MO1xuXG5cblxuXG4gICAgICAgIH0gZWxzZSBpZihpdGVtLnR5cGUgPT09ICdibG9jaycpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIGEgYmxvY2ssIHJ1biB0aGlzIGZ1bmN0aW9uIHRocm91Z2ggZWFjaCBlbGVtZW50LlxuXG4gICAgICAgICAgICBzdmdfZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsICdnJyk7XG4gICAgICAgICAgICBzdmdfZWxlbS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyt4KycsJyt5KycpJyk7XG4gICAgICAgICAgICBpdGVtLmRyYXdpbmdfcGFydHMuZm9yRWFjaCggZnVuY3Rpb24oYmxvY2tfaXRlbSxpZCl7XG4gICAgICAgICAgICAgICAgc3ZnX2VsZW0uYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICAgICAgICAgIG1rX3N2Z19lbGVtKGJsb2NrX2l0ZW0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN2Z19lbGVtO1xuXG5cbiAgICB9XG4gICAgcmV0dXJuIHN2Z19kb2N1bWVudDtcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBta19zdmc7XG4iLCJ2YXIgbWtfZHJhd2luZyA9IHJlcXVpcmUoJy4uL21rX2RyYXdpbmcnKTtcbnZhciBta19ib3JkZXIgPSByZXF1aXJlKCcuLi9ta19ib3JkZXInKTtcblxudmFyIHBhZ2UgPSBmdW5jdGlvbihzZXR0aW5ncyl7XG5cbiAgICB2YXIgZCA9IG1rX2RyYXdpbmcoc2V0dGluZ3MpO1xuXG4gICAgdmFyIHNoZWV0X3NlY3Rpb24gPSAnQSc7XG4gICAgdmFyIHNoZWV0X251bSA9ICcwMCc7XG4gICAgLy9kLmFwcGVuZChta19ib3JkZXIoc2V0dGluZ3MsIHNoZWV0X3NlY3Rpb24sIHNoZWV0X251bSApKTtcblxuICAgIHZhciBzaXplID0gc2V0dGluZ3MuZHJhd2luZ19zZXR0aW5ncy5zaXplO1xuICAgIHZhciBsb2MgPSBzZXR0aW5ncy5kcmF3aW5nX3NldHRpbmdzLmxvYztcblxuICAgIHZhciB4LCB5LCBoLCB3O1xuICAgIGQubGF5ZXIoJ3RleHQnKTtcbiAgICBkLnRleHQoXG4gICAgICAgIFtzaXplLmRyYXdpbmcudyoxLzIsIHNpemUuZHJhd2luZy5oKjEvM10sXG4gICAgICAgIFtcbiAgICAgICAgICAgICdQViBTeXN0ZW0gRGVzaWduJyxcbiAgICAgICAgXSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgJ3Byb2plY3QgdGl0bGUnXG4gICAgKTtcblxuICAgIGlmKCBzZXR0aW5ncy5mLnNlY3Rpb25fZGVmaW5lZChzZXR0aW5ncywgJ2xvY2F0aW9uJykgICl7XG4gICAgICAgIGQudGV4dChcbiAgICAgICAgICAgIFtzaXplLmRyYXdpbmcudyoxLzIsIHNpemUuZHJhd2luZy5oKjEvMyArMzBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnBlcm0ubG9jYXRpb24uYWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5wZXJtLmxvY2F0aW9uLmNpdHkgKyAnLCAnICsgc2V0dGluZ3MucGVybS5sb2NhdGlvbi5jb3VudHkgKyAnLCBGTCwgJyArIHNldHRpbmdzLnBlcm0ubG9jYXRpb24uemlwLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAncHJvamVjdCB0aXRsZSdcbiAgICAgICAgKTtcbiAgICB9XG4gICAgdmFyIG5fcm93cyA9IHNldHRpbmdzLmRyYXdpbmdfc2V0dGluZ3Muc2hlZXRzLmxlbmd0aDtcbiAgICB2YXIgbl9jb2xzID0gMjtcbiAgICB3ID0gNDAwKzgwO1xuICAgIGggPSBuX3Jvd3MqMjA7XG4gICAgeCA9IHNpemUuZHJhd2luZy5mcmFtZV9wYWRkaW5nKjY7XG4gICAgeSA9IHNpemUuZHJhd2luZy5oIC0gc2l6ZS5kcmF3aW5nLmZyYW1lX3BhZGRpbmcgLSBzaXplLmRyYXdpbmcudGl0bGVib3guYm90dG9tLmg7XG4gICAgeSArPSAtMjAgKiBuX3Jvd3M7XG4gICAgeSArPSAtNDA7IC8vIHRoZSBsYXN0IG51bWJlciBpcyB0aGUgZ2FwIHRvIHRoZSB0aXRsZSBib3hcbiAgICBkLnRleHQoIFt4K3cvMiwgeS0yMF0sICdDb250ZW50cycsIG51bGwsICd0YWJsZV9sYXJnZScgKTtcblxuICAgIHZhciB0ID0gZC50YWJsZShuX3Jvd3Msbl9jb2xzKS5sb2MoeCx5KTtcbiAgICB0LnJvd19zaXplKCdhbGwnLCAyMCkuY29sX3NpemUoMiwgNDAwKS5jb2xfc2l6ZSgxLCA4MCk7XG5cbiAgICBzZXR0aW5ncy5kcmF3aW5nX3NldHRpbmdzLnNoZWV0cy5mb3JFYWNoKGZ1bmN0aW9uKHNoZWV0LGkpe1xuICAgICAgICB0LmNlbGwoaSsxLDEpLnRleHQoc2hlZXQubnVtKTtcbiAgICAgICAgdC5jZWxsKGkrMSwyKS50ZXh0KHNoZWV0LmRlc2MpO1xuXG4gICAgfSk7XG5cblxuICAgIHQuYWxsX2NlbGxzKCkuZm9yRWFjaChmdW5jdGlvbihjZWxsKXtcbiAgICAgICAgY2VsbC5mb250KCd0YWJsZV9sYXJnZV9sZWZ0JykuYm9yZGVyKCdhbGwnKTtcbiAgICB9KTtcblxuICAgIHQubWsoKTtcblxuICAgIC8qXG4gICAgY29uc29sZS5sb2codGFibGVfcGFydHMpO1xuICAgIGQuYXBwZW5kKHRhYmxlX3BhcnRzKTtcbiAgICBkLnRleHQoW3NpemUuZHJhd2luZy53LzMsc2l6ZS5kcmF3aW5nLmgvM10sICdYJywgJ3RhYmxlJyk7XG4gICAgZC5yZWN0KFtzaXplLmRyYXdpbmcudy8zLTUsc2l6ZS5kcmF3aW5nLmgvMy01XSxbMTAsMTBdLCdib3gnKTtcblxuICAgIHQuY2VsbCgyLDIpLmJvcmRlcignYWxsJykudGV4dCgnY2VsbCAyLDInKTtcbiAgICB0LmNlbGwoMywzKS5ib3JkZXIoJ2FsbCcpLnRleHQoJ2NlbGwgMywzJyk7XG4gICAgdC5jZWxsKDQsNCkuYm9yZGVyKCdhbGwnKS50ZXh0KCdjZWxsIDQsNCcpO1xuICAgIHQuY2VsbCg1LDUpLmJvcmRlcignYWxsJykudGV4dCgnY2VsbCA1LDUnKTtcblxuXG5cbiAgICB0LmNlbGwoNCw2KS5ib3JkZXIoJ2FsbCcpLnRleHQoJ2NlbGwgNCw2Jyk7XG4gICAgdC5jZWxsKDQsNykuYm9yZGVyKCdhbGwnKS50ZXh0KCdjZWxsIDQsNycpO1xuICAgIHQuY2VsbCg1LDYpLmJvcmRlcignYWxsJykudGV4dCgnY2VsbCA1LDYnKTtcbiAgICB0LmNlbGwoNSw3KS5ib3JkZXIoJ2FsbCcpLnRleHQoJ2NlbGwgNSw3Jyk7XG5cblxuICAgIC8vKi9cblxuICAgIHJldHVybiBkLmRyYXdpbmdfcGFydHM7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBwYWdlO1xuIiwidmFyIG1rX2RyYXdpbmcgPSByZXF1aXJlKCcuLi9ta19kcmF3aW5nJyk7XG52YXIgbWtfYm9yZGVyID0gcmVxdWlyZSgnLi4vbWtfYm9yZGVyJyk7XG5cbnZhciBwYWdlID0gZnVuY3Rpb24oc2V0dGluZ3Mpe1xuICAgIHZhciBmID0gc2V0dGluZ3MuZjtcblxuICAgIGQgPSBta19kcmF3aW5nKHNldHRpbmdzKTtcblxuICAgIHZhciBzaGVldF9zZWN0aW9uID0gJ1MnO1xuICAgIHZhciBzaGVldF9udW0gPSAnMDEnO1xuICAgIC8vZC5hcHBlbmQobWtfYm9yZGVyKHNldHRpbmdzLCBzaGVldF9zZWN0aW9uLCBzaGVldF9udW0gKSk7XG5cbiAgICB2YXIgc2l6ZSA9IHNldHRpbmdzLmRyYXdpbmdfc2V0dGluZ3Muc2l6ZTtcbiAgICB2YXIgbG9jID0gc2V0dGluZ3MuZHJhd2luZ19zZXR0aW5ncy5sb2M7XG4gICAgdmFyIHN5c3RlbSA9IHNldHRpbmdzLnN5c3RlbTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbiAgICBpZiggZi5zZWN0aW9uX2RlZmluZWQoc2V0dGluZ3MsICdyb29mJykgKXtcblxuXG5cbiAgICAgICAgdmFyIHgsIHksIGgsIHcsIHNlY3Rpb25feCwgc2VjdGlvbl95LCBsZW5ndGhfcCwgc2NhbGU7XG5cbiAgICAgICAgdmFyIHNsb3BlID0gc3lzdGVtLnJvb2Yuc2xvcGUuc3BsaXQoJzonKVswXTtcbiAgICAgICAgdmFyIGFuZ2xlX3JhZCA9IE1hdGguYXRhbiggTnVtYmVyKHNsb3BlKSAvMTIgKTtcbiAgICAgICAgLy9hbmdsZV9yYWQgPSBhbmdsZSAqIChNYXRoLlBJLzE4MCk7XG5cblxuICAgICAgICBsZW5ndGhfcCA9IHN5c3RlbS5yb29mLmxlbmd0aCAqIE1hdGguY29zKGFuZ2xlX3JhZCk7XG4gICAgICAgIHN5c3RlbS5yb29mLmhlaWdodCA9IHN5c3RlbS5yb29mLmxlbmd0aCAqIE1hdGguc2luKGFuZ2xlX3JhZCk7XG5cbiAgICAgICAgdmFyIHJvb2ZfcmF0aW8gPSBzeXN0ZW0ucm9vZi5sZW5ndGggLyBzeXN0ZW0ucm9vZi53aWR0aDtcbiAgICAgICAgdmFyIHJvb2ZfcGxhbl9yYXRpbyA9IGxlbmd0aF9wIC8gc3lzdGVtLnJvb2Yud2lkdGg7XG5cblxuICAgICAgICBpZiggc3lzdGVtLnJvb2YudHlwZSA9PT0gXCJHYWJsZVwiKXtcblxuXG4gICAgICAgICAgICAvLy8vLy8vXG4gICAgICAgICAgICAvLyBSb29kIHBsYW4gdmlld1xuICAgICAgICAgICAgdmFyIHBsYW5feCA9IDYwO1xuICAgICAgICAgICAgdmFyIHBsYW5feSA9IDYwO1xuXG4gICAgICAgICAgICB2YXIgcGxhbl93LCBwbGFuX2g7XG4gICAgICAgICAgICBpZiggbGVuZ3RoX3AqMiA+IHN5c3RlbS5yb29mLndpZHRoICl7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSAyMDAvKGxlbmd0aF9wKjIpO1xuICAgICAgICAgICAgICAgIHBsYW5fdyA9IChsZW5ndGhfcCoyKSAqIHNjYWxlO1xuICAgICAgICAgICAgICAgIHBsYW5faCA9IHBsYW5fdyAvIChsZW5ndGhfcCoyIC8gc3lzdGVtLnJvb2Yud2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9IDMwMC8oc3lzdGVtLnJvb2Yud2lkdGgpO1xuICAgICAgICAgICAgICAgIHBsYW5faCA9IHN5c3RlbS5yb29mLndpZHRoICogc2NhbGU7XG4gICAgICAgICAgICAgICAgcGxhbl93ID0gcGxhbl9oICogKGxlbmd0aF9wKjIgLyBzeXN0ZW0ucm9vZi53aWR0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGQucmVjdChcbiAgICAgICAgICAgICAgICBbcGxhbl94K3BsYW5fdy8yLCBwbGFuX3krcGxhbl9oLzJdLFxuICAgICAgICAgICAgICAgIFtwbGFuX3csIHBsYW5faF0sXG4gICAgICAgICAgICAgICAgXCJwcmV2aWV3X3N0cnVjdHVyYWxcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZC5wb2x5KFtcbiAgICAgICAgICAgICAgICAgICAgW3BsYW5feCAgICAgICAsIHBsYW5feV0sXG4gICAgICAgICAgICAgICAgICAgIFtwbGFuX3grcGxhbl93LzIsIHBsYW5feV0sXG4gICAgICAgICAgICAgICAgICAgIFtwbGFuX3grcGxhbl93LzIsIHBsYW5feStwbGFuX2hdLFxuICAgICAgICAgICAgICAgICAgICBbcGxhbl94LCAgICAgICAgcGxhbl95K3BsYW5faF0sXG4gICAgICAgICAgICAgICAgICAgIFtwbGFuX3ggICAgICAgLCBwbGFuX3ldLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJwcmV2aWV3X3N0cnVjdHVyYWxfcG9seV91bnNlbGVjdGVkXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkLnBvbHkoW1xuICAgICAgICAgICAgICAgICAgICBbcGxhbl94K3BsYW5fdy8yICAgICAgICwgcGxhbl95XSxcbiAgICAgICAgICAgICAgICAgICAgW3BsYW5feCtwbGFuX3cvMitwbGFuX3cvMiwgcGxhbl95XSxcbiAgICAgICAgICAgICAgICAgICAgW3BsYW5feCtwbGFuX3cvMitwbGFuX3cvMiwgcGxhbl95K3BsYW5faF0sXG4gICAgICAgICAgICAgICAgICAgIFtwbGFuX3grcGxhbl93LzIsICAgICAgICBwbGFuX3krcGxhbl9oXSxcbiAgICAgICAgICAgICAgICAgICAgW3BsYW5feCtwbGFuX3cvMiAgICAgICAsIHBsYW5feV0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcInByZXZpZXdfc3RydWN0dXJhbF9wb2x5X3NlbGVjdGVkXCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGQubGluZShbXG4gICAgICAgICAgICAgICAgICAgIFtwbGFuX3grcGxhbl93LzIsIHBsYW5feV0sXG4gICAgICAgICAgICAgICAgICAgIFtwbGFuX3grcGxhbl93LzIsIHBsYW5feStwbGFuX2hdXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcInByZXZpZXdfc3RydWN0dXJhbF9kb3RcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGQudGV4dChcbiAgICAgICAgICAgICAgICBbcGxhbl94LTIwLCBwbGFuX3krcGxhbl9oLzJdLFxuICAgICAgICAgICAgICAgIHN5c3RlbS5yb29mLmxlbmd0aC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICdkaW1lbnRpb24nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgZC50ZXh0KFxuICAgICAgICAgICAgICAgIFtwbGFuX3grcGxhbl93KzIwLCBwbGFuX3krcGxhbl9oLzJdLFxuICAgICAgICAgICAgICAgIHN5c3RlbS5yb29mLndpZHRoLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgJ2RpbWVudGlvbicsXG4gICAgICAgICAgICAgICAgJ2RpbWVudGlvbidcbiAgICAgICAgICAgICk7XG5cblxuICAgICAgICAgICAgeCA9IHBsYW5feCArIDEyMDtcbiAgICAgICAgICAgIHkgPSBwbGFuX3kgLSAyMDtcblxuICAgICAgICAgICAgZC5ibG9jaygnbm9ydGggYXJyb3dfbGVmdCcsIFt4LHldKTtcblxuXG4gICAgICAgICAgICAvLy8vLy8vL1xuICAgICAgICAgICAgLy8gcm9vZiBjcm9zc2VjdGlvblxuXG4gICAgICAgICAgICB2YXIgY3NfeCA9IHBsYW5feDtcbiAgICAgICAgICAgIHZhciBjc195ID0gcGxhbl95ICsgcGxhbl9oICsgNTA7XG4gICAgICAgICAgICB2YXIgY3NfaCA9IHN5c3RlbS5yb29mLmhlaWdodCAqIHNjYWxlO1xuICAgICAgICAgICAgdmFyIGNzX3cgPSBwbGFuX3cvMjtcblxuICAgICAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgICAgICAgICAgW2NzX3grY3NfdywgICBjc195XSxcbiAgICAgICAgICAgICAgICAgICAgW2NzX3grY3NfdywgICBjc195K2NzX2hdLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJwcmV2aWV3X3N0cnVjdHVyYWxfZG90XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgICAgICAgICBbY3NfeCtjc193LCAgIGNzX3ldLFxuICAgICAgICAgICAgICAgICAgICBbY3NfeCtjc193KjIsIGNzX3krY3NfaF0sXG4gICAgICAgICAgICAgICAgICAgIFtjc194LCAgICAgICAgY3NfeStjc19oXSxcbiAgICAgICAgICAgICAgICAgICAgW2NzX3grY3NfdywgICBjc195XSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwicHJldmlld19zdHJ1Y3R1cmFsXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkLnRleHQoXG4gICAgICAgICAgICAgICAgW2NzX3grY3Nfdy0xNSwgY3NfeStjc19oKjIvM10sXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdCggc3lzdGVtLnJvb2YuaGVpZ2h0ICkudG9GaXhlZCgpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgJ2RpbWVudGlvbicsXG4gICAgICAgICAgICAgICAgJ2RpbWVudGlvbidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkLnRleHQoXG4gICAgICAgICAgICAgICAgW2NzX3grY3NfdyoxLjUrMjAsIGNzX3krY3NfaC8zXSxcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KCBzeXN0ZW0ucm9vZi5sZW5ndGggKS50b0ZpeGVkKCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAnZGltZW50aW9uJyxcbiAgICAgICAgICAgICAgICAnZGltZW50aW9uJ1xuICAgICAgICAgICAgKTtcblxuXG5cbiAgICAgICAgICAgIC8vLy8vL1xuICAgICAgICAgICAgLy8gcm9vZiBkZXRhaWxcblxuICAgICAgICAgICAgdmFyIGRldGFpbF94ID0gMzArNDAwO1xuICAgICAgICAgICAgdmFyIGRldGFpbF95ID0gMzA7XG5cbiAgICAgICAgICAgIGlmKCBOdW1iZXIoc3lzdGVtLnJvb2Yud2lkdGgpID49IE51bWJlcihzeXN0ZW0ucm9vZi5sZW5ndGgpICl7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSAzNTAvKHN5c3RlbS5yb29mLndpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSAzNTAvKHN5c3RlbS5yb29mLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGV0YWlsX3cgPSBzeXN0ZW0ucm9vZi53aWR0aCAqIHNjYWxlO1xuICAgICAgICAgICAgdmFyIGRldGFpbF9oID0gc3lzdGVtLnJvb2YubGVuZ3RoICogc2NhbGU7XG5cbiAgICAgICAgICAgIGQucmVjdChcbiAgICAgICAgICAgICAgICBbZGV0YWlsX3grZGV0YWlsX3cvMiwgZGV0YWlsX3krZGV0YWlsX2gvMl0sXG4gICAgICAgICAgICAgICAgW2RldGFpbF93LCBkZXRhaWxfaF0sXG4gICAgICAgICAgICAgICAgXCJwcmV2aWV3X3N0cnVjdHVyYWxfcG9seV9zZWxlY3RlZF9mcmFtZWRcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgdmFyIGEgPSAzO1xuICAgICAgICAgICAgdmFyIG9mZnNldF9hID0gYSAqIHNjYWxlO1xuXG4gICAgICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgICAgICAgICBbZGV0YWlsX3gsICAgZGV0YWlsX3krb2Zmc2V0X2FdLFxuICAgICAgICAgICAgICAgICAgICBbZGV0YWlsX3grZGV0YWlsX3csICAgZGV0YWlsX3krb2Zmc2V0X2FdLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJwcmV2aWV3X3N0cnVjdHVyYWxfZG90XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgICAgICAgICBbZGV0YWlsX3gsICAgICAgICAgIGRldGFpbF95K2RldGFpbF9oLW9mZnNldF9hXSxcbiAgICAgICAgICAgICAgICAgICAgW2RldGFpbF94K2RldGFpbF93LCBkZXRhaWxfeStkZXRhaWxfaC1vZmZzZXRfYV0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcInByZXZpZXdfc3RydWN0dXJhbF9kb3RcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGQubGluZShbXG4gICAgICAgICAgICAgICAgICAgIFtkZXRhaWxfeCtvZmZzZXRfYSwgZGV0YWlsX3ldLFxuICAgICAgICAgICAgICAgICAgICBbZGV0YWlsX3grb2Zmc2V0X2EsIGRldGFpbF95K2RldGFpbF9oXSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwicHJldmlld19zdHJ1Y3R1cmFsX2RvdFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgICAgICAgICAgW2RldGFpbF94K2RldGFpbF93LW9mZnNldF9hLCBkZXRhaWxfeV0sXG4gICAgICAgICAgICAgICAgICAgIFtkZXRhaWxfeCtkZXRhaWxfdy1vZmZzZXRfYSwgZGV0YWlsX3krZGV0YWlsX2hdLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJwcmV2aWV3X3N0cnVjdHVyYWxfZG90XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGQudGV4dChcbiAgICAgICAgICAgICAgICBbZGV0YWlsX3gtNDAsIGRldGFpbF95K2RldGFpbF9oLzJdLFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoIHN5c3RlbS5yb29mLmxlbmd0aCApLnRvRml4ZWQoKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICdkaW1lbnRpb24nLFxuICAgICAgICAgICAgICAgICdkaW1lbnRpb24nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZC50ZXh0KFxuICAgICAgICAgICAgICAgIFtkZXRhaWxfeCtkZXRhaWxfdy8yLCBkZXRhaWxfeStkZXRhaWxfaCs0MF0sXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdCggc3lzdGVtLnJvb2Yud2lkdGggKS50b0ZpeGVkKCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAnZGltZW50aW9uJyxcbiAgICAgICAgICAgICAgICAnZGltZW50aW9uJ1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZC50ZXh0KFxuICAgICAgICAgICAgICAgIFtkZXRhaWxfeCsgKG9mZnNldF9hKS8yLCBkZXRhaWxfeStkZXRhaWxfaCsxNV0sXG4gICAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICAgICdkaW1lbnRpb24nLFxuICAgICAgICAgICAgICAgICdkaW1lbnRpb24nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZC50ZXh0KFxuICAgICAgICAgICAgICAgIFtkZXRhaWxfeCtkZXRhaWxfdy0ob2Zmc2V0X2EpLzIsIGRldGFpbF95K2RldGFpbF9oKzE1XSxcbiAgICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgICAgJ2RpbWVudGlvbicsXG4gICAgICAgICAgICAgICAgJ2RpbWVudGlvbidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkLnRleHQoXG4gICAgICAgICAgICAgICAgW2RldGFpbF94LTE1LCBkZXRhaWxfeStkZXRhaWxfaC0ob2Zmc2V0X2EpLzJdLFxuICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICAnZGltZW50aW9uJyxcbiAgICAgICAgICAgICAgICAnZGltZW50aW9uJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGQudGV4dChcbiAgICAgICAgICAgICAgICBbZGV0YWlsX3gtMTUsIGRldGFpbF95KyhvZmZzZXRfYSkvMl0sXG4gICAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICAgICdkaW1lbnRpb24nLFxuICAgICAgICAgICAgICAgICdkaW1lbnRpb24nXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB4ID0gZGV0YWlsX3ggKyBkZXRhaWxfdyArIDI1O1xuICAgICAgICAgICAgeSA9IGRldGFpbF95ICsgMTIwO1xuXG4gICAgICAgICAgICBkLmJsb2NrKCdub3J0aCBhcnJvd191cCcsIFt4LHldKTtcblxuXG5cbiAgICAgICAgICAgIC8vLy8vL1xuICAgICAgICAgICAgLy8gTW9kdWxlIG9wdGlvbnNcbiAgICAgICAgICAgIGlmKCBmLnNlY3Rpb25fZGVmaW5lZChzZXR0aW5ncywgJ21vZHVsZScpICYmIGYuc2VjdGlvbl9kZWZpbmVkKHNldHRpbmdzLCAnYXJyYXknKSl7XG4gICAgICAgICAgICAgICAgdmFyIHIsYztcblxuICAgICAgICAgICAgICAgIHZhciByb29mX2xlbmd0aF9hdmFpbCA9IHN5c3RlbS5yb29mLmxlbmd0aCAtIChhKjIpO1xuICAgICAgICAgICAgICAgIHZhciByb29mX3dpZHRoX2F2YWlsID0gc3lzdGVtLnJvb2Yud2lkdGggLSAoYSoyKTtcblxuICAgICAgICAgICAgICAgIHZhciByb3dfc3BhY2luZztcbiAgICAgICAgICAgICAgICBpZiggc3lzdGVtLm1vZHVsZS5vcmllbnRhdGlvbiA9PT0gJ1BvcnRyYWl0JyApe1xuICAgICAgICAgICAgICAgICAgICByb3dfc3BhY2luZyA9IE51bWJlcihzeXN0ZW0ubW9kdWxlLmxlbmd0aCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBjb2xfc3BhY2luZyA9IE51bWJlcihzeXN0ZW0ubW9kdWxlLndpZHRoKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZV93ID0gKE51bWJlcihzeXN0ZW0ubW9kdWxlLndpZHRoKSAgKS8xMjtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlX2ggPSAoTnVtYmVyKHN5c3RlbS5tb2R1bGUubGVuZ3RoKSApLzEyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd19zcGFjaW5nID0gTnVtYmVyKHN5c3RlbS5tb2R1bGUud2lkdGgpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgY29sX3NwYWNpbmcgPSBOdW1iZXIoc3lzdGVtLm1vZHVsZS5sZW5ndGgpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgbW9kdWxlX3cgPSAoTnVtYmVyKHN5c3RlbS5tb2R1bGUubGVuZ3RoKSkvMTI7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZV9oID0gKE51bWJlcihzeXN0ZW0ubW9kdWxlLndpZHRoKSApLzEyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJvd19zcGFjaW5nID0gcm93X3NwYWNpbmcvMTI7IC8vbW9kdWxlIGRpbWVudGlvbnMgYXJlIGluIGluY2hlc1xuICAgICAgICAgICAgICAgIGNvbF9zcGFjaW5nID0gY29sX3NwYWNpbmcvMTI7IC8vbW9kdWxlIGRpbWVudGlvbnMgYXJlIGluIGluY2hlc1xuXG4gICAgICAgICAgICAgICAgdmFyIG51bV9yb3dzID0gTWF0aC5mbG9vcihyb29mX2xlbmd0aF9hdmFpbC9yb3dfc3BhY2luZyk7XG4gICAgICAgICAgICAgICAgdmFyIG51bV9jb2xzID0gTWF0aC5mbG9vcihyb29mX3dpZHRoX2F2YWlsL2NvbF9zcGFjaW5nKTtcblxuICAgICAgICAgICAgICAgIC8vc2VsZWN0ZWQgbW9kdWxlc1xuXG4gICAgICAgICAgICAgICAgaWYoIG51bV9jb2xzICE9PSBzZXR0aW5ncy50ZW1wLm51bV9jb2xzIHx8IG51bV9yb3dzICE9PSBzZXR0aW5ncy50ZW1wLm51bV9yb3dzICl7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLndlYnBhZ2Uuc2VsZWN0ZWRfbW9kdWxlcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy53ZWJwYWdlLnNlbGVjdGVkX21vZHVsZXNfdG90YWwgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciggcj0xOyByPD1udW1fcm93czsgcisrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLndlYnBhZ2Uuc2VsZWN0ZWRfbW9kdWxlc1tyXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKCBjPTE7IGM8PW51bV9jb2xzOyBjKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLndlYnBhZ2Uuc2VsZWN0ZWRfbW9kdWxlc1tyXVtjXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy50ZW1wLm51bV9jb2xzID0gbnVtX2NvbHM7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnRlbXAubnVtX3Jvd3MgPSBudW1fcm93cztcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIHggPSBkZXRhaWxfeCArIG9mZnNldF9hOyAvL2Nvcm5lciBvZiB1c2FibGUgc3BhY2VcbiAgICAgICAgICAgICAgICB5ID0gZGV0YWlsX3kgKyBvZmZzZXRfYTtcbiAgICAgICAgICAgICAgICB4ICs9ICggcm9vZl93aWR0aF9hdmFpbCAtIChjb2xfc3BhY2luZypudW1fY29scykpLzIgKnNjYWxlOyAvLyBjZW50ZXIgYXJyYXkgb24gcm9vZlxuICAgICAgICAgICAgICAgIHkgKz0gKCByb29mX2xlbmd0aF9hdmFpbCAtIChyb3dfc3BhY2luZypudW1fcm93cykpLzIgKnNjYWxlO1xuICAgICAgICAgICAgICAgIG1vZHVsZV93ID0gbW9kdWxlX3cgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICBtb2R1bGVfaCA9IG1vZHVsZV9oICogc2NhbGU7XG5cblxuXG4gICAgICAgICAgICAgICAgZm9yKCByPTE7IHI8PW51bV9yb3dzOyByKyspe1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciggYz0xOyBjPD1udW1fY29sczsgYysrKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxheWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHNldHRpbmdzLndlYnBhZ2Uuc2VsZWN0ZWRfbW9kdWxlc1tyXVtjXSApIGxheWVyID0gJ3ByZXZpZXdfc3RydWN0dXJhbF9tb2R1bGVfc2VsZWN0ZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBsYXllciA9ICdwcmV2aWV3X3N0cnVjdHVyYWxfbW9kdWxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZV94ID0gKGMtMSkgKiBjb2xfc3BhY2luZyAqIHNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlX3kgPSAoci0xKSAqIHJvd19zcGFjaW5nICogc2NhbGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGQucmVjdChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbeCttb2R1bGVfeCttb2R1bGVfdy8yLCB5K21vZHVsZV95K21vZHVsZV9oLzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFttb2R1bGVfdywgbW9kdWxlX2hdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25jbGljazogXCJnLmYudG9nZ2xlX21vZHVsZSh0aGlzKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVfSUQ6ICAocikgKyAnLCcgKyAoYylcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGQudGV4dChcbiAgICAgICAgICAgICAgICAgICAgW2RldGFpbF94K2RldGFpbF93LzIsIGRldGFpbF95K2RldGFpbF9oKzEwMF0sXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiU2VsZWN0ZWQgbW9kdWxlczogXCIgKyBwYXJzZUZsb2F0KCBzZXR0aW5ncy53ZWJwYWdlLnNlbGVjdGVkX21vZHVsZXNfdG90YWwgKS50b0ZpeGVkKCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQ2FsY3VsYXRlZCBtb2R1bGVzOiBcIiArIHBhcnNlRmxvYXQoIHNldHRpbmdzLnN5c3RlbS5hcnJheS5udW1iZXJfb2ZfbW9kdWxlcyApLnRvRml4ZWQoKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAnZGltZW50aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgJ2RpbWVudGlvbidcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG5cblxuXG5cbiAgICAgICAgfVxuICAgIH1cblxuXG5cblxuXG5cbiAgICByZXR1cm4gZC5kcmF3aW5nX3BhcnRzO1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gcGFnZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbnZhciBta19kcmF3aW5nID0gcmVxdWlyZSgnLi4vbWtfZHJhd2luZycpO1xudmFyIG1rX2JvcmRlciA9IHJlcXVpcmUoJy4uL21rX2JvcmRlcicpO1xuXG4vL3ZhciBkcmF3aW5nX3BhcnRzID0gW107XG4vL2QubGlua19kcmF3aW5nX3BhcnRzKGRyYXdpbmdfcGFydHMpO1xuXG52YXIgcGFnZSA9IGZ1bmN0aW9uKHNldHRpbmdzKXtcbiAgICB2YXIgZCA9IG1rX2RyYXdpbmcoc2V0dGluZ3MpO1xuICAgIHZhciBzaGVldF9zZWN0aW9uID0gJ1BWJztcbiAgICB2YXIgc2hlZXRfbnVtID0gJzAxJztcbiAgICAvL2QuYXBwZW5kKG1rX2JvcmRlcihzZXR0aW5ncywgc2hlZXRfc2VjdGlvbiwgc2hlZXRfbnVtICkpO1xuXG4gICAgdmFyIGYgPSBzZXR0aW5ncy5mO1xuXG4gICAgLy92YXIgY29tcG9uZW50cyA9IHNldHRpbmdzLmNvbXBvbmVudHM7XG4gICAgLy92YXIgc3lzdGVtID0gc2V0dGluZ3Muc3lzdGVtO1xuICAgIHZhciBzeXN0ZW0gPSBzZXR0aW5ncy5zeXN0ZW07XG5cbiAgICB2YXIgc2l6ZSA9IHNldHRpbmdzLmRyYXdpbmdfc2V0dGluZ3Muc2l6ZTtcbiAgICB2YXIgbG9jID0gc2V0dGluZ3MuZHJhd2luZ19zZXR0aW5ncy5sb2M7XG5cblxuXG5cbiAgICB2YXIgeCwgeSwgaCwgdztcbiAgICB2YXIgb2Zmc2V0O1xuXG5cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jYXJyYXlcbiAgICBpZiggZi5zZWN0aW9uX2RlZmluZWQoc2V0dGluZ3MsICdtb2R1bGUnKSAmJiBmLnNlY3Rpb25fZGVmaW5lZChzZXR0aW5ncywgJ2FycmF5JykgKXtcbiAgICAgICAgZC5zZWN0aW9uKCdhcnJheScpO1xuXG5cbiAgICAgICAgeCA9IGxvYy5hcnJheS5yaWdodCAtIHNpemUuc3RyaW5nLnc7XG4gICAgICAgIHkgPSBsb2MuYXJyYXkudXBwZXI7XG4gICAgICAgIC8veSAtPSBzaXplLnN0cmluZy5oLzI7XG5cblxuICAgICAgICAvL2ZvciggdmFyIGk9MDsgaTxzeXN0ZW0uREMuc3RyaW5nX251bTsgaSsrICkge1xuICAgICAgICBmb3IoIHZhciBpIGluIF8ucmFuZ2Uoc3lzdGVtLmFycmF5Lm51bV9zdHJpbmdzKSkge1xuICAgICAgICAgICAgLy92YXIgb2Zmc2V0ID0gaSAqIHNpemUud2lyZV9vZmZzZXQuYmFzZVxuICAgICAgICAgICAgdmFyIG9mZnNldF93aXJlID0gc2l6ZS53aXJlX29mZnNldC5taW4gKyAoIHNpemUud2lyZV9vZmZzZXQuYmFzZSAqIGkgKTtcblxuICAgICAgICAgICAgZC5ibG9jaygnc3RyaW5nJywgW3gseV0pO1xuICAgICAgICAgICAgLy8gcG9zaXRpdmUgaG9tZSBydW5cbiAgICAgICAgICAgIGQubGF5ZXIoJ0RDX3BvcycpO1xuICAgICAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgICAgICBbIHggLCBsb2MuYXJyYXkudXBwZXIgXSxcbiAgICAgICAgICAgICAgICBbIHggLCBsb2MuYXJyYXkudXBwZXItb2Zmc2V0X3dpcmUgXSxcbiAgICAgICAgICAgICAgICBbIGxvYy5hcnJheS5yaWdodCtvZmZzZXRfd2lyZSAsIGxvYy5hcnJheS51cHBlci1vZmZzZXRfd2lyZSBdLFxuICAgICAgICAgICAgICAgIFsgbG9jLmFycmF5LnJpZ2h0K29mZnNldF93aXJlICwgbG9jLmpiX2JveC55LW9mZnNldF93aXJlXSxcbiAgICAgICAgICAgICAgICBbIGxvYy5qYl9ib3gueCAsIGxvYy5qYl9ib3gueS1vZmZzZXRfd2lyZV0sXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgLy8gbmVnYXRpdmUgaG9tZSBydW5cbiAgICAgICAgICAgIGQubGF5ZXIoJ0RDX25lZycpO1xuICAgICAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgICAgICBbIHggLCBsb2MuYXJyYXkubG93ZXIgXSxcbiAgICAgICAgICAgICAgICBbIHggLCBsb2MuYXJyYXkubG93ZXJfbGltaXQrb2Zmc2V0X3dpcmUgXSxcbiAgICAgICAgICAgICAgICBbIGxvYy5hcnJheS5yaWdodCtvZmZzZXRfd2lyZSAsIGxvYy5hcnJheS5sb3dlcl9saW1pdCtvZmZzZXRfd2lyZSBdLFxuICAgICAgICAgICAgICAgIFsgbG9jLmFycmF5LnJpZ2h0K29mZnNldF93aXJlICwgbG9jLmpiX2JveC55K29mZnNldF93aXJlXSxcbiAgICAgICAgICAgICAgICBbIGxvYy5qYl9ib3gueCAsIGxvYy5qYl9ib3gueStvZmZzZXRfd2lyZV0sXG4gICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgeCAtPSBzaXplLnN0cmluZy53O1xuICAgICAgICB9XG5cbiAgICAvLyAgICBkLnJlY3QoXG4gICAgLy8gICAgICAgIFsgKGxvYy5hcnJheS5yaWdodCtsb2MuYXJyYXkubGVmdCkvMiwgKGxvYy5hcnJheS5sb3dlcitsb2MuYXJyYXkudXBwZXIpLzIgXSxcbiAgICAvLyAgICAgICAgWyBsb2MuYXJyYXkucmlnaHQtbG9jLmFycmF5LmxlZnQsIGxvYy5hcnJheS5sb3dlci1sb2MuYXJyYXkudXBwZXIgXSxcbiAgICAvLyAgICAgICAgJ0RDX3BvcycpO1xuICAgIC8vXG5cbiAgICAgICAgZC5sYXllcignRENfZ3JvdW5kJyk7XG4gICAgICAgIGQubGluZShbXG4gICAgICAgICAgICAvL1sgbG9jLmFycmF5LmxlZnQgLCBsb2MuYXJyYXkubG93ZXIgKyBzaXplLndpcmVfb2Zmc2V0Lmdyb3VuZCBdLFxuICAgICAgICAgICAgWyBsb2MuYXJyYXkubGVmdCwgbG9jLmFycmF5Lmxvd2VyX2xpbWl0ICsgc2l6ZS53aXJlX29mZnNldC5ncm91bmQgXSxcbiAgICAgICAgICAgIFsgbG9jLmFycmF5LnJpZ2h0K3NpemUud2lyZV9vZmZzZXQuZ3JvdW5kICwgbG9jLmFycmF5Lmxvd2VyX2xpbWl0ICsgc2l6ZS53aXJlX29mZnNldC5ncm91bmQgXSxcbiAgICAgICAgICAgIFsgbG9jLmFycmF5LnJpZ2h0K3NpemUud2lyZV9vZmZzZXQuZ3JvdW5kICwgbG9jLmpiX2JveC55ICsgc2l6ZS53aXJlX29mZnNldC5ncm91bmRdLFxuICAgICAgICAgICAgWyBsb2MuamJfYm94LnggLCBsb2MuamJfYm94Lnkrc2l6ZS53aXJlX29mZnNldC5ncm91bmRdLFxuICAgICAgICBdKTtcblxuICAgICAgICBkLmxheWVyKCk7XG5cblxuICAgIH0vLyBlbHNlIHsgY29uc29sZS5sb2coXCJEcmF3aW5nOiBhcnJheSBub3QgcmVhZHlcIil9XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIGNvbWJpbmVyIGJveFxuXG4gICAgaWYoIGYuc2VjdGlvbl9kZWZpbmVkKHNldHRpbmdzLCAnREMnKSApe1xuXG4gICAgICAgIGQuc2VjdGlvbihcImNvbWJpbmVyXCIpO1xuXG4gICAgICAgIHggPSBsb2MuamJfYm94Lng7XG4gICAgICAgIHkgPSBsb2MuamJfYm94Lnk7XG5cbiAgICAgICAgZC5yZWN0KFxuICAgICAgICAgICAgW3gseV0sXG4gICAgICAgICAgICBbc2l6ZS5qYl9ib3gudyxzaXplLmpiX2JveC5oXSxcbiAgICAgICAgICAgICdib3gnXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yKCBpIGluIF8ucmFuZ2Uoc3lzdGVtLmFycmF5Lm51bV9zdHJpbmdzKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gc2l6ZS53aXJlX29mZnNldC5taW4gKyAoIHNpemUud2lyZV9vZmZzZXQuYmFzZSAqIGkgKTtcblxuICAgICAgICAgICAgZC5sYXllcignRENfcG9zJyk7XG4gICAgICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgICAgIFsgeCAsIHktb2Zmc2V0XSxcbiAgICAgICAgICAgICAgICBbIHggLCB5LW9mZnNldF0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGQuYmxvY2soICd0ZXJtaW5hbCcsIHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHktb2Zmc2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgICAgIFsgeCAsIHktb2Zmc2V0XSxcbiAgICAgICAgICAgICAgICBbIGxvYy5kaXNjYm94Lngtb2Zmc2V0ICwgeS1vZmZzZXRdLFxuICAgICAgICAgICAgICAgIFsgbG9jLmRpc2Nib3gueC1vZmZzZXQgLCBsb2MuZGlzY2JveC55K3NpemUuZGlzY2JveC5oLzItc2l6ZS50ZXJtaW5hbF9kaWFtXSxcbiAgICAgICAgICAgICAgICBbIGxvYy5kaXNjYm94Lngtb2Zmc2V0ICwgbG9jLmRpc2Nib3gueStzaXplLmRpc2Nib3guaC8yLXNpemUudGVybWluYWxfZGlhbS1zaXplLnRlcm1pbmFsX2RpYW0qM10sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGQuYmxvY2soICd0ZXJtaW5hbCcsIHtcbiAgICAgICAgICAgICAgICB4OiBsb2MuZGlzY2JveC54LW9mZnNldCxcbiAgICAgICAgICAgICAgICB5OiBsb2MuZGlzY2JveC55K3NpemUuZGlzY2JveC5oLzItc2l6ZS50ZXJtaW5hbF9kaWFtXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZC5sYXllcignRENfbmVnJyk7XG4gICAgICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgICAgIFsgeCwgeStvZmZzZXRdLFxuICAgICAgICAgICAgICAgIFsgeC1zaXplLmZ1c2Uudy8yICwgeStvZmZzZXRdLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBkLmJsb2NrKCAnZnVzZScsIHtcbiAgICAgICAgICAgICAgICB4OiB4ICxcbiAgICAgICAgICAgICAgICB5OiB5K29mZnNldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgICAgICBbIHgrc2l6ZS5mdXNlLncvMiAsIHkrb2Zmc2V0XSxcbiAgICAgICAgICAgICAgICBbIGxvYy5kaXNjYm94Lngrb2Zmc2V0ICwgeStvZmZzZXRdLFxuICAgICAgICAgICAgICAgIFsgbG9jLmRpc2Nib3gueCtvZmZzZXQgLCBsb2MuZGlzY2JveC55K3NpemUuZGlzY2JveC5oLzItc2l6ZS50ZXJtaW5hbF9kaWFtXSxcbiAgICAgICAgICAgICAgICBbIGxvYy5kaXNjYm94Lngrb2Zmc2V0ICwgbG9jLmRpc2Nib3gueStzaXplLmRpc2Nib3guaC8yLXNpemUudGVybWluYWxfZGlhbS1zaXplLnRlcm1pbmFsX2RpYW0qM10sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGQuYmxvY2soICd0ZXJtaW5hbCcsIHtcbiAgICAgICAgICAgICAgICB4OiBsb2MuZGlzY2JveC54K29mZnNldCxcbiAgICAgICAgICAgICAgICB5OiBsb2MuZGlzY2JveC55K3NpemUuZGlzY2JveC5oLzItc2l6ZS50ZXJtaW5hbF9kaWFtXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGQubGF5ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZC5sYXllcignRENfZ3JvdW5kJyk7XG4gICAgICAgIC8vZC5saW5lKFtcbiAgICAgICAgLy8gICAgWyBsb2MuYXJyYXkubGVmdCAsIGxvYy5hcnJheS5sb3dlciArIHNpemUubW9kdWxlLncgKyBzaXplLndpcmVfb2Zmc2V0Lmdyb3VuZCBdLFxuICAgICAgICAvLyAgICBbIGxvYy5hcnJheS5yaWdodCtzaXplLndpcmVfb2Zmc2V0Lmdyb3VuZCAsIGxvYy5hcnJheS5sb3dlciArIHNpemUubW9kdWxlLncgKyBzaXplLndpcmVfb2Zmc2V0Lmdyb3VuZCBdLFxuICAgICAgICAvLyAgICBbIGxvYy5hcnJheS5yaWdodCtzaXplLndpcmVfb2Zmc2V0Lmdyb3VuZCAsIGxvYy5hcnJheS55ICsgc2l6ZS5tb2R1bGUudyArIHNpemUud2lyZV9vZmZzZXQuZ3JvdW5kXSxcbiAgICAgICAgLy8gICAgWyBsb2MuYXJyYXkueCAsIGxvYy5hcnJheS55K3NpemUubW9kdWxlLncrc2l6ZS53aXJlX29mZnNldC5ncm91bmRdLFxuICAgICAgICAvL10pO1xuXG4gICAgICAgIC8vZC5sYXllcigpO1xuXG4gICAgICAgIC8vIEdyb3VuZFxuICAgICAgICAvL29mZnNldCA9IHNpemUud2lyZV9vZmZzZXQuZ2FwICsgc2l6ZS53aXJlX29mZnNldC5ncm91bmQ7XG4gICAgICAgIG9mZnNldCA9IHNpemUud2lyZV9vZmZzZXQuZ3JvdW5kO1xuXG4gICAgICAgIGQubGF5ZXIoJ0RDX2dyb3VuZCcpO1xuICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgWyB4ICwgeStvZmZzZXRdLFxuICAgICAgICAgICAgWyB4ICwgeStvZmZzZXRdLFxuICAgICAgICBdKTtcbiAgICAgICAgZC5ibG9jayggJ3Rlcm1pbmFsJywge1xuICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgIHk6IHkrb2Zmc2V0LFxuICAgICAgICB9KTtcbiAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgIFsgeCAsIHkrb2Zmc2V0XSxcbiAgICAgICAgICAgIFsgbG9jLmRpc2Nib3gueCtvZmZzZXQgLCB5K29mZnNldF0sXG4gICAgICAgICAgICBbIGxvYy5kaXNjYm94Lngrb2Zmc2V0ICwgbG9jLmRpc2Nib3gueStzaXplLmRpc2Nib3guaC8yLXNpemUudGVybWluYWxfZGlhbV0sXG4gICAgICAgICAgICBbIGxvYy5kaXNjYm94Lngrb2Zmc2V0ICwgbG9jLmRpc2Nib3gueStzaXplLmRpc2Nib3guaC8yLXNpemUudGVybWluYWxfZGlhbS1zaXplLnRlcm1pbmFsX2RpYW0qM10sXG4gICAgICAgIF0pO1xuICAgICAgICBkLmJsb2NrKCAndGVybWluYWwnLCB7XG4gICAgICAgICAgICB4OiBsb2MuZGlzY2JveC54K29mZnNldCxcbiAgICAgICAgICAgIHk6IGxvYy5kaXNjYm94Lnkrc2l6ZS5kaXNjYm94LmgvMi1zaXplLnRlcm1pbmFsX2RpYW1cbiAgICAgICAgfSk7XG4gICAgICAgIGQubGF5ZXIoKTtcblxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAvLyBEQyBkaXNjb25lY3RcbiAgICAgICAgZC5zZWN0aW9uKFwiREMgZGljb25lY3RcIik7XG5cblxuICAgICAgICBkLnJlY3QoXG4gICAgICAgICAgICBbbG9jLmRpc2Nib3gueCwgbG9jLmRpc2Nib3gueV0sXG4gICAgICAgICAgICBbc2l6ZS5kaXNjYm94Lncsc2l6ZS5kaXNjYm94LmhdLFxuICAgICAgICAgICAgJ2JveCdcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBEQyBkaXNjb25lY3QgY29tYmluZXIgZC5saW5lc1xuXG4gICAgICAgIHggPSBsb2MuZGlzY2JveC54O1xuICAgICAgICB5ID0gbG9jLmRpc2Nib3gueSArIHNpemUuZGlzY2JveC5oLzI7XG5cbiAgICAgICAgaWYoIHN5c3RlbS5hcnJheS5udW1fc3RyaW5ncyA+IDEpe1xuICAgICAgICAgICAgdmFyIG9mZnNldF9taW4gPSBzaXplLndpcmVfb2Zmc2V0Lm1pbjtcbiAgICAgICAgICAgIHZhciBvZmZzZXRfbWF4ID0gc2l6ZS53aXJlX29mZnNldC5taW4gKyAoIChzeXN0ZW0uYXJyYXkubnVtX3N0cmluZ3MgLTEpICogc2l6ZS53aXJlX29mZnNldC5iYXNlICk7XG4gICAgICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgICAgIFsgeC1vZmZzZXRfbWluLCB5LXNpemUudGVybWluYWxfZGlhbS1zaXplLnRlcm1pbmFsX2RpYW0qM10sXG4gICAgICAgICAgICAgICAgWyB4LW9mZnNldF9tYXgsIHktc2l6ZS50ZXJtaW5hbF9kaWFtLXNpemUudGVybWluYWxfZGlhbSozXSxcbiAgICAgICAgICAgIF0sICdEQ19wb3MnKTtcbiAgICAgICAgICAgIGQubGluZShbXG4gICAgICAgICAgICAgICAgWyB4K29mZnNldF9taW4sIHktc2l6ZS50ZXJtaW5hbF9kaWFtLXNpemUudGVybWluYWxfZGlhbSozXSxcbiAgICAgICAgICAgICAgICBbIHgrb2Zmc2V0X21heCwgeS1zaXplLnRlcm1pbmFsX2RpYW0tc2l6ZS50ZXJtaW5hbF9kaWFtKjNdLFxuICAgICAgICAgICAgXSwgJ0RDX25lZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW52ZXJ0ZXIgY29uZWN0aW9uXG4gICAgICAgIC8vZC5saW5lKFtcbiAgICAgICAgLy8gICAgWyB4LW9mZnNldF9taW4sIHktc2l6ZS50ZXJtaW5hbF9kaWFtLXNpemUudGVybWluYWxfZGlhbSozXSxcbiAgICAgICAgLy8gICAgWyB4LW9mZnNldF9taW4sIHktc2l6ZS50ZXJtaW5hbF9kaWFtLXNpemUudGVybWluYWxfZGlhbSozXSxcbiAgICAgICAgLy9dLCdEQ19wb3MnKTtcblxuICAgICAgICAvL29mZnNldCA9IG9mZnNldF9tYXggLSBvZmZzZXRfbWluO1xuICAgICAgICBvZmZzZXQgPSBzaXplLndpcmVfb2Zmc2V0Lm1pbjtcblxuICAgICAgICAvLyBuZWdcbiAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgIFsgeCtvZmZzZXQsIHktc2l6ZS50ZXJtaW5hbF9kaWFtLXNpemUudGVybWluYWxfZGlhbSozXSxcbiAgICAgICAgICAgIFsgeCtvZmZzZXQsIGxvYy5pbnZlcnRlci55K3NpemUuaW52ZXJ0ZXIuaC8yLXNpemUudGVybWluYWxfZGlhbSBdLFxuICAgICAgICBdLCdEQ19uZWcnKTtcbiAgICAgICAgZC5ibG9jayggJ3Rlcm1pbmFsJywge1xuICAgICAgICAgICAgeDogeCtvZmZzZXQsXG4gICAgICAgICAgICB5OiBsb2MuaW52ZXJ0ZXIueStzaXplLmludmVydGVyLmgvMi1zaXplLnRlcm1pbmFsX2RpYW0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHBvc1xuICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgWyB4LW9mZnNldCwgeS1zaXplLnRlcm1pbmFsX2RpYW0tc2l6ZS50ZXJtaW5hbF9kaWFtKjNdLFxuICAgICAgICAgICAgWyB4LW9mZnNldCwgbG9jLmludmVydGVyLnkrc2l6ZS5pbnZlcnRlci5oLzItc2l6ZS50ZXJtaW5hbF9kaWFtIF0sXG4gICAgICAgIF0sJ0RDX3BvcycpO1xuICAgICAgICBkLmJsb2NrKCAndGVybWluYWwnLCB7XG4gICAgICAgICAgICB4OiB4LW9mZnNldCxcbiAgICAgICAgICAgIHk6IGxvYy5pbnZlcnRlci55K3NpemUuaW52ZXJ0ZXIuaC8yLXNpemUudGVybWluYWxfZGlhbSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZ3JvdW5kXG4gICAgICAgIC8vb2Zmc2V0ID0gc2l6ZS53aXJlX29mZnNldC5nYXAgKyBzaXplLndpcmVfb2Zmc2V0Lmdyb3VuZDtcbiAgICAgICAgb2Zmc2V0ID0gc2l6ZS53aXJlX29mZnNldC5ncm91bmQ7XG4gICAgICAgIGQubGluZShbXG4gICAgICAgICAgICBbIHgrb2Zmc2V0LCB5LXNpemUudGVybWluYWxfZGlhbS1zaXplLnRlcm1pbmFsX2RpYW0qM10sXG4gICAgICAgICAgICBbIHgrb2Zmc2V0LCBsb2MuaW52ZXJ0ZXIueStzaXplLmludmVydGVyLmgvMi1zaXplLnRlcm1pbmFsX2RpYW0gXSxcbiAgICAgICAgXSwnRENfZ3JvdW5kJyk7XG4gICAgICAgIGQuYmxvY2soICd0ZXJtaW5hbCcsIHtcbiAgICAgICAgICAgIHg6IHgrb2Zmc2V0LFxuICAgICAgICAgICAgeTogbG9jLmludmVydGVyLnkrc2l6ZS5pbnZlcnRlci5oLzItc2l6ZS50ZXJtaW5hbF9kaWFtLFxuICAgICAgICB9KTtcblxuICAgIH1cblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jaW52ZXJ0ZXJcbiAgICBpZiggZi5zZWN0aW9uX2RlZmluZWQoc2V0dGluZ3MsICdpbnZlcnRlcicpICl7XG5cbiAgICAgICAgZC5zZWN0aW9uKFwiaW52ZXJ0ZXJcIik7XG5cblxuICAgICAgICB4ID0gbG9jLmludmVydGVyLng7XG4gICAgICAgIHkgPSBsb2MuaW52ZXJ0ZXIueTtcblxuXG4gICAgICAgIC8vZnJhbWVcbiAgICAgICAgZC5sYXllcignYm94Jyk7XG4gICAgICAgIGQucmVjdChcbiAgICAgICAgICAgIFt4LHldLFxuICAgICAgICAgICAgW3NpemUuaW52ZXJ0ZXIudywgc2l6ZS5pbnZlcnRlci5oXVxuICAgICAgICApO1xuICAgICAgICAvLyBMYWJlbCBhdCB0b3AgKEludmVydGVyLCBtYWtlLCBtb2RlbCwgLi4uKVxuICAgICAgICBkLmxheWVyKCd0ZXh0Jyk7XG4gICAgICAgIGQudGV4dChcbiAgICAgICAgICAgIFtsb2MuaW52ZXJ0ZXIueCwgbG9jLmludmVydGVyLnRvcCArIHNpemUuaW52ZXJ0ZXIudGV4dF9nYXAgXSxcbiAgICAgICAgICAgIFsgJ0ludmVydGVyJywgc2V0dGluZ3Muc3lzdGVtLmludmVydGVyLm1ha2UgKyBcIiBcIiArIHNldHRpbmdzLnN5c3RlbS5pbnZlcnRlci5tb2RlbCBdLFxuICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgJ2xhYmVsJ1xuICAgICAgICApO1xuICAgICAgICBkLmxheWVyKCk7XG5cbiAgICAvLyNpbnZlcnRlciBzeW1ib2xcbiAgICAgICAgZC5zZWN0aW9uKFwiaW52ZXJ0ZXIgc3ltYm9sXCIpO1xuXG4gICAgICAgIHggPSBsb2MuaW52ZXJ0ZXIueDtcbiAgICAgICAgeSA9IGxvYy5pbnZlcnRlci55O1xuXG4gICAgICAgIHcgPSBzaXplLmludmVydGVyLnN5bWJvbF93O1xuICAgICAgICBoID0gc2l6ZS5pbnZlcnRlci5zeW1ib2xfaDtcblxuICAgICAgICB2YXIgc3BhY2UgPSB3KjEvMTI7XG5cbiAgICAgICAgLy8gSW52ZXJ0ZXIgc3ltYm9sXG4gICAgICAgIGQubGF5ZXIoJ2JveCcpO1xuXG4gICAgICAgIC8vIGJveFxuICAgICAgICBkLnJlY3QoXG4gICAgICAgICAgICBbeCx5XSxcbiAgICAgICAgICAgIFt3LCBoXVxuICAgICAgICApO1xuICAgICAgICAvLyBkaWFnYW5hbFxuICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgW3gtdy8yLCB5K2gvMl0sXG4gICAgICAgICAgICBbeCt3LzIsIHktaC8yXSxcblxuICAgICAgICBdKTtcbiAgICAgICAgLy8gRENcbiAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgIFt4IC0gdy8yICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgeSAtIGgvMiArIHNwYWNlXSxcbiAgICAgICAgICAgIFt4IC0gdy8yICsgc3BhY2UqNixcbiAgICAgICAgICAgICAgICB5IC0gaC8yICsgc3BhY2VdLFxuICAgICAgICBdKTtcbiAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgIFt4IC0gdy8yICsgc3BhY2UsXG4gICAgICAgICAgICAgICAgeSAtIGgvMiArIHNwYWNlKjJdLFxuICAgICAgICAgICAgW3ggLSB3LzIgKyBzcGFjZSoyLFxuICAgICAgICAgICAgICAgIHkgLSBoLzIgKyBzcGFjZSoyXSxcbiAgICAgICAgXSk7XG4gICAgICAgIGQubGluZShbXG4gICAgICAgICAgICBbeCAtIHcvMiArIHNwYWNlKjMsXG4gICAgICAgICAgICAgICAgeSAtIGgvMiArIHNwYWNlKjJdLFxuICAgICAgICAgICAgW3ggLSB3LzIgKyBzcGFjZSo0LFxuICAgICAgICAgICAgICAgIHkgLSBoLzIgKyBzcGFjZSoyXSxcbiAgICAgICAgXSk7XG4gICAgICAgIGQubGluZShbXG4gICAgICAgICAgICBbeCAtIHcvMiArIHNwYWNlKjUsXG4gICAgICAgICAgICAgICAgeSAtIGgvMiArIHNwYWNlKjJdLFxuICAgICAgICAgICAgW3ggLSB3LzIgKyBzcGFjZSo2LFxuICAgICAgICAgICAgICAgIHkgLSBoLzIgKyBzcGFjZSoyXSxcbiAgICAgICAgXSk7XG5cbiAgICAgICAgLy8gQUNcbiAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgIFt4ICsgdy8yIC0gc3BhY2UsXG4gICAgICAgICAgICAgICAgeSArIGgvMiAtIHNwYWNlKjEuNV0sXG4gICAgICAgICAgICBbeCArIHcvMiAtIHNwYWNlKjIsXG4gICAgICAgICAgICAgICAgeSArIGgvMiAtIHNwYWNlKjEuNV0sXG4gICAgICAgIF0pO1xuICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgW3ggKyB3LzIgLSBzcGFjZSozLFxuICAgICAgICAgICAgICAgIHkgKyBoLzIgLSBzcGFjZSoxLjVdLFxuICAgICAgICAgICAgW3ggKyB3LzIgLSBzcGFjZSo0LFxuICAgICAgICAgICAgICAgIHkgKyBoLzIgLSBzcGFjZSoxLjVdLFxuICAgICAgICBdKTtcbiAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgIFt4ICsgdy8yIC0gc3BhY2UqNSxcbiAgICAgICAgICAgICAgICB5ICsgaC8yIC0gc3BhY2UqMS41XSxcbiAgICAgICAgICAgIFt4ICsgdy8yIC0gc3BhY2UqNixcbiAgICAgICAgICAgICAgICB5ICsgaC8yIC0gc3BhY2UqMS41XSxcbiAgICAgICAgXSk7XG4gICAgICAgIGQubGF5ZXIoKTtcblxuXG5cblxuXG4gICAgfVxuXG5cblxuXG5cbi8vI0FDX2Rpc2Njb25lY3RcbiAgICBpZiggZi5zZWN0aW9uX2RlZmluZWQoc2V0dGluZ3MsICdBQycpICl7XG4gICAgICAgIGQuc2VjdGlvbihcIkFDX2Rpc2Njb25lY3RcIik7XG5cbiAgICAgICAgeCA9IGxvYy5BQ19kaXNjLng7XG4gICAgICAgIHkgPSBsb2MuQUNfZGlzYy55O1xuICAgICAgICB2YXIgcGFkZGluZyA9IHNpemUudGVybWluYWxfZGlhbTtcblxuICAgICAgICBkLmxheWVyKCdib3gnKTtcbiAgICAgICAgZC5yZWN0KFxuICAgICAgICAgICAgW3gsIHldLFxuICAgICAgICAgICAgW3NpemUuQUNfZGlzYy53LCBzaXplLkFDX2Rpc2MuaF1cbiAgICAgICAgKTtcbiAgICAgICAgZC5sYXllcigpO1xuXG5cbiAgICAvL2QuY2lyYyhbeCx5XSw1KTtcblxuXG5cbiAgICAvLyNBQyBsb2FkIGNlbnRlclxuICAgICAgICBkLnNlY3Rpb24oXCJBQyBsb2FkIGNlbnRlclwiKTtcblxuICAgICAgICB2YXIgYnJlYWtlcl9zcGFjaW5nID0gc2l6ZS5BQ19sb2FkY2VudGVyLmJyZWFrZXJzLnNwYWNpbmc7XG5cbiAgICAgICAgeCA9IGxvYy5BQ19sb2FkY2VudGVyLng7XG4gICAgICAgIHkgPSBsb2MuQUNfbG9hZGNlbnRlci55O1xuICAgICAgICB3ID0gc2l6ZS5BQ19sb2FkY2VudGVyLnc7XG4gICAgICAgIGggPSBzaXplLkFDX2xvYWRjZW50ZXIuaDtcblxuICAgICAgICBkLnJlY3QoW3gseV0sXG4gICAgICAgICAgICBbdyxoXSxcbiAgICAgICAgICAgICdib3gnXG4gICAgICAgICk7XG5cbiAgICAgICAgZC50ZXh0KFt4LHktaCowLjRdLFxuICAgICAgICAgICAgW3N5c3RlbS5BQy5sb2FkY2VudGVyX3R5cGVzLCAnTG9hZCBDZW50ZXInXSxcbiAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgICdsYWJlbCdcbiAgICAgICAgKTtcbiAgICAgICAgdyA9IHNpemUuQUNfbG9hZGNlbnRlci5icmVha2VyLnc7XG4gICAgICAgIGggPSBzaXplLkFDX2xvYWRjZW50ZXIuYnJlYWtlci5oO1xuXG4gICAgICAgIHBhZGRpbmcgPSBsb2MuQUNfbG9hZGNlbnRlci54IC0gbG9jLkFDX2xvYWRjZW50ZXIuYnJlYWtlcnMubGVmdCAtIHNpemUuQUNfbG9hZGNlbnRlci5icmVha2VyLnc7XG5cbiAgICAgICAgeSA9IGxvYy5BQ19sb2FkY2VudGVyLmJyZWFrZXJzLnRvcDtcbiAgICAgICAgeSArPSBzaXplLkFDX2xvYWRjZW50ZXIuYnJlYWtlcnMuc3BhY2luZy8yO1xuICAgICAgICBmb3IoIHZhciBpPTA7IGk8c2l6ZS5BQ19sb2FkY2VudGVyLmJyZWFrZXJzLm51bTsgaSsrKXtcbiAgICAgICAgICAgIGQucmVjdChbeC1wYWRkaW5nLXcvMix5XSxbdyxoXSwnYm94Jyk7XG4gICAgICAgICAgICBkLnJlY3QoW3grcGFkZGluZyt3LzIseV0sW3csaF0sJ2JveCcpO1xuICAgICAgICAgICAgeSArPSBicmVha2VyX3NwYWNpbmc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcywgbDtcblxuICAgICAgICBsID0gbG9jLkFDX2xvYWRjZW50ZXIubmV1dHJhbGJhcjtcbiAgICAgICAgcyA9IHNpemUuQUNfbG9hZGNlbnRlci5uZXV0cmFsYmFyO1xuICAgICAgICBkLnJlY3QoW2wueCxsLnldLCBbcy53LHMuaF0sICdBQ19uZXV0cmFsJyApO1xuXG4gICAgICAgIGwgPSBsb2MuQUNfbG9hZGNlbnRlci5ncm91bmRiYXI7XG4gICAgICAgIHMgPSBzaXplLkFDX2xvYWRjZW50ZXIuZ3JvdW5kYmFyO1xuICAgICAgICBkLnJlY3QoW2wueCxsLnldLCBbcy53LHMuaF0sICdBQ19ncm91bmQnICk7XG5cbiAgICAgICAgZC5ibG9jaygnZ3JvdW5kJywgW2wueCxsLnkrcy5oLzJdKTtcblxuXG5cbiAgICAvLyBBQyBkLmxpbmVzXG4gICAgICAgIGQuc2VjdGlvbihcIkFDIGQubGluZXNcIik7XG5cbiAgICAgICAgeCA9IGxvYy5pbnZlcnRlci5ib3R0b21fcmlnaHQueDtcbiAgICAgICAgeSA9IGxvYy5pbnZlcnRlci5ib3R0b21fcmlnaHQueTtcbiAgICAgICAgeCAtPSBzaXplLnRlcm1pbmFsX2RpYW0gKiAoc3lzdGVtLkFDLm51bV9jb25kdWN0b3JzKzEpO1xuICAgICAgICB5IC09IHNpemUudGVybWluYWxfZGlhbTtcblxuICAgICAgICB2YXIgY29uZHVpdF95ID0gbG9jLkFDX2NvbmR1aXQueTtcbiAgICAgICAgcGFkZGluZyA9IHNpemUudGVybWluYWxfZGlhbTtcbiAgICAgICAgLy92YXIgQUNfZC5sYXllcl9uYW1lcyA9IFsnQUNfZ3JvdW5kJywgJ0FDX25ldXRyYWwnLCAnQUNfTDEnLCAnQUNfTDInLCAnQUNfTDInXTtcblxuICAgICAgICBmb3IoIHZhciBpPTA7IGkgPCBzeXN0ZW0uQUMubnVtX2NvbmR1Y3RvcnM7IGkrKyApe1xuICAgICAgICAgICAgZC5ibG9jaygndGVybWluYWwnLCBbeCx5XSApO1xuICAgICAgICAgICAgZC5sYXllcignQUNfJytzeXN0ZW0uQUMuY29uZHVjdG9yc1tpXSk7XG4gICAgICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgICAgIFt4LCB5XSxcbiAgICAgICAgICAgICAgICBbeCwgbG9jLkFDX2Rpc2MuYm90dG9tIC0gcGFkZGluZyoyIC0gcGFkZGluZyppICBdLFxuICAgICAgICAgICAgICAgIFtsb2MuQUNfZGlzYy5sZWZ0LCBsb2MuQUNfZGlzYy5ib3R0b20gLSBwYWRkaW5nKjIgLSBwYWRkaW5nKmkgXSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgeCArPSBzaXplLnRlcm1pbmFsX2RpYW07XG4gICAgICAgIH1cbiAgICAgICAgZC5sYXllcigpO1xuXG4gICAgICAgIHggPSBsb2MuQUNfZGlzYy54O1xuICAgICAgICB5ID0gbG9jLkFDX2Rpc2MueSArIHNpemUuQUNfZGlzYy5oLzI7XG4gICAgICAgIHkgLT0gcGFkZGluZyoyO1xuXG4gICAgICAgIGlmKCBzeXN0ZW0uQUMuY29uZHVjdG9ycyAmJiBzeXN0ZW0uQUMuY29uZHVjdG9ycy5pbmRleE9mKCdncm91bmQnKSsxICkge1xuICAgICAgICAgICAgZC5sYXllcignQUNfZ3JvdW5kJyk7XG4gICAgICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgICAgIFsgeC1zaXplLkFDX2Rpc2Mudy8yLCB5IF0sXG4gICAgICAgICAgICAgICAgWyB4K3NpemUuQUNfZGlzYy53LzIrcGFkZGluZyoyLCB5IF0sXG4gICAgICAgICAgICAgICAgWyB4K3NpemUuQUNfZGlzYy53LzIrcGFkZGluZyoyLCBjb25kdWl0X3kgKyBicmVha2VyX3NwYWNpbmcqMiBdLFxuICAgICAgICAgICAgICAgIFsgbG9jLkFDX2xvYWRjZW50ZXIubGVmdCtwYWRkaW5nKjIsIGNvbmR1aXRfeSArIGJyZWFrZXJfc3BhY2luZyoyIF0sXG4gICAgICAgICAgICAgICAgLy9bIGxvYy5BQ19sb2FkY2VudGVyLmxlZnQrcGFkZGluZyoyLCB5IF0sXG4gICAgICAgICAgICAgICAgLy9bIGxvYy5BQ19sb2FkY2VudGVyLmdyb3VuZGJhci54LXBhZGRpbmcsIHkgXSxcbiAgICAgICAgICAgICAgICAvL1sgbG9jLkFDX2xvYWRjZW50ZXIuZ3JvdW5kYmFyLngtcGFkZGluZywgbG9jLkFDX2xvYWRjZW50ZXIuZ3JvdW5kYmFyLnkrc2l6ZS5BQ19sb2FkY2VudGVyLmdyb3VuZGJhci5oLzIgXSxcbiAgICAgICAgICAgICAgICBbIGxvYy5BQ19sb2FkY2VudGVyLmxlZnQrcGFkZGluZyoyLCBsb2MuQUNfbG9hZGNlbnRlci5ncm91bmRiYXIueSBdLFxuICAgICAgICAgICAgICAgIFsgbG9jLkFDX2xvYWRjZW50ZXIuZ3JvdW5kYmFyLngtc2l6ZS5BQ19sb2FkY2VudGVyLmdyb3VuZGJhci53LzIsIGxvYy5BQ19sb2FkY2VudGVyLmdyb3VuZGJhci55IF0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBzeXN0ZW0uQUMuY29uZHVjdG9ycyAmJiBzeXN0ZW0uQUMuY29uZHVjdG9ycy5pbmRleE9mKCduZXV0cmFsJykrMSApIHtcbiAgICAgICAgICAgIHkgLT0gcGFkZGluZztcbiAgICAgICAgICAgIGQubGF5ZXIoJ0FDX25ldXRyYWwnKTtcbiAgICAgICAgICAgIGQubGluZShbXG4gICAgICAgICAgICAgICAgWyB4LXNpemUuQUNfZGlzYy53LzIsIHkgXSxcbiAgICAgICAgICAgICAgICBbIHgrcGFkZGluZyozKjIsIHkgXSxcbiAgICAgICAgICAgICAgICBbIHgrcGFkZGluZyozKjIsIGNvbmR1aXRfeSArIGJyZWFrZXJfc3BhY2luZyoxIF0sXG4gICAgICAgICAgICAgICAgWyBsb2MuQUNfbG9hZGNlbnRlci5uZXV0cmFsYmFyLngsIGNvbmR1aXRfeSArIGJyZWFrZXJfc3BhY2luZyoxIF0sXG4gICAgICAgICAgICAgICAgWyBsb2MuQUNfbG9hZGNlbnRlci5uZXV0cmFsYmFyLngsXG4gICAgICAgICAgICAgICAgICAgIGxvYy5BQ19sb2FkY2VudGVyLm5ldXRyYWxiYXIueS1zaXplLkFDX2xvYWRjZW50ZXIubmV1dHJhbGJhci5oLzIgXSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG5cblxuXG4gICAgICAgIGZvciggdmFyIGk9MTsgaSA8PSAzOyBpKysgKSB7XG4gICAgICAgICAgICBpZiggc3lzdGVtLkFDLmNvbmR1Y3RvcnMgJiYgc3lzdGVtLkFDLmNvbmR1Y3RvcnMuaW5kZXhPZignTCcraSkrMSApIHtcbiAgICAgICAgICAgICAgICB5IC09IHBhZGRpbmc7XG4gICAgICAgICAgICAgICAgZC5sYXllcignQUNfTCcraSk7XG4gICAgICAgICAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgICAgICAgICAgWyB4LXNpemUuQUNfZGlzYy53LzIsIHkgXSxcbiAgICAgICAgICAgICAgICAgICAgWyB4K3BhZGRpbmcqMyooMi1pKSwgeSBdLFxuICAgICAgICAgICAgICAgICAgICBbIHgrcGFkZGluZyozKigyLWkpLCBsb2MuQUNfZGlzYy5zd2l0Y2hfYm90dG9tIF0sXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgZC5ibG9jaygndGVybWluYWwnLCBbIHgtcGFkZGluZyooaS0yKSozLCBsb2MuQUNfZGlzYy5zd2l0Y2hfYm90dG9tIF0gKTtcbiAgICAgICAgICAgICAgICBkLmJsb2NrKCd0ZXJtaW5hbCcsIFsgeC1wYWRkaW5nKihpLTIpKjMsIGxvYy5BQ19kaXNjLnN3aXRjaF90b3AgXSApO1xuICAgICAgICAgICAgICAgIGQubGluZShbXG4gICAgICAgICAgICAgICAgICAgIFsgeC1wYWRkaW5nKihpLTIpKjMsIGxvYy5BQ19kaXNjLnN3aXRjaF90b3AgXSxcbiAgICAgICAgICAgICAgICAgICAgWyB4LXBhZGRpbmcqKGktMikqMywgY29uZHVpdF95LWJyZWFrZXJfc3BhY2luZyooaS0xKSBdLFxuICAgICAgICAgICAgICAgICAgICBbIGxvYy5BQ19sb2FkY2VudGVyLmJyZWFrZXJzLmxlZnQsIGNvbmR1aXRfeS1icmVha2VyX3NwYWNpbmcqKGktMSkgXSxcbiAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuXG5cbiAgICB9XG5cblxuXG5cbi8vIFdpcmUgdGFibGVcbiAgICBkLnNlY3Rpb24oXCJXaXJlIHRhYmxlXCIpO1xuXG4vLy8qXG5cbiAgICB4ID0gbG9jLndpcmVfdGFibGUueDtcbiAgICB5ID0gbG9jLndpcmVfdGFibGUueTtcblxuICAgIGlmKCBzeXN0ZW0uQUMubnVtX2NvbmR1Y3RvcnMgKSB7XG4gICAgICAgIHZhciBuX3Jvd3MgPSAyICsgc3lzdGVtLkFDLm51bV9jb25kdWN0b3JzO1xuICAgICAgICB2YXIgbl9jb2xzID0gNjtcbiAgICAgICAgdmFyIHJvd19oZWlnaHQgPSAxNTtcbiAgICAgICAgdmFyIGNvbHVtbl93aWR0aCA9IHtcbiAgICAgICAgICAgIG51bWJlcjogMjUsXG4gICAgICAgICAgICBjb25kdWN0b3I6IDUwLFxuICAgICAgICAgICAgd2lyZV9nYXVnZTogMjUsXG4gICAgICAgICAgICB3aXJlX3R5cGU6IDc1LFxuICAgICAgICAgICAgY29uZHVpdF9zaXplOiAzNSxcbiAgICAgICAgICAgIGNvbmR1aXRfdHlwZTogNzUsXG4gICAgICAgIH07XG5cbiAgICAgICAgaCA9IG5fcm93cypyb3dfaGVpZ2h0O1xuXG4gICAgICAgIHZhciB0ID0gZC50YWJsZShuX3Jvd3Msbl9jb2xzKS5sb2MoeCx5KTtcbiAgICAgICAgdC5yb3dfc2l6ZSgnYWxsJywgcm93X2hlaWdodClcbiAgICAgICAgICAgIC5jb2xfc2l6ZSgxLCBjb2x1bW5fd2lkdGgubnVtYmVyKVxuICAgICAgICAgICAgLmNvbF9zaXplKDIsIGNvbHVtbl93aWR0aC5jb25kdWN0b3IpXG4gICAgICAgICAgICAuY29sX3NpemUoMywgY29sdW1uX3dpZHRoLndpcmVfZ2F1Z2UpXG4gICAgICAgICAgICAuY29sX3NpemUoNCwgY29sdW1uX3dpZHRoLndpcmVfdHlwZSlcbiAgICAgICAgICAgIC5jb2xfc2l6ZSg1LCBjb2x1bW5fd2lkdGguY29uZHVpdF9zaXplKVxuICAgICAgICAgICAgLmNvbF9zaXplKDYsIGNvbHVtbl93aWR0aC5jb25kdWl0X3R5cGUpO1xuXG4gICAgICAgIHQuYWxsX2NlbGxzKCkuZm9yRWFjaChmdW5jdGlvbihjZWxsKXtcbiAgICAgICAgICAgIGNlbGwuZm9udCgndGFibGUnKS5ib3JkZXIoJ2FsbCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgdC5jZWxsKDEsMSkuYm9yZGVyKCdCJywgZmFsc2UpO1xuICAgICAgICB0LmNlbGwoMSwzKS5ib3JkZXIoJ1InLCBmYWxzZSk7XG4gICAgICAgIHQuY2VsbCgxLDUpLmJvcmRlcignUicsIGZhbHNlKTtcblxuICAgICAgICB0LmNlbGwoMSwzKS5mb250KCd0YWJsZV9sZWZ0JykudGV4dCgnV2lyZScpO1xuICAgICAgICB0LmNlbGwoMSw1KS5mb250KCd0YWJsZV9sZWZ0JykudGV4dCgnQ29uZHVpdCcpO1xuXG4gICAgICAgIHQuY2VsbCgyLDMpLmZvbnQoJ3RhYmxlJykudGV4dCgnQ29uZHVjdG9ycycpO1xuICAgICAgICB0LmNlbGwoMiwzKS5mb250KCd0YWJsZScpLnRleHQoJ0FXRycpO1xuICAgICAgICB0LmNlbGwoMiw0KS5mb250KCd0YWJsZScpLnRleHQoJ1R5cGUnKTtcbiAgICAgICAgdC5jZWxsKDIsNSkuZm9udCgndGFibGUnKS50ZXh0KCdTaXplJyk7XG4gICAgICAgIHQuY2VsbCgyLDYpLmZvbnQoJ3RhYmxlJykudGV4dCgnVHlwZScpO1xuXG4gICAgICAgIGZvciggaT0xOyBpPD1zeXN0ZW0uQUMubnVtX2NvbmR1Y3RvcnM7IGkrKyl7XG4gICAgICAgICAgICB0LmNlbGwoMitpLDEpLmZvbnQoJ3RhYmxlJykudGV4dChpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdC5jZWxsKDIraSwyKS5mb250KCd0YWJsZV9sZWZ0JykudGV4dCggZi5wcmV0dHlfd29yZChzZXR0aW5ncy5zeXN0ZW0uQUMuY29uZHVjdG9yc1tpLTFdKSApO1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vZC50ZXh0KCBbeCt3LzIsIHktcm93X2hlaWdodF0sIGYucHJldHR5X25hbWUoc2VjdGlvbl9uYW1lKSwndGFibGUnICk7XG5cblxuICAgICAgICB0Lm1rKCk7XG5cbiAgICB9XG5cbi8vKi9cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbi8vIHZvbHRhZ2UgZHJvcFxuICAgIGQuc2VjdGlvbihcInZvbHRhZ2UgZHJvcFwiKTtcblxuXG4gICAgeCA9IGxvYy52b2x0X2Ryb3BfdGFibGUueDtcbiAgICB5ID0gbG9jLnZvbHRfZHJvcF90YWJsZS55O1xuICAgIHcgPSBzaXplLnZvbHRfZHJvcF90YWJsZS53O1xuICAgIGggPSBzaXplLnZvbHRfZHJvcF90YWJsZS5oO1xuXG4gICAgZC5sYXllcigndGFibGUnKTtcbiAgICBkLnJlY3QoIFt4LHldLCBbdyxoXSApO1xuXG4gICAgeSAtPSBoLzI7XG4gICAgeSArPSAxMDtcblxuICAgIGQudGV4dCggW3gseV0sICdWb2x0YWdlIERyb3AnLCAndGV4dCcsICd0YWJsZScpO1xuXG5cbi8vIGdlbmVyYWwgbm90ZXNcbiAgICBkLnNlY3Rpb24oXCJnZW5lcmFsIG5vdGVzXCIpO1xuXG4gICAgeCA9IGxvYy5nZW5lcmFsX25vdGVzLng7XG4gICAgeSA9IGxvYy5nZW5lcmFsX25vdGVzLnk7XG4gICAgdyA9IHNpemUuZ2VuZXJhbF9ub3Rlcy53O1xuICAgIGggPSBzaXplLmdlbmVyYWxfbm90ZXMuaDtcblxuICAgIGQubGF5ZXIoJ3RhYmxlJyk7XG4gICAgZC5yZWN0KCBbeCx5XSwgW3csaF0gKTtcblxuICAgIHkgLT0gaC8yO1xuICAgIHkgKz0gMTA7XG5cbiAgICBkLnRleHQoIFt4LHldLCAnR2VuZXJhbCBOb3RlcycsICd0ZXh0JywgJ3RhYmxlJyk7XG5cblxuICAgIGQuc2VjdGlvbigpO1xuXG4gICAgcmV0dXJuIGQuZHJhd2luZ19wYXJ0cztcbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhZ2U7XG4iLCJ2YXIgbWtfZHJhd2luZyA9IHJlcXVpcmUoJy4uL21rX2RyYXdpbmcnKTtcbnZhciBta19ib3JkZXIgPSByZXF1aXJlKCcuLi9ta19ib3JkZXInKTtcblxudmFyIHBhZ2UgPSBmdW5jdGlvbihzZXR0aW5ncyl7XG4gICAgdmFyIGYgPSBzZXR0aW5ncy5mO1xuXG4gICAgZCA9IG1rX2RyYXdpbmcoc2V0dGluZ3MpO1xuXG4gICAgdmFyIHNoZWV0X3NlY3Rpb24gPSAnUFYnO1xuICAgIHZhciBzaGVldF9udW0gPSAnMDInO1xuICAgIC8vZC5hcHBlbmQobWtfYm9yZGVyKHNldHRpbmdzLCBzaGVldF9zZWN0aW9uLCBzaGVldF9udW0gKSk7XG5cbiAgICB2YXIgc2l6ZSA9IHNldHRpbmdzLmRyYXdpbmdfc2V0dGluZ3Muc2l6ZTtcbiAgICB2YXIgbG9jID0gc2V0dGluZ3MuZHJhd2luZ19zZXR0aW5ncy5sb2M7XG5cblxuICAgIGQudGV4dChcbiAgICAgICAgW3NpemUuZHJhd2luZy53LzIsIHNpemUuZHJhd2luZy5oLzJdLFxuICAgICAgICAnQ2FsY3VsYXRpb24gU2hlZXQnLFxuICAgICAgICAndGV4dCcsXG4gICAgICAgICd0aXRsZTInXG4gICAgKTtcblxuXG4gICAgeCA9IHNpemUuZHJhd2luZy5mcmFtZV9wYWRkaW5nKjY7XG4gICAgeSA9IHNpemUuZHJhd2luZy5mcmFtZV9wYWRkaW5nKjYgKzIwO1xuXG4gICAgZC5sYXllcigndGFibGUnKTtcblxuXG4gICAgZm9yKCB2YXIgc2VjdGlvbl9uYW1lIGluIHNldHRpbmdzLnN5c3RlbSApe1xuICAgICAgICBpZiggZi5zZWN0aW9uX2RlZmluZWQoc2V0dGluZ3MsIHNlY3Rpb25fbmFtZSkgKXtcbiAgICAgICAgICAgIHZhciBzZWN0aW9uID0gc2V0dGluZ3Muc3lzdGVtW3NlY3Rpb25fbmFtZV07XG5cbiAgICAgICAgICAgIHZhciBuID0gT2JqZWN0LmtleXMoc2VjdGlvbikubGVuZ3RoO1xuXG4gICAgICAgICAgICB2YXIgbl9yb3dzID0gbiswO1xuICAgICAgICAgICAgdmFyIG5fY29scyA9IDI7XG5cbiAgICAgICAgICAgIHZhciByb3dfaGVpZ2h0ID0gMTU7XG4gICAgICAgICAgICBoID0gbl9yb3dzKnJvd19oZWlnaHQ7XG5cblxuICAgICAgICAgICAgdmFyIHQgPSBkLnRhYmxlKG5fcm93cyxuX2NvbHMpLmxvYyh4LHkpO1xuICAgICAgICAgICAgdC5yb3dfc2l6ZSgnYWxsJywgcm93X2hlaWdodCkuY29sX3NpemUoMSwgMTAwKS5jb2xfc2l6ZSgyLCAxMjUpO1xuICAgICAgICAgICAgdyA9IDEwMCs4MDtcblxuICAgICAgICAgICAgdmFyIHIgPSAxO1xuICAgICAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICAgICAgZm9yKCB2YXIgdmFsdWVfbmFtZSBpbiBzZWN0aW9uICl7XG4gICAgICAgICAgICAgICAgdC5jZWxsKHIsMSkudGV4dCggZi5wcmV0dHlfbmFtZSh2YWx1ZV9uYW1lKSApO1xuICAgICAgICAgICAgICAgIGlmKCAhIHNlY3Rpb25bdmFsdWVfbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnLSc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKCBzZWN0aW9uW3ZhbHVlX25hbWVdLmNvbnN0cnVjdG9yID09PSBBcnJheSApe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHNlY3Rpb25bdmFsdWVfbmFtZV0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYoIHNlY3Rpb25bdmFsdWVfbmFtZV0uY29uc3RydWN0b3IgPT09IE9iamVjdCApe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICcoICknO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiggaXNOYU4oc2VjdGlvblt2YWx1ZV9uYW1lXSkgKXtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZWN0aW9uW3ZhbHVlX25hbWVdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdChzZWN0aW9uW3ZhbHVlX25hbWVdKS50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0LmNlbGwociwyKS50ZXh0KCB2YWx1ZSApO1xuICAgICAgICAgICAgICAgIHIrKztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkLnRleHQoIFt4K3cvMiwgeS1yb3dfaGVpZ2h0XSwgZi5wcmV0dHlfbmFtZShzZWN0aW9uX25hbWUpLCd0YWJsZScgKTtcblxuXG5cblxuICAgICAgICAgICAgdC5hbGxfY2VsbHMoKS5mb3JFYWNoKGZ1bmN0aW9uKGNlbGwpe1xuICAgICAgICAgICAgICAgIGNlbGwuZm9udCgndGFibGUnKS5ib3JkZXIoJ2FsbCcpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHQubWsoKTtcblxuICAgICAgICAgICAgLy8qL1xuICAgICAgICAgICAgeSArPSBoICsgMzA7XG5cbiAgICAgICAgICAgIGlmKCB5ID4gKCBzZXR0aW5ncy5kcmF3aW5nX3NldHRpbmdzLnNpemUuZHJhd2luZy5oICogMC44ICkgKSB7XG4gICAgICAgICAgICAgICAgeSA9XG4gICAgICAgICAgICAgICAgICAgIHkgPSBzaXplLmRyYXdpbmcuZnJhbWVfcGFkZGluZyo2ICsyMDtcbiAgICAgICAgICAgICAgICAgICAgeCArPSB3KjEuNTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdub3QgZGVmaW5lZDogJywgc2VjdGlvbl9uYW1lLCBzZWN0aW9uKTtcbiAgICAgICAgfVxuXG5cblxuXG4gICAgfVxuXG4gICAgZC5sYXllcigpO1xuXG5cbiAgICByZXR1cm4gZC5kcmF3aW5nX3BhcnRzO1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gcGFnZTtcbiIsInZhciBta19kcmF3aW5nID0gcmVxdWlyZSgnLi4vbWtfZHJhd2luZycpO1xudmFyIG1rX2JvcmRlciA9IHJlcXVpcmUoJy4uL21rX2JvcmRlcicpO1xudmFyIGYgPSByZXF1aXJlKCcuLi9mdW5jdGlvbnMnKTtcblxudmFyIHBhZ2UgPSBmdW5jdGlvbihzZXR0aW5ncyl7XG4gICAgY29uc29sZS5sb2coXCIqKiBNYWtpbmcgcHJldmlldyAxXCIpO1xuXG4gICAgdmFyIGQgPSBta19kcmF3aW5nKHNldHRpbmdzKTtcblxuXG5cbiAgICB2YXIgc2l6ZSA9IHNldHRpbmdzLmRyYXdpbmdfc2V0dGluZ3Muc2l6ZTtcbiAgICB2YXIgbG9jID0gc2V0dGluZ3MuZHJhd2luZ19zZXR0aW5ncy5sb2M7XG4gICAgdmFyIHN5c3RlbSA9IHNldHRpbmdzLnN5c3RlbTtcblxuICAgIHZhciB4LCB5LCBoLCB3LCBzZWN0aW9uX3gsIHNlY3Rpb25feTtcblxuICAgIHcgPSBzaXplLnByZXZpZXcubW9kdWxlLnc7XG4gICAgaCA9IHNpemUucHJldmlldy5tb2R1bGUuaDtcbiAgICBsb2MucHJldmlldy5hcnJheS5ib3R0b20gPSBsb2MucHJldmlldy5hcnJheS50b3AgKyBoKjEuMjUqc3lzdGVtLmFycmF5Lm1vZHVsZXNfcGVyX3N0cmluZyArIGgqMy80O1xuICAgIC8vbG9jLnByZXZpZXcuYXJyYXkucmlnaHQgPSBsb2MucHJldmlldy5hcnJheS5sZWZ0ICsgdyoxLjI1KnN5c3RlbS5hcnJheS5udW1fc3RyaW5ncyArIHcqMjtcbiAgICBsb2MucHJldmlldy5hcnJheS5yaWdodCA9IGxvYy5wcmV2aWV3LmFycmF5LmxlZnQgKyB3KjEuMjUqOCArIHcqMjtcblxuICAgIGxvYy5wcmV2aWV3LmludmVydGVyLmNlbnRlciA9IDUwMCA7XG4gICAgdyA9IHNpemUucHJldmlldy5pbnZlcnRlci53O1xuICAgIGxvYy5wcmV2aWV3LmludmVydGVyLmxlZnQgPSBsb2MucHJldmlldy5pbnZlcnRlci5jZW50ZXIgLSB3LzI7XG4gICAgbG9jLnByZXZpZXcuaW52ZXJ0ZXIucmlnaHQgPSBsb2MucHJldmlldy5pbnZlcnRlci5jZW50ZXIgKyB3LzI7XG5cbiAgICBsb2MucHJldmlldy5EQy5sZWZ0ID0gbG9jLnByZXZpZXcuYXJyYXkucmlnaHQ7XG4gICAgbG9jLnByZXZpZXcuREMucmlnaHQgPSBsb2MucHJldmlldy5pbnZlcnRlci5sZWZ0O1xuICAgIGxvYy5wcmV2aWV3LkRDLmNlbnRlciA9ICggbG9jLnByZXZpZXcuREMucmlnaHQgKyBsb2MucHJldmlldy5EQy5sZWZ0ICkvMjtcblxuICAgIGxvYy5wcmV2aWV3LkFDLmxlZnQgPSBsb2MucHJldmlldy5pbnZlcnRlci5yaWdodDtcbiAgICBsb2MucHJldmlldy5BQy5yaWdodCA9IGxvYy5wcmV2aWV3LkFDLmxlZnQgKyAzMDA7XG4gICAgbG9jLnByZXZpZXcuQUMuY2VudGVyID0gKCBsb2MucHJldmlldy5BQy5yaWdodCArIGxvYy5wcmV2aWV3LkFDLmxlZnQgKS8yO1xuXG5cbi8vIFRPRE8gZml4OiBzZWN0aW9ucyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIsIG9yIHRoZXJlIGFyZSBhcmVhc1xuXG4gICAgaWYoIGYuc2VjdGlvbl9kZWZpbmVkKHNldHRpbmdzLCAnYXJyYXknKSAmJiBmLnNlY3Rpb25fZGVmaW5lZChzZXR0aW5ncywgJ21vZHVsZScpICl7XG4gICAgICAgIGQubGF5ZXIoJ3ByZXZpZXdfYXJyYXknKTtcblxuICAgICAgICB3ID0gc2l6ZS5wcmV2aWV3Lm1vZHVsZS53O1xuICAgICAgICBoID0gc2l6ZS5wcmV2aWV3Lm1vZHVsZS5oO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gNDA7XG5cbiAgICAgICAgZm9yKCB2YXIgcz0wOyBzPHN5c3RlbS5hcnJheS5udW1fc3RyaW5nczsgcysrICl7XG4gICAgICAgICAgICB4ID0gbG9jLnByZXZpZXcuYXJyYXkubGVmdCArIHcqMS4yNSpzO1xuICAgICAgICAgICAgLy8gc3RyaW5nIHdpcmluZ1xuICAgICAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgICAgICAgICAgWyB4ICwgbG9jLnByZXZpZXcuYXJyYXkudG9wIF0sXG4gICAgICAgICAgICAgICAgICAgIFsgeCAsIGxvYy5wcmV2aWV3LmFycmF5LmJvdHRvbSBdLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBtb2R1bGVzXG4gICAgICAgICAgICBmb3IoIHZhciBtPTA7IG08c3lzdGVtLmFycmF5Lm1vZHVsZXNfcGVyX3N0cmluZzsgbSsrICl7XG4gICAgICAgICAgICAgICAgeSA9IGxvYy5wcmV2aWV3LmFycmF5LnRvcCArIGggKyBoKjEuMjUqbTtcbiAgICAgICAgICAgICAgICAvLyBtb2R1bGVzXG4gICAgICAgICAgICAgICAgZC5yZWN0KFxuICAgICAgICAgICAgICAgICAgICBbIHggLCB5IF0sXG4gICAgICAgICAgICAgICAgICAgIFt3LGhdLFxuICAgICAgICAgICAgICAgICAgICAncHJldmlld19tb2R1bGUnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvcCBhcnJheSBjb25kdWl0XG4gICAgICAgIGQubGluZShbXG4gICAgICAgICAgICAgICAgWyBsb2MucHJldmlldy5hcnJheS5sZWZ0ICwgbG9jLnByZXZpZXcuYXJyYXkudG9wIF0sXG4gICAgICAgICAgICAgICAgWyBsb2MucHJldmlldy5hcnJheS5yaWdodCAtIHcsIGxvYy5wcmV2aWV3LmFycmF5LnRvcCBdLFxuICAgICAgICAgICAgICAgIFsgbG9jLnByZXZpZXcuYXJyYXkucmlnaHQgLCBsb2MucHJldmlldy5hcnJheS50b3AgXSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgKTtcbiAgICAgICAgLy8gYm90dG9tIGFycmF5IGNvbmR1aXRcbiAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgICAgICBbIGxvYy5wcmV2aWV3LmFycmF5LmxlZnQgLCBsb2MucHJldmlldy5hcnJheS5ib3R0b20gXSxcbiAgICAgICAgICAgICAgICBbIGxvYy5wcmV2aWV3LmFycmF5LnJpZ2h0IC0gdyAsIGxvYy5wcmV2aWV3LmFycmF5LmJvdHRvbSBdLFxuICAgICAgICAgICAgICAgIFsgbG9jLnByZXZpZXcuYXJyYXkucmlnaHQgLSB3ICwgbG9jLnByZXZpZXcuYXJyYXkudG9wIF0sXG4gICAgICAgICAgICBdXG4gICAgICAgICk7XG5cbiAgICAgICAgeSA9IGxvYy5wcmV2aWV3LmFycmF5LnRvcDtcbiAgICAgICAgaCA9IHNpemUucHJldmlldy5tb2R1bGUuaDtcblxuICAgICAgICBkLnRleHQoXG4gICAgICAgICAgICBbIGxvYy5wcmV2aWV3LkRDLmNlbnRlciwgeStoLzIrb2Zmc2V0IF0sXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ0FycmF5IERDJyxcbiAgICAgICAgICAgICAgICAnU3RyaW5nczogJyArIHBhcnNlRmxvYXQoc3lzdGVtLmFycmF5Lm51bV9zdHJpbmdzKS50b0ZpeGVkKCksXG4gICAgICAgICAgICAgICAgJ01vZHVsZXM6ICcgKyBwYXJzZUZsb2F0KHN5c3RlbS5hcnJheS5tb2R1bGVzX3Blcl9zdHJpbmcpLnRvRml4ZWQoKSxcbiAgICAgICAgICAgICAgICAnUG1wOiAnICsgcGFyc2VGbG9hdChzeXN0ZW0uYXJyYXkucG1wKS50b0ZpeGVkKCksXG4gICAgICAgICAgICAgICAgJ0ltcDogJyArIHBhcnNlRmxvYXQoc3lzdGVtLmFycmF5LmltcCkudG9GaXhlZCgpLFxuICAgICAgICAgICAgICAgICdWbXA6ICcgKyBwYXJzZUZsb2F0KHN5c3RlbS5hcnJheS52bXApLnRvRml4ZWQoKSxcbiAgICAgICAgICAgICAgICAnSXNjOiAnICsgcGFyc2VGbG9hdChzeXN0ZW0uYXJyYXkuaXNjKS50b0ZpeGVkKCksXG4gICAgICAgICAgICAgICAgJ1ZvYzogJyArIHBhcnNlRmxvYXQoc3lzdGVtLmFycmF5LnZvYykudG9GaXhlZCgpLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgICdwcmV2aWV3IHRleHQnXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYoIGYuc2VjdGlvbl9kZWZpbmVkKHNldHRpbmdzLCAnREMnKSApe1xuICAgICAgICBkLmxheWVyKCdwcmV2aWV3X0RDJyk7XG5cbiAgICAgICAgLy95ID0geTtcbiAgICAgICAgeSA9IGxvYy5wcmV2aWV3LmFycmF5LnRvcDtcbiAgICAgICAgdyA9IHNpemUucHJldmlldy5tb2R1bGUudztcbiAgICAgICAgaCA9IHNpemUucHJldmlldy5tb2R1bGUuaDtcblxuICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgICAgIFsgbG9jLnByZXZpZXcuREMubGVmdCAsIHkgXSxcbiAgICAgICAgICAgICAgICBbIGxvYy5wcmV2aWV3LkRDLnJpZ2h0LCB5IF0sXG4gICAgICAgICAgICBdXG4gICAgICAgICk7XG4gICAgICAgIGQucmVjdChcbiAgICAgICAgICAgIFtsb2MucHJldmlldy5EQy5jZW50ZXIseV0sXG4gICAgICAgICAgICBbdyxoXSxcbiAgICAgICAgICAgICdwcmV2aWV3X0RDX2JveCdcbiAgICAgICAgKTtcblxuICAgIH1cblxuICAgIGlmKCBmLnNlY3Rpb25fZGVmaW5lZChzZXR0aW5ncywgJ2ludmVydGVyJykgKXtcblxuICAgICAgICBkLmxheWVyKCdwcmV2aWV3X2ludmVydGVyJyk7XG5cbiAgICAgICAgeSA9IHk7XG4gICAgICAgIHcgPSBzaXplLnByZXZpZXcuaW52ZXJ0ZXIudztcbiAgICAgICAgaCA9IHNpemUucHJldmlldy5pbnZlcnRlci5oO1xuXG4gICAgICAgIGQucmVjdChcbiAgICAgICAgICAgIFtsb2MucHJldmlldy5pbnZlcnRlci5jZW50ZXIseV0sXG4gICAgICAgICAgICBbdyxoXSxcbiAgICAgICAgICAgICdwcmV2aWV3X2ludmVydGVyX2JveCdcbiAgICAgICAgKTtcbiAgICAgICAgZC50ZXh0KFxuICAgICAgICAgICAgW2xvYy5wcmV2aWV3LmludmVydGVyLmNlbnRlcix5K2gvMitvZmZzZXRdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdJbnZlcnRlcicsXG4gICAgICAgICAgICAgICAgc3lzdGVtLmludmVydGVyLm1ha2UsXG4gICAgICAgICAgICAgICAgc3lzdGVtLmludmVydGVyLm1vZGVsLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICd0ZXh0JyxcbiAgICAgICAgICAgICdwcmV2aWV3IHRleHQnXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYoIGYuc2VjdGlvbl9kZWZpbmVkKHNldHRpbmdzLCAnQUMnKSApe1xuXG4gICAgICAgIGQubGF5ZXIoJ3ByZXZpZXdfQUMnKTtcblxuXG4gICAgICAgIHkgPSB5O1xuICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgICAgIFsgbG9jLnByZXZpZXcuQUMubGVmdCwgeSBdLFxuICAgICAgICAgICAgICAgIFsgbG9jLnByZXZpZXcuQUMucmlnaHQsIHkgXSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgKTtcbiAgICAgICAgdyA9IHNpemUucHJldmlldy5BQy53O1xuICAgICAgICBoID0gc2l6ZS5wcmV2aWV3LkFDLmg7XG4gICAgICAgIGQucmVjdChcbiAgICAgICAgICAgIFtsb2MucHJldmlldy5BQy5jZW50ZXIseV0sXG4gICAgICAgICAgICBbdyxoXSxcbiAgICAgICAgICAgICdwcmV2aWV3X0FDX2JveCdcbiAgICAgICAgKTtcbiAgICAgICAgdyA9IHNpemUucHJldmlldy5sb2FkY2VudGVyLnc7XG4gICAgICAgIGggPSBzaXplLnByZXZpZXcubG9hZGNlbnRlci5oO1xuICAgICAgICBkLnJlY3QoXG4gICAgICAgICAgICBbIGxvYy5wcmV2aWV3LkFDLnJpZ2h0LXcvMiwgeStoLzQgXSxcbiAgICAgICAgICAgIFt3LGhdLFxuICAgICAgICAgICAgJ3ByZXZpZXdfQUNfYm94J1xuICAgICAgICApO1xuXG4gICAgICAgIGQudGV4dChcbiAgICAgICAgICAgIFtsb2MucHJldmlldy5BQy5jZW50ZXIseStoLzIrb2Zmc2V0XSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnQUMnLFxuXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgJ3ByZXZpZXcgdGV4dCdcbiAgICAgICAgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBkLmRyYXdpbmdfcGFydHM7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBwYWdlO1xuIiwidmFyIG1rX2RyYXdpbmcgPSByZXF1aXJlKCcuLi9ta19kcmF3aW5nJyk7XG52YXIgbWtfYm9yZGVyID0gcmVxdWlyZSgnLi4vbWtfYm9yZGVyJyk7XG52YXIgZiA9IHJlcXVpcmUoJy4uL2Z1bmN0aW9ucycpO1xuXG52YXIgcGFnZSA9IGZ1bmN0aW9uKHNldHRpbmdzKXtcbiAgICBjb25zb2xlLmxvZyhcIioqIE1ha2luZyBwcmV2aWV3IDJcIik7XG5cbiAgICB2YXIgZCA9IG1rX2RyYXdpbmcoc2V0dGluZ3MpO1xuXG4gICAgaWYoIGYuc2VjdGlvbl9kZWZpbmVkKHNldHRpbmdzLCAncm9vZicpICl7XG5cbiAgICAgICAgdmFyIHNpemUgPSBzZXR0aW5ncy5kcmF3aW5nX3NldHRpbmdzLnNpemU7XG4gICAgICAgIHZhciBsb2MgPSBzZXR0aW5ncy5kcmF3aW5nX3NldHRpbmdzLmxvYztcbiAgICAgICAgdmFyIHN5c3RlbSA9IHNldHRpbmdzLnN5c3RlbTtcblxuICAgICAgICB2YXIgeCwgeSwgaCwgdywgc2VjdGlvbl94LCBzZWN0aW9uX3ksIGxlbmd0aF9wLCBzY2FsZTtcblxuICAgICAgICB2YXIgc2xvcGUgPSBzeXN0ZW0ucm9vZi5zbG9wZS5zcGxpdCgnOicpWzBdO1xuICAgICAgICB2YXIgYW5nbGVfcmFkID0gTWF0aC5hdGFuKCBOdW1iZXIoc2xvcGUpIC8xMiApO1xuICAgICAgICAvL2FuZ2xlX3JhZCA9IGFuZ2xlICogKE1hdGguUEkvMTgwKTtcblxuXG4gICAgICAgIGxlbmd0aF9wID0gc3lzdGVtLnJvb2YubGVuZ3RoICogTWF0aC5jb3MoYW5nbGVfcmFkKTtcbiAgICAgICAgc3lzdGVtLnJvb2YuaGVpZ2h0ID0gc3lzdGVtLnJvb2YubGVuZ3RoICogTWF0aC5zaW4oYW5nbGVfcmFkKTtcblxuICAgICAgICB2YXIgcm9vZl9yYXRpbyA9IHN5c3RlbS5yb29mLmxlbmd0aCAvIHN5c3RlbS5yb29mLndpZHRoO1xuICAgICAgICB2YXIgcm9vZl9wbGFuX3JhdGlvID0gbGVuZ3RoX3AgLyBzeXN0ZW0ucm9vZi53aWR0aDtcblxuXG4gICAgICAgIGlmKCBzeXN0ZW0ucm9vZi50eXBlID09PSBcIkdhYmxlXCIpe1xuXG5cbiAgICAgICAgICAgIC8vLy8vLy9cbiAgICAgICAgICAgIC8vIFJvb2QgcGxhbiB2aWV3XG4gICAgICAgICAgICB2YXIgcGxhbl94ID0gMzA7XG4gICAgICAgICAgICB2YXIgcGxhbl95ID0gMzA7XG5cbiAgICAgICAgICAgIHZhciBwbGFuX3csIHBsYW5faDtcbiAgICAgICAgICAgIGlmKCBsZW5ndGhfcCoyID4gc3lzdGVtLnJvb2Yud2lkdGggKXtcbiAgICAgICAgICAgICAgICBzY2FsZSA9IDI1MC8obGVuZ3RoX3AqMik7XG4gICAgICAgICAgICAgICAgcGxhbl93ID0gKGxlbmd0aF9wKjIpICogc2NhbGU7XG4gICAgICAgICAgICAgICAgcGxhbl9oID0gcGxhbl93IC8gKGxlbmd0aF9wKjIgLyBzeXN0ZW0ucm9vZi53aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYWxlID0gNDAwLyhzeXN0ZW0ucm9vZi53aWR0aCk7XG4gICAgICAgICAgICAgICAgcGxhbl9oID0gc3lzdGVtLnJvb2Yud2lkdGggKiBzY2FsZTtcbiAgICAgICAgICAgICAgICBwbGFuX3cgPSBwbGFuX2ggKiAobGVuZ3RoX3AqMiAvIHN5c3RlbS5yb29mLndpZHRoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZC5yZWN0KFxuICAgICAgICAgICAgICAgIFtwbGFuX3grcGxhbl93LzIsIHBsYW5feStwbGFuX2gvMl0sXG4gICAgICAgICAgICAgICAgW3BsYW5fdywgcGxhbl9oXSxcbiAgICAgICAgICAgICAgICBcInByZXZpZXdfc3RydWN0dXJhbFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBkLnBvbHkoW1xuICAgICAgICAgICAgICAgICAgICBbcGxhbl94ICAgICAgICwgcGxhbl95XSxcbiAgICAgICAgICAgICAgICAgICAgW3BsYW5feCtwbGFuX3cvMiwgcGxhbl95XSxcbiAgICAgICAgICAgICAgICAgICAgW3BsYW5feCtwbGFuX3cvMiwgcGxhbl95K3BsYW5faF0sXG4gICAgICAgICAgICAgICAgICAgIFtwbGFuX3gsICAgICAgICBwbGFuX3krcGxhbl9oXSxcbiAgICAgICAgICAgICAgICAgICAgW3BsYW5feCAgICAgICAsIHBsYW5feV0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcInByZXZpZXdfc3RydWN0dXJhbF9wb2x5X3Vuc2VsZWN0ZWRcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGQucG9seShbXG4gICAgICAgICAgICAgICAgICAgIFtwbGFuX3grcGxhbl93LzIgICAgICAgLCBwbGFuX3ldLFxuICAgICAgICAgICAgICAgICAgICBbcGxhbl94K3BsYW5fdy8yK3BsYW5fdy8yLCBwbGFuX3ldLFxuICAgICAgICAgICAgICAgICAgICBbcGxhbl94K3BsYW5fdy8yK3BsYW5fdy8yLCBwbGFuX3krcGxhbl9oXSxcbiAgICAgICAgICAgICAgICAgICAgW3BsYW5feCtwbGFuX3cvMiwgICAgICAgIHBsYW5feStwbGFuX2hdLFxuICAgICAgICAgICAgICAgICAgICBbcGxhbl94K3BsYW5fdy8yICAgICAgICwgcGxhbl95XSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwicHJldmlld19zdHJ1Y3R1cmFsX3BvbHlfc2VsZWN0ZWRcIlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgICAgICAgICAgW3BsYW5feCtwbGFuX3cvMiwgcGxhbl95XSxcbiAgICAgICAgICAgICAgICAgICAgW3BsYW5feCtwbGFuX3cvMiwgcGxhbl95K3BsYW5faF1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwicHJldmlld19zdHJ1Y3R1cmFsX2RvdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgZC50ZXh0KFxuICAgICAgICAgICAgICAgIFtwbGFuX3gtMjAsIHBsYW5feStwbGFuX2gvMl0sXG4gICAgICAgICAgICAgICAgc3lzdGVtLnJvb2YubGVuZ3RoLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgJ2RpbWVudGlvbidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICBkLnRleHQoXG4gICAgICAgICAgICAgICAgW3BsYW5feCtwbGFuX3crMjAsIHBsYW5feStwbGFuX2gvMl0sXG4gICAgICAgICAgICAgICAgc3lzdGVtLnJvb2Yud2lkdGgudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAnZGltZW50aW9uJ1xuICAgICAgICAgICAgKTtcblxuXG5cblxuICAgICAgICAgICAgLy8vLy8vLy9cbiAgICAgICAgICAgIC8vIHJvb2YgY3Jvc3NlY3Rpb25cblxuICAgICAgICAgICAgdmFyIGNzX3ggPSAzMDtcbiAgICAgICAgICAgIHZhciBjc195ID0gMzArcGxhbl9oKzUwO1xuICAgICAgICAgICAgdmFyIGNzX2ggPSBzeXN0ZW0ucm9vZi5oZWlnaHQgKiBzY2FsZTtcbiAgICAgICAgICAgIHZhciBjc193ID0gcGxhbl93LzI7XG5cbiAgICAgICAgICAgIGQubGluZShbXG4gICAgICAgICAgICAgICAgICAgIFtjc194K2NzX3csICAgY3NfeV0sXG4gICAgICAgICAgICAgICAgICAgIFtjc194K2NzX3csICAgY3NfeStjc19oXSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwicHJldmlld19zdHJ1Y3R1cmFsX2RvdFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgICAgICAgICAgW2NzX3grY3NfdywgICBjc195XSxcbiAgICAgICAgICAgICAgICAgICAgW2NzX3grY3NfdyoyLCBjc195K2NzX2hdLFxuICAgICAgICAgICAgICAgICAgICBbY3NfeCwgICAgICAgIGNzX3krY3NfaF0sXG4gICAgICAgICAgICAgICAgICAgIFtjc194K2NzX3csICAgY3NfeV0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcInByZXZpZXdfc3RydWN0dXJhbFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZC50ZXh0KFxuICAgICAgICAgICAgICAgIFtjc194K2NzX3ctMTUsIGNzX3krY3NfaCoyLzNdLFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoIHN5c3RlbS5yb29mLmhlaWdodCApLnRvRml4ZWQoKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICdkaW1lbnRpb24nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZC50ZXh0KFxuICAgICAgICAgICAgICAgIFtjc194K2NzX3cqMS41KzIwLCBjc195K2NzX2gvM10sXG4gICAgICAgICAgICAgICAgcGFyc2VGbG9hdCggc3lzdGVtLnJvb2YubGVuZ3RoICkudG9GaXhlZCgpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgJ2RpbWVudGlvbidcbiAgICAgICAgICAgICk7XG5cblxuXG4gICAgICAgICAgICAvLy8vLy9cbiAgICAgICAgICAgIC8vIHJvb2YgZGV0YWlsXG5cbiAgICAgICAgICAgIHZhciBkZXRhaWxfeCA9IDMwKzQ1MDtcbiAgICAgICAgICAgIHZhciBkZXRhaWxfeSA9IDMwO1xuXG4gICAgICAgICAgICBpZiggTnVtYmVyKHN5c3RlbS5yb29mLndpZHRoKSA+PSBOdW1iZXIoc3lzdGVtLnJvb2YubGVuZ3RoKSApe1xuICAgICAgICAgICAgICAgIHNjYWxlID0gNDUwLyhzeXN0ZW0ucm9vZi53aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYWxlID0gNDUwLyhzeXN0ZW0ucm9vZi5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRldGFpbF93ID0gc3lzdGVtLnJvb2Yud2lkdGggKiBzY2FsZTtcbiAgICAgICAgICAgIHZhciBkZXRhaWxfaCA9IHN5c3RlbS5yb29mLmxlbmd0aCAqIHNjYWxlO1xuXG4gICAgICAgICAgICBkLnJlY3QoXG4gICAgICAgICAgICAgICAgW2RldGFpbF94K2RldGFpbF93LzIsIGRldGFpbF95K2RldGFpbF9oLzJdLFxuICAgICAgICAgICAgICAgIFtkZXRhaWxfdywgZGV0YWlsX2hdLFxuICAgICAgICAgICAgICAgIFwicHJldmlld19zdHJ1Y3R1cmFsX3BvbHlfc2VsZWN0ZWRfZnJhbWVkXCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHZhciBhID0gMztcbiAgICAgICAgICAgIHZhciBvZmZzZXRfYSA9IGEgKiBzY2FsZTtcblxuICAgICAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgICAgICAgICAgW2RldGFpbF94LCAgIGRldGFpbF95K29mZnNldF9hXSxcbiAgICAgICAgICAgICAgICAgICAgW2RldGFpbF94K2RldGFpbF93LCAgIGRldGFpbF95K29mZnNldF9hXSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwicHJldmlld19zdHJ1Y3R1cmFsX2RvdFwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgICAgICAgICAgW2RldGFpbF94LCAgICAgICAgICBkZXRhaWxfeStkZXRhaWxfaC1vZmZzZXRfYV0sXG4gICAgICAgICAgICAgICAgICAgIFtkZXRhaWxfeCtkZXRhaWxfdywgZGV0YWlsX3krZGV0YWlsX2gtb2Zmc2V0X2FdLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJwcmV2aWV3X3N0cnVjdHVyYWxfZG90XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkLmxpbmUoW1xuICAgICAgICAgICAgICAgICAgICBbZGV0YWlsX3grb2Zmc2V0X2EsIGRldGFpbF95XSxcbiAgICAgICAgICAgICAgICAgICAgW2RldGFpbF94K29mZnNldF9hLCBkZXRhaWxfeStkZXRhaWxfaF0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBcInByZXZpZXdfc3RydWN0dXJhbF9kb3RcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGQubGluZShbXG4gICAgICAgICAgICAgICAgICAgIFtkZXRhaWxfeCtkZXRhaWxfdy1vZmZzZXRfYSwgZGV0YWlsX3ldLFxuICAgICAgICAgICAgICAgICAgICBbZGV0YWlsX3grZGV0YWlsX3ctb2Zmc2V0X2EsIGRldGFpbF95K2RldGFpbF9oXSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwicHJldmlld19zdHJ1Y3R1cmFsX2RvdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBkLnRleHQoXG4gICAgICAgICAgICAgICAgW2RldGFpbF94LTQwLCBkZXRhaWxfeStkZXRhaWxfaC8yXSxcbiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KCBzeXN0ZW0ucm9vZi5sZW5ndGggKS50b0ZpeGVkKCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAnZGltZW50aW9uJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGQudGV4dChcbiAgICAgICAgICAgICAgICBbZGV0YWlsX3grZGV0YWlsX3cvMiwgZGV0YWlsX3krZGV0YWlsX2grNDBdLFxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoIHN5c3RlbS5yb29mLndpZHRoICkudG9GaXhlZCgpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgJ2RpbWVudGlvbidcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGQudGV4dChcbiAgICAgICAgICAgICAgICBbZGV0YWlsX3grIChvZmZzZXRfYSkvMiwgZGV0YWlsX3krZGV0YWlsX2grMTVdLFxuICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICAnZGltZW50aW9uJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGQudGV4dChcbiAgICAgICAgICAgICAgICBbZGV0YWlsX3grZGV0YWlsX3ctKG9mZnNldF9hKS8yLCBkZXRhaWxfeStkZXRhaWxfaCsxNV0sXG4gICAgICAgICAgICAgICAgJ2EnLFxuICAgICAgICAgICAgICAgICdkaW1lbnRpb24nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZC50ZXh0KFxuICAgICAgICAgICAgICAgIFtkZXRhaWxfeC0xNSwgZGV0YWlsX3krZGV0YWlsX2gtKG9mZnNldF9hKS8yXSxcbiAgICAgICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAgICAgJ2RpbWVudGlvbidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkLnRleHQoXG4gICAgICAgICAgICAgICAgW2RldGFpbF94LTE1LCBkZXRhaWxfeSsob2Zmc2V0X2EpLzJdLFxuICAgICAgICAgICAgICAgICdhJyxcbiAgICAgICAgICAgICAgICAnZGltZW50aW9uJ1xuICAgICAgICAgICAgKTtcblxuXG5cblxuXG4gICAgICAgICAgICAvLy8vLy9cbiAgICAgICAgICAgIC8vIE1vZHVsZSBvcHRpb25zXG4gICAgICAgICAgICBpZiggZi5zZWN0aW9uX2RlZmluZWQoc2V0dGluZ3MsICdtb2R1bGUnKSAmJiBmLnNlY3Rpb25fZGVmaW5lZChzZXR0aW5ncywgJ2FycmF5Jykpe1xuICAgICAgICAgICAgICAgIHZhciByLGM7XG5cbiAgICAgICAgICAgICAgICB2YXIgcm9vZl9sZW5ndGhfYXZhaWwgPSBzeXN0ZW0ucm9vZi5sZW5ndGggLSAoYSoyKTtcbiAgICAgICAgICAgICAgICB2YXIgcm9vZl93aWR0aF9hdmFpbCA9IHN5c3RlbS5yb29mLndpZHRoIC0gKGEqMik7XG5cbiAgICAgICAgICAgICAgICB2YXIgcm93X3NwYWNpbmc7XG4gICAgICAgICAgICAgICAgaWYoIHN5c3RlbS5tb2R1bGUub3JpZW50YXRpb24gPT09ICdQb3J0cmFpdCcgKXtcbiAgICAgICAgICAgICAgICAgICAgcm93X3NwYWNpbmcgPSBOdW1iZXIoc3lzdGVtLm1vZHVsZS5sZW5ndGgpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgY29sX3NwYWNpbmcgPSBOdW1iZXIoc3lzdGVtLm1vZHVsZS53aWR0aCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVfdyA9IChOdW1iZXIoc3lzdGVtLm1vZHVsZS53aWR0aCkgICkvMTI7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZV9oID0gKE51bWJlcihzeXN0ZW0ubW9kdWxlLmxlbmd0aCkgKS8xMjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb3dfc3BhY2luZyA9IE51bWJlcihzeXN0ZW0ubW9kdWxlLndpZHRoKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGNvbF9zcGFjaW5nID0gTnVtYmVyKHN5c3RlbS5tb2R1bGUubGVuZ3RoKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIG1vZHVsZV93ID0gKE51bWJlcihzeXN0ZW0ubW9kdWxlLmxlbmd0aCkpLzEyO1xuICAgICAgICAgICAgICAgICAgICBtb2R1bGVfaCA9IChOdW1iZXIoc3lzdGVtLm1vZHVsZS53aWR0aCkgKS8xMjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByb3dfc3BhY2luZyA9IHJvd19zcGFjaW5nLzEyOyAvL21vZHVsZSBkaW1lbnRpb25zIGFyZSBpbiBpbmNoZXNcbiAgICAgICAgICAgICAgICBjb2xfc3BhY2luZyA9IGNvbF9zcGFjaW5nLzEyOyAvL21vZHVsZSBkaW1lbnRpb25zIGFyZSBpbiBpbmNoZXNcblxuICAgICAgICAgICAgICAgIHZhciBudW1fcm93cyA9IE1hdGguZmxvb3Iocm9vZl9sZW5ndGhfYXZhaWwvcm93X3NwYWNpbmcpO1xuICAgICAgICAgICAgICAgIHZhciBudW1fY29scyA9IE1hdGguZmxvb3Iocm9vZl93aWR0aF9hdmFpbC9jb2xfc3BhY2luZyk7XG5cbiAgICAgICAgICAgICAgICAvL3NlbGVjdGVkIG1vZHVsZXNcblxuICAgICAgICAgICAgICAgIGlmKCBudW1fY29scyAhPT0gc2V0dGluZ3MudGVtcC5udW1fY29scyB8fCBudW1fcm93cyAhPT0gc2V0dGluZ3MudGVtcC5udW1fcm93cyApe1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy53ZWJwYWdlLnNlbGVjdGVkX21vZHVsZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mud2VicGFnZS5zZWxlY3RlZF9tb2R1bGVzX3RvdGFsID0gMDtcblxuICAgICAgICAgICAgICAgICAgICBmb3IoIHI9MTsgcjw9bnVtX3Jvd3M7IHIrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy53ZWJwYWdlLnNlbGVjdGVkX21vZHVsZXNbcl0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciggYz0xOyBjPD1udW1fY29sczsgYysrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy53ZWJwYWdlLnNlbGVjdGVkX21vZHVsZXNbcl1bY10gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudGVtcC5udW1fY29scyA9IG51bV9jb2xzO1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy50ZW1wLm51bV9yb3dzID0gbnVtX3Jvd3M7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICB4ID0gZGV0YWlsX3ggKyBvZmZzZXRfYTsgLy9jb3JuZXIgb2YgdXNhYmxlIHNwYWNlXG4gICAgICAgICAgICAgICAgeSA9IGRldGFpbF95ICsgb2Zmc2V0X2E7XG4gICAgICAgICAgICAgICAgeCArPSAoIHJvb2Zfd2lkdGhfYXZhaWwgLSAoY29sX3NwYWNpbmcqbnVtX2NvbHMpKS8yICpzY2FsZTsgLy8gY2VudGVyIGFycmF5IG9uIHJvb2ZcbiAgICAgICAgICAgICAgICB5ICs9ICggcm9vZl9sZW5ndGhfYXZhaWwgLSAocm93X3NwYWNpbmcqbnVtX3Jvd3MpKS8yICpzY2FsZTtcbiAgICAgICAgICAgICAgICBtb2R1bGVfdyA9IG1vZHVsZV93ICogc2NhbGU7XG4gICAgICAgICAgICAgICAgbW9kdWxlX2ggPSBtb2R1bGVfaCAqIHNjYWxlO1xuXG5cblxuICAgICAgICAgICAgICAgIGZvciggcj0xOyByPD1udW1fcm93czsgcisrKXtcblxuICAgICAgICAgICAgICAgICAgICBmb3IoIGM9MTsgYzw9bnVtX2NvbHM7IGMrKyl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXllcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBzZXR0aW5ncy53ZWJwYWdlLnNlbGVjdGVkX21vZHVsZXNbcl1bY10gKSBsYXllciA9ICdwcmV2aWV3X3N0cnVjdHVyYWxfbW9kdWxlX3NlbGVjdGVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgbGF5ZXIgPSAncHJldmlld19zdHJ1Y3R1cmFsX21vZHVsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2R1bGVfeCA9IChjLTEpICogY29sX3NwYWNpbmcgKiBzY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZV95ID0gKHItMSkgKiByb3dfc3BhY2luZyAqIHNjYWxlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkLnJlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3grbW9kdWxlX3grbW9kdWxlX3cvMiwgeSttb2R1bGVfeSttb2R1bGVfaC8yXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbW9kdWxlX3csIG1vZHVsZV9oXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXllcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uY2xpY2s6IFwiZy5mLnRvZ2dsZV9tb2R1bGUodGhpcylcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlX0lEOiAgKHIpICsgJywnICsgKGMpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkLnRleHQoXG4gICAgICAgICAgICAgICAgICAgIFtkZXRhaWxfeCtkZXRhaWxfdy8yLCBkZXRhaWxfeStkZXRhaWxfaCsxMDBdLFxuICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlNlbGVjdGVkIG1vZHVsZXM6IFwiICsgcGFyc2VGbG9hdCggc2V0dGluZ3Mud2VicGFnZS5zZWxlY3RlZF9tb2R1bGVzX3RvdGFsICkudG9GaXhlZCgpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkNhbGN1bGF0ZWQgbW9kdWxlczogXCIgKyBwYXJzZUZsb2F0KCBzZXR0aW5ncy5zeXN0ZW0uYXJyYXkubnVtYmVyX29mX21vZHVsZXMgKS50b0ZpeGVkKCkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgJ2RpbWVudGlvbidcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHggPSBkZXRhaWxfeCArIDQ3NTtcbiAgICAgICAgICAgIHkgPSBkZXRhaWxfeSArIDEyMDtcblxuICAgICAgICAgICAgZC5ibG9jaygnbm9ydGggYXJyb3dfdXAnLCBbeCx5XSk7XG5cbiAgICAgICAgICAgIHggPSAxMjA7XG4gICAgICAgICAgICB5ID0gMTU7XG5cbiAgICAgICAgICAgIGQuYmxvY2soJ25vcnRoIGFycm93X2xlZnQnLCBbeCx5XSk7XG4vLyovXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qXG5cblxuXG5cbiAgICAgICAgZC5saW5lKFtcbiAgICAgICAgICAgIFt4LCAgICB5XSxcbiAgICAgICAgICAgIFt4K2R4LCB5LWR5XSxcbiAgICAgICAgICAgIFt4K2R4LCB5XSxcbiAgICAgICAgICAgIFt4LCAgICB5XSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgKTtcblxuICAgICAgICBkLnRleHQoXG4gICAgICAgICAgICBbeCtkeC8yLTEwLCB5LWR5LzItMjBdLFxuICAgICAgICAgICAgc3lzdGVtLnJvb2YuaGVpZ2h0LnRvU3RyaW5nKCksXG4gICAgICAgICAgICAnZGltZW50aW9uJ1xuICAgICAgICApO1xuICAgICAgICBkLnRleHQoXG4gICAgICAgICAgICBbeCtkeC8yKzUsIHktMTVdLFxuICAgICAgICAgICAgYW5nbGUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICdkaW1lbnRpb24nXG4gICAgICAgICk7XG5cblxuICAgICAgICB4ID0geCtkeCsxMDA7XG4gICAgICAgIHkgPSB5O1xuXG5cbiAgICAgICAgLy8qL1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGQuZHJhd2luZ19wYXJ0cztcbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhZ2U7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgbWtfc2hlZXQgPSByZXF1aXJlKCcuL21rX3NoZWV0Jyk7XG5cbnZhciBwcm9jZXNzID0gZnVuY3Rpb24oc2V0dGluZ3MpIHtcbiAgICB2YXIgZiA9IHNldHRpbmdzLmY7XG5cbiAgICAvL2NvcHkgaW5wdXRzIGZyb20gc2V0dGluZ3MuaW5wdXQgdG8gc2V0dGluZ3Muc3lzdGVtLlxuICAgIGYubWVyZ2Vfb2JqZWN0cyhzZXR0aW5ncy51c2VyX2lucHV0LCBzZXR0aW5ncy5zeXN0ZW0pO1xuXG5cbiAgICAvL2NvbnNvbGUubG9nKCctLS1zZXR0aW5ncy0tLScsIHNldHRpbmdzKTtcbiAgICB2YXIgY29uZmlnX29wdGlvbnMgPSBzZXR0aW5ncy5jb25maWdfb3B0aW9ucztcbiAgICB2YXIgc3lzdGVtID0gc2V0dGluZ3Muc3lzdGVtO1xuICAgIHZhciBsb2MgPSBzZXR0aW5ncy5kcmF3aW5nX3NldHRpbmdzLmxvYztcbiAgICB2YXIgc2l6ZSA9IHNldHRpbmdzLmRyYXdpbmdfc2V0dGluZ3Muc2l6ZTtcbiAgICB2YXIgc3RhdGUgPSBzZXR0aW5ncy5zdGF0ZTtcblxuICAgIHZhciBpbnB1dHMgPSBzZXR0aW5ncy5pbnB1dHM7XG5cblxuXG4vLyBVcGRhdGUgc2V0dGluZ3MgYW5kIGNhbGN1bGF0aW9uc1xuXG4gICAgaWYoIHN0YXRlLmRhdGFiYXNlX2xvYWRlZCApe1xuICAgICAgICBpbnB1dHMuREMgPSBzZXR0aW5ncy5pbnB1dHMuREMgfHwge307XG4gICAgICAgIGlucHV0cy5EQy53aXJlX3NpemUgPSBzZXR0aW5ncy5pbnB1dHMuREMud2lyZV9zaXplIHx8IHt9O1xuICAgICAgICBpbnB1dHMuREMud2lyZV9zaXplLm9wdGlvbnMgPSBpbnB1dHMuREMud2lyZV9zaXplLm9wdGlvbnMgfHwgZi5vYmpfbmFtZXMoc2V0dGluZ3MuY29uZmlnX29wdGlvbnMuTkVDX3RhYmxlc1snQ2ggOSBUYWJsZSA4IENvbmR1Y3RvciBQcm9wZXJ0aWVzJ10pO1xuXG5cbiAgICB9XG5cblxuXG4gICAgLy9jb25zb2xlLmxvZyhcInByb2Nlc3NcIik7XG4gICAgLy9jb25zb2xlLmxvZyhzeXN0ZW0ubW9kdWxlLm1ha2UpO1xuXG4gICAgaW5wdXRzLm1vZHVsZS5tYWtlLm9wdGlvbnMgPSBmLm9ial9uYW1lcyhzZXR0aW5ncy5jb21wb25lbnRzLm1vZHVsZXMpO1xuICAgIGlmKCBzeXN0ZW0ubW9kdWxlLm1ha2UgKSB7XG4gICAgICAgIGlucHV0cy5tb2R1bGUubW9kZWwub3B0aW9ucyAgPSBmLm9ial9uYW1lcyggc2V0dGluZ3MuY29tcG9uZW50cy5tb2R1bGVzW3N5c3RlbS5tb2R1bGUubWFrZV0gKTtcbiAgICB9XG5cbiAgICBpZiggc3lzdGVtLm1vZHVsZS5tb2RlbCApIHtcbiAgICAgICAgdmFyIHNwZWNzID0gc2V0dGluZ3MuY29tcG9uZW50cy5tb2R1bGVzW3N5c3RlbS5tb2R1bGUubWFrZV1bc3lzdGVtLm1vZHVsZS5tb2RlbF07XG4gICAgICAgIGZvciggdmFyIHNwZWNfbmFtZSBpbiBzcGVjcyApe1xuICAgICAgICAgICAgaWYoIHNwZWNfbmFtZSAhPT0gJ21vZHVsZV9pZCcgKXtcbiAgICAgICAgICAgICAgICBzeXN0ZW0ubW9kdWxlW3NwZWNfbmFtZV0gPSBzcGVjc1tzcGVjX25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vc3lzdGVtLm1vZHVsZS5zcGVjcyA9IHNldHRpbmdzLmNvbXBvbmVudHMubW9kdWxlc1tzeXN0ZW0ubW9kdWxlLm1ha2VdW3N5c3RlbS5tb2R1bGUubW9kZWxdO1xuICAgIH1cblxuICAgIGlmKCBmLnNlY3Rpb25fZGVmaW5lZChzZXR0aW5ncywgJ2FycmF5JykgJiYgZi5zZWN0aW9uX2RlZmluZWQoc2V0dGluZ3MsICdtb2R1bGUnKSApe1xuICAgICAgICBzeXN0ZW0uYXJyYXkgPSBzeXN0ZW0uYXJyYXkgfHwge307XG4gICAgICAgIHN5c3RlbS5hcnJheS5pc2MgPSBzeXN0ZW0ubW9kdWxlLmlzYyAqIHN5c3RlbS5hcnJheS5udW1fc3RyaW5ncztcbiAgICAgICAgc3lzdGVtLmFycmF5LnZvYyA9IHN5c3RlbS5tb2R1bGUudm9jICogc3lzdGVtLmFycmF5Lm1vZHVsZXNfcGVyX3N0cmluZztcbiAgICAgICAgc3lzdGVtLmFycmF5LmltcCA9IHN5c3RlbS5tb2R1bGUuaW1wICogc3lzdGVtLmFycmF5Lm51bV9zdHJpbmdzO1xuICAgICAgICBzeXN0ZW0uYXJyYXkudm1wID0gc3lzdGVtLm1vZHVsZS52bXAgKiBzeXN0ZW0uYXJyYXkubW9kdWxlc19wZXJfc3RyaW5nO1xuICAgICAgICBzeXN0ZW0uYXJyYXkucG1wID0gc3lzdGVtLmFycmF5LnZtcCAgKiBzeXN0ZW0uYXJyYXkuaW1wO1xuXG4gICAgICAgIHN5c3RlbS5hcnJheS5udW1iZXJfb2ZfbW9kdWxlcyA9IHN5c3RlbS5hcnJheS5tb2R1bGVzX3Blcl9zdHJpbmcgKiBzeXN0ZW0uYXJyYXkubnVtX3N0cmluZ3M7XG5cblxuICAgIH1cblxuXG4gICAgaWYoIGYuc2VjdGlvbl9kZWZpbmVkKHNldHRpbmdzLCAnREMnKSApe1xuXG4gICAgICAgIHN5c3RlbS5EQy53aXJlX3NpemUgPSBcIi1VbmRlZmluZWQtXCI7XG5cbiAgICB9XG5cbiAgICBpbnB1dHMuaW52ZXJ0ZXIubWFrZS5vcHRpb25zID0gZi5vYmpfbmFtZXMoc2V0dGluZ3MuY29tcG9uZW50cy5pbnZlcnRlcnMpO1xuICAgIGlmKCBzeXN0ZW0uaW52ZXJ0ZXIubWFrZSApIHtcbiAgICAgICAgaW5wdXRzLmludmVydGVyLm1vZGVsLm9wdGlvbnMgPSBmLm9ial9uYW1lcyggc2V0dGluZ3MuY29tcG9uZW50cy5pbnZlcnRlcnNbc3lzdGVtLmludmVydGVyLm1ha2VdICk7XG4gICAgfVxuICAgIGlmKCBmLnNlY3Rpb25fZGVmaW5lZChzZXR0aW5ncywgJ2ludmVydGVyJykgKXtcblxuICAgIH1cblxuICAgIC8vaW5wdXRzLkFDLmxvYWRjZW50ZXJfdHlwZSA9IHNldHRpbmdzLmYub2JqX25hbWVzKGlucHV0cy5BQy5sb2FkY2VudGVyX3R5cGVzKTtcbiAgICBpZiggc3lzdGVtLkFDLmxvYWRjZW50ZXJfdHlwZXMgKSB7XG4gICAgICAgIHZhciBsb2FkY2VudGVyX3R5cGUgPSBzeXN0ZW0uQUMubG9hZGNlbnRlcl90eXBlcztcbiAgICAgICAgdmFyIEFDX29wdGlvbnMgPSBpbnB1dHMuQUMubG9hZGNlbnRlcl90eXBlc1tsb2FkY2VudGVyX3R5cGVdO1xuICAgICAgICBpbnB1dHMuQUMudHlwZS5vcHRpb25zID0gQUNfb3B0aW9ucztcbiAgICAgICAgLy9pbi5vcHQuQUMudHlwZXNbbG9hZGNlbnRlcl90eXBlXTtcblxuICAgICAgICAvL2lucHV0cy5BQ1sndHlwZSddID0gZi5vYmpfbmFtZXMoIHNldHRpbmdzLmluLm9wdC5BQy50eXBlICk7XG4gICAgfVxuICAgIGlmKCBzeXN0ZW0uQUMudHlwZSApIHtcbiAgICAgICAgc3lzdGVtLkFDLmNvbmR1Y3RvcnMgPSBzZXR0aW5ncy5pbi5vcHQuQUMudHlwZXNbc3lzdGVtLkFDLnR5cGVdO1xuICAgICAgICBzeXN0ZW0uQUMubnVtX2NvbmR1Y3RvcnMgPSBzeXN0ZW0uQUMuY29uZHVjdG9ycy5sZW5ndGg7XG5cbiAgICB9XG4gICAgaWYoIGYuc2VjdGlvbl9kZWZpbmVkKHNldHRpbmdzLCAnQUMnKSApe1xuXG4gICAgICAgIHN5c3RlbS5BQy53aXJlX3NpemUgPSBcIi1VbmRlZmluZWQtXCI7XG4gICAgfVxuXG4gICAgc2l6ZS53aXJlX29mZnNldC5tYXggPSBzaXplLndpcmVfb2Zmc2V0Lm1pbiArIHN5c3RlbS5hcnJheS5udW1fc3RyaW5ncyAqIHNpemUud2lyZV9vZmZzZXQuYmFzZTtcbiAgICBzaXplLndpcmVfb2Zmc2V0Lmdyb3VuZCA9IHNpemUud2lyZV9vZmZzZXQubWF4ICsgc2l6ZS53aXJlX29mZnNldC5iYXNlKjE7XG4gICAgbG9jLmFycmF5LmxlZnQgPSBsb2MuYXJyYXkucmlnaHQgLSAoIHNpemUuc3RyaW5nLncgKiBzeXN0ZW0uYXJyYXkubnVtX3N0cmluZ3MgKSAtICggc2l6ZS5tb2R1bGUuZnJhbWUudyozLzQgKSA7XG5cblxuXG5cbiAgICBpZiggZi5zZWN0aW9uX2RlZmluZWQoc2V0dGluZ3MsICdsb2NhdGlvbicpICl7XG4gICAgICAgIC8vY29uc29sZS5sb2coJ2FkZHJlc3MgcmVhZHknKTtcbiAgICAgICAgLy9mLnJlcXVlc3RfZ2VvY29kZSgpO1xuICAgICAgICBzZXR0aW5ncy5wZXJtLmxvY2F0aW9uLm5ld19hZGRyZXNzID0gZmFsc2U7XG4gICAgICAgIGZvciggdmFyIG5hbWUgaW4gc2V0dGluZ3Muc3lzdGVtLmxvY2F0aW9uICl7XG4gICAgICAgICAgICBpZiggc2V0dGluZ3Muc3lzdGVtLmxvY2F0aW9uW25hbWVdICE9PSBzZXR0aW5ncy5wZXJtLmxvY2F0aW9uW25hbWVdKXtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5wZXJtLmxvY2F0aW9uLm5ld19hZGRyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldHRpbmdzLnBlcm0ubG9jYXRpb25bbmFtZV0gPSBzZXR0aW5ncy5zeXN0ZW0ubG9jYXRpb25bbmFtZV07XG4gICAgICAgIH1cblxuICAgIH1cblxuXG5cblxuXG4vLyBVcGRhdGUgZHJhd2luZ1xuXG4gICAgLy8gTWFrZSBibG9ja3NcbiAgICBmLm1rX2Jsb2NrcyhzZXR0aW5ncyk7XG5cblxuICAgIC8vIE1ha2UgZHJhd2luZ1xuICAgIHZhciBpLCBwO1xuXG4gICAgLy8gTm90IG5lZWRlZCBvbiBzZXJ2ZXJcblxuXG4gICAgc2V0dGluZ3MuZHJhd2luZy5wYXJ0cyA9IHt9O1xuICAgIHNldHRpbmdzLmRyYXdpbmcuc3ZncyA9IHt9O1xuICAgIHNldHRpbmdzLmRyYXdpbmdfc2V0dGluZ3Muc2hlZXRzLmZvckVhY2goZnVuY3Rpb24oc2hlZXRfaW5mbywgaSl7XG4gICAgICAgIHAgPSBpKzE7XG4gICAgICAgIHNldHRpbmdzLmRyYXdpbmcucGFydHNbcF0gPSBta19zaGVldChzZXR0aW5ncywgc2hlZXRfaW5mbyk7XG4vLyAgICAgICAgc2V0dGluZ3MuZHJhd2luZy5wYXJ0c1twXSA9IGYubWtfc2hlZXRfbnVtW3BdKHNldHRpbmdzKTtcblxuICAgIH0pO1xuXG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBzZXR0aW5nc19kZXZfZGVmYXVsdHMgPSBmdW5jdGlvbihzZXR0aW5ncykge1xuICAgIGNvbnNvbGUubG9nKCdEZXYgbW9kZSAtIGRlZmF1bHRzIG9uJyk7XG5cbiAgICAvL2NvbnNvbGUubG9nKCctLS1zZXR0aW5ncy0tLScsIHNldHRpbmdzKTtcbiAgICB2YXIgY29uZmlnX29wdGlvbnMgPSBzZXR0aW5ncy5jb25maWdfb3B0aW9ucztcbiAgICB2YXIgaW5wdXRzID0gc2V0dGluZ3MuaW5wdXRzO1xuICAgIHZhciB1c2VyX2lucHV0ID0gc2V0dGluZ3MudXNlcl9pbnB1dDtcbiAgICB2YXIgbG9jID0gc2V0dGluZ3MuZHJhd2luZ19zZXR0aW5ncy5sb2M7XG4gICAgdmFyIHNpemUgPSBzZXR0aW5ncy5kcmF3aW5nX3NldHRpbmdzLnNpemU7XG4gICAgdmFyIHN0YXRlID0gc2V0dGluZ3Muc3RhdGU7XG5cbiAgICBpZiggc3RhdGUuZGF0YWJhc2VfbG9hZGVkICl7XG4gICAgICAgIGlucHV0cy5EQyA9IHNldHRpbmdzLmlucHV0cy5EQyB8fCB7fTtcbiAgICAgICAgaW5wdXRzLkRDLndpcmVfc2l6ZSA9IHNldHRpbmdzLmlucHV0cy5EQy53aXJlX3NpemUgfHwge307XG4gICAgICAgIGlucHV0cy5EQy53aXJlX3NpemUub3B0aW9ucyA9IGlucHV0cy5EQy53aXJlX3NpemUub3B0aW9ucyB8fCBnLmYub2JqX25hbWVzKHNldHRpbmdzLmNvbmZpZ19vcHRpb25zLk5FQ190YWJsZXNbJ0NoIDkgVGFibGUgOCBDb25kdWN0b3IgUHJvcGVydGllcyddKTtcblxuXG4gICAgfVxuXG4gICAgdXNlcl9pbnB1dC5hcnJheS5udW1fc3RyaW5ncyA9IHVzZXJfaW5wdXQuYXJyYXkubnVtX3N0cmluZ3MgfHwgNDtcbiAgICB1c2VyX2lucHV0LmFycmF5Lm1vZHVsZXNfcGVyX3N0cmluZyA9IHVzZXJfaW5wdXQuYXJyYXkubW9kdWxlc19wZXJfc3RyaW5nIHx8IDY7XG4gICAgdXNlcl9pbnB1dC5EQy5ob21lX3J1bl9sZW5ndGggPSB1c2VyX2lucHV0LkRDLmhvbWVfcnVuX2xlbmd0aCB8fCA1MDtcblxuICAgIHVzZXJfaW5wdXQucm9vZi53aWR0aCAgPSB1c2VyX2lucHV0LnJvb2Yud2lkdGggfHwgNjA7XG4gICAgdXNlcl9pbnB1dC5yb29mLmxlbmd0aCA9IHVzZXJfaW5wdXQucm9vZi5sZW5ndGggfHwgMjU7XG4gICAgdXNlcl9pbnB1dC5yb29mLnNsb3BlICA9IHVzZXJfaW5wdXQucm9vZi5zbG9wZSB8fCBcIjY6MTJcIjtcbiAgICB1c2VyX2lucHV0LnJvb2YudHlwZSAgID0gdXNlcl9pbnB1dC5yb29mLnR5cGUgfHwgXCJHYWJsZVwiO1xuXG4gICAgdXNlcl9pbnB1dC5pbnZlcnRlci5sb2NhdGlvbiA9IHVzZXJfaW5wdXQuaW52ZXJ0ZXIubG9jYXRpb24gIHx8IFwiSW5zaWRlXCI7XG5cbiAgICB1c2VyX2lucHV0Lm1vZHVsZS5vcmllbnRhdGlvbiA9IHVzZXJfaW5wdXQubW9kdWxlLm9yaWVudGF0aW9uIHx8IFwiUG9ydHJhaXRcIjtcblxuICAgIHVzZXJfaW5wdXQubG9jYXRpb24uYWRkcmVzcyA9IHVzZXJfaW5wdXQubG9jYXRpb24uYWRkcmVzcyB8fCAnMTY3OSBDbGVhcmxha2UgUm9hZCc7XG4gICAgdXNlcl9pbnB1dC5sb2NhdGlvbi5jaXR5ICAgID0gdXNlcl9pbnB1dC5sb2NhdGlvbi5jaXR5IHx8ICdDb2NvYSc7XG4gICAgdXNlcl9pbnB1dC5sb2NhdGlvbi56aXAgICAgID0gdXNlcl9pbnB1dC5sb2NhdGlvbi56aXAgfHwgJzMyOTIyJztcbiAgICB1c2VyX2lucHV0LmxvY2F0aW9uLmNvdW50eSAgID0gdXNlcl9pbnB1dC5sb2NhdGlvbi5jb3VudHkgfHwgJ0JyZXZhcmQnO1xuXG5cbiAgICBpZiggc3RhdGUuZGF0YWJhc2VfbG9hZGVkICl7XG5cbiAgICAgICAgdXNlcl9pbnB1dC5tb2R1bGUubWFrZSA9IHVzZXJfaW5wdXQubW9kdWxlLm1ha2UgfHxcbiAgICAgICAgICAgIGcuZi5vYmpfbmFtZXMoIHNldHRpbmdzLmNvbXBvbmVudHMubW9kdWxlcyApWzBdO1xuICAgICAgICB1c2VyX2lucHV0Lm1vZHVsZS5tb2RlbCA9IHVzZXJfaW5wdXQubW9kdWxlLm1vZGVsIHx8XG4gICAgICAgICAgICBnLmYub2JqX25hbWVzKCBzZXR0aW5ncy5jb21wb25lbnRzLm1vZHVsZXNbdXNlcl9pbnB1dC5tb2R1bGUubWFrZV0gKVswXTtcblxuICAgICAgICB1c2VyX2lucHV0LmludmVydGVyLm1ha2UgPSB1c2VyX2lucHV0LmludmVydGVyLm1ha2UgfHxcbiAgICAgICAgICAgIGcuZi5vYmpfbmFtZXMoIHNldHRpbmdzLmNvbXBvbmVudHMuaW52ZXJ0ZXJzIClbMF07XG4gICAgICAgIHVzZXJfaW5wdXQuaW52ZXJ0ZXIubW9kZWwgPSB1c2VyX2lucHV0LmludmVydGVyLm1vZGVsIHx8XG4gICAgICAgICAgICBnLmYub2JqX25hbWVzKCBzZXR0aW5ncy5jb21wb25lbnRzLmludmVydGVyc1t1c2VyX2lucHV0LmludmVydGVyLm1ha2VdIClbMF07XG5cblxuICAgICAgICB1c2VyX2lucHV0LkFDLmxvYWRjZW50ZXJfdHlwZXMgPSB1c2VyX2lucHV0LkFDLmxvYWRjZW50ZXJfdHlwZXMgfHxcbiAgICAgICAgLy8gICAgZy5mLm9ial9uYW1lcyhpbnB1dHMuQUMubG9hZGNlbnRlcl90eXBlcylbMF07XG4gICAgICAgICAgICAnNDgwLzI3N1YnO1xuXG5cbiAgICAgICAgdXNlcl9pbnB1dC5BQy50eXBlID0gdXNlcl9pbnB1dC5BQy50eXBlIHx8ICc0ODBWIFd5ZSc7XG4gICAgICAgIC8vc3lzdGVtLkFDLnR5cGUgPSB1c2VyX2lucHV0LkFDLnR5cGUgfHxcbiAgICAgICAgLy8gICAgdXNlcl9pbnB1dC5BQy5sb2FkY2VudGVyX3R5cGVzW3N5c3RlbS5BQy5sb2FkY2VudGVyX3R5cGVzXVswXTtcblxuICAgICAgICB1c2VyX2lucHV0LkFDLmRpc3RhbmNlX3RvX2xvYWRjZW50ZXIgPSB1c2VyX2lucHV0LkFDLmRpc3RhbmNlX3RvX2xvYWRjZW50ZXIgfHxcbiAgICAgICAgICAgIDUwO1xuXG5cbiAgICAgICAgdXNlcl9pbnB1dC5EQy53aXJlX3NpemUgPSBpbnB1dHMuREMud2lyZV9zaXplLm9wdGlvbnNbM107XG4gICAgICAgIC8qXG5cbiAgICAgICAgc2V0dGluZ3MuY29uZmlnX29wdGlvbnMuaW52ZXJ0ZXJNYWtlQXJyYXkgPSBrLm9iaklkQXJyYXkoc2V0dGluZ3MuY29uZmlnX29wdGlvbnMuaW52ZXJ0ZXJzKTtcbiAgICAgICAgdXNlcl9pbnB1dC5pbnZlcnRlci5tYWtlID0gdXNlcl9pbnB1dC5pbnZlcnRlci5tYWtlIHx8IE9iamVjdC5rZXlzKCBzZXR0aW5ncy5jb25maWdfb3B0aW9ucy5pbnZlcnRlcnMgKVswXTtcbiAgICAgICAgc2V0dGluZ3MuY29uZmlnX29wdGlvbnMuaW52ZXJ0ZXJNb2RlbEFycmF5ID0gay5vYmpJZEFycmF5KHNldHRpbmdzLmNvbmZpZ19vcHRpb25zLmludmVydGVyc1tzeXN0ZW0uaW52ZXJ0ZXIubWFrZV0pO1xuXG4gICAgICAgIHVzZXJfaW5wdXQuQUNfbG9hZGNlbnRlcl90eXBlID0gdXNlcl9pbnB1dC5BQ19sb2FkY2VudGVyX3R5cGUgfHwgY29uZmlnX29wdGlvbnMuQUNfbG9hZGNlbnRlcl90eXBlX29wdGlvbnNbMF07XG4gICAgICAgIC8vKi9cblxuXG4gICAgICAgIHVzZXJfaW5wdXQuYXR0YWNobWVudF9zeXN0ZW0ubWFrZSA9IHVzZXJfaW5wdXQuYXR0YWNobWVudF9zeXN0ZW0ubWFrZSB8fFxuICAgICAgICAgICAgaW5wdXRzLmF0dGFjaG1lbnRfc3lzdGVtLm1ha2Uub3B0aW9uc1swXTtcbiAgICAgICAgdXNlcl9pbnB1dC5hdHRhY2htZW50X3N5c3RlbS5tb2RlbCA9IHVzZXJfaW5wdXQuYXR0YWNobWVudF9zeXN0ZW0ubW9kZWwgfHxcbiAgICAgICAgICAgIGlucHV0cy5hdHRhY2htZW50X3N5c3RlbS5tb2RlbC5vcHRpb25zWzBdO1xuXG4gICAgfVxuXG5cblxuXG5cbn07XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHRpbmdzX2Rldl9kZWZhdWx0cztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBzZXR0aW5nc19kcmF3aW5nKHNldHRpbmdzKXtcblxuICAgIHZhciBzeXN0ZW0gPSBzZXR0aW5ncy5zeXN0ZW07XG4gICAgdmFyIHN0YXR1cyA9IHNldHRpbmdzLnN0YXR1cztcblxuICAgIC8vIERyYXdpbmcgc3BlY2lmaWNcbiAgICAvL3NldHRpbmdzLmRyYXdpbmcgPSBzZXR0aW5ncy5kcmF3aW5nIHx8IHt9O1xuXG5cbiAgICB2YXIgc2l6ZSA9IHNldHRpbmdzLmRyYXdpbmdfc2V0dGluZ3Muc2l6ZSA9IHt9O1xuICAgIHZhciBsb2MgPSBzZXR0aW5ncy5kcmF3aW5nX3NldHRpbmdzLmxvYyA9IHt9O1xuXG5cbiAgICAvLyBzaXplc1xuICAgIHNpemUuZHJhd2luZyA9IHtcbiAgICAgICAgdzogMTAwMCxcbiAgICAgICAgaDogNzgwLFxuICAgICAgICBmcmFtZV9wYWRkaW5nOiA1LFxuICAgICAgICB0aXRsZWJveDoge1xuICAgICAgICAgICAgc2lkZToge1xuICAgICAgICAgICAgICAgIHc6IDgwLFxuICAgICAgICAgICAgICAgIGg6IDgwKjMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm90dG9tOiB7XG4gICAgICAgICAgICAgICAgaDogNDAsXG4gICAgICAgICAgICAgICAgdzogNjUwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICBzaXplLm1vZHVsZSA9IHt9O1xuICAgIHNpemUubW9kdWxlLmZyYW1lID0ge1xuICAgICAgICB3OiAxMCxcbiAgICAgICAgaDogMzAsXG4gICAgfTtcbiAgICBzaXplLm1vZHVsZS5sZWFkID0gc2l6ZS5tb2R1bGUuZnJhbWUudyoyLzM7XG4gICAgc2l6ZS5tb2R1bGUuaCA9IHNpemUubW9kdWxlLmZyYW1lLmggKyBzaXplLm1vZHVsZS5sZWFkKjI7XG4gICAgc2l6ZS5tb2R1bGUudyA9IHNpemUubW9kdWxlLmZyYW1lLnc7XG5cbiAgICBzaXplLndpcmVfb2Zmc2V0ID0ge1xuICAgICAgICBiYXNlOiA3LFxuICAgICAgICBnYXA6IHNpemUubW9kdWxlLncsXG4gICAgfTtcbiAgICBzaXplLndpcmVfb2Zmc2V0Lm1pbiA9IHNpemUud2lyZV9vZmZzZXQuYmFzZSAqIDE7XG5cbiAgICBzaXplLnN0cmluZyA9IHt9O1xuICAgIHNpemUuc3RyaW5nLmdhcCA9IHNpemUubW9kdWxlLmZyYW1lLncvNDI7XG4gICAgc2l6ZS5zdHJpbmcuZ2FwX21pc3NpbmcgPSBzaXplLm1vZHVsZS5oO1xuICAgIHNpemUuc3RyaW5nLncgPSBzaXplLm1vZHVsZS5mcmFtZS53ICogMi41O1xuXG4gICAgc2l6ZS50ZXJtaW5hbF9kaWFtID0gNTtcbiAgICBzaXplLmZ1c2UgPSB7fTtcbiAgICBzaXplLmZ1c2UudyA9IDE1O1xuICAgIHNpemUuZnVzZS5oID0gNDtcblxuXG4gICAgLy8gSW52ZXJ0ZXJcbiAgICBzaXplLmludmVydGVyID0geyB3OiAyNTAsIGg6IDE1MCB9O1xuICAgIHNpemUuaW52ZXJ0ZXIudGV4dF9nYXAgPSAxNTtcbiAgICBzaXplLmludmVydGVyLnN5bWJvbF93ID0gNTA7XG4gICAgc2l6ZS5pbnZlcnRlci5zeW1ib2xfaCA9IDI1O1xuXG4gICAgbG9jLmludmVydGVyID0ge1xuICAgICAgICB4OiBzaXplLmRyYXdpbmcudy8yLFxuICAgICAgICB5OiBzaXplLmRyYXdpbmcuaC8zLFxuICAgIH07XG4gICAgbG9jLmludmVydGVyLmJvdHRvbSA9IGxvYy5pbnZlcnRlci55ICsgc2l6ZS5pbnZlcnRlci5oLzI7XG4gICAgbG9jLmludmVydGVyLnRvcCA9IGxvYy5pbnZlcnRlci55IC0gc2l6ZS5pbnZlcnRlci5oLzI7XG4gICAgbG9jLmludmVydGVyLmJvdHRvbV9yaWdodCA9IHtcbiAgICAgICAgeDogbG9jLmludmVydGVyLnggKyBzaXplLmludmVydGVyLncvMixcbiAgICAgICAgeTogbG9jLmludmVydGVyLnkgKyBzaXplLmludmVydGVyLmgvMixcbiAgICB9O1xuXG4gICAgLy8gYXJyYXlcbiAgICBsb2MuYXJyYXkgPSB7XG4gICAgICAgIHg6IGxvYy5pbnZlcnRlci54IC0gMjAwLFxuICAgICAgICB1cHBlcjogbG9jLmludmVydGVyLnkgLSAyMCxcbiAgICB9O1xuICAgIC8vbG9jLmFycmF5LnVwcGVyID0gbG9jLmFycmF5LnkgLSBzaXplLnN0cmluZy5oLzI7XG4gICAgbG9jLmFycmF5LnJpZ2h0ID0gbG9jLmFycmF5LnggLSBzaXplLm1vZHVsZS5mcmFtZS5oKjM7XG5cblxuXG5cbiAgICBsb2MuREMgPSBsb2MuYXJyYXk7XG5cbiAgICAvLyBEQyBqYlxuICAgIHNpemUuamJfYm94ID0ge1xuICAgICAgICBoOiAxNTAsXG4gICAgICAgIHc6IDgwLFxuICAgIH07XG4gICAgbG9jLmpiX2JveCA9IHtcbiAgICAgICAgeDogMzUwLFxuICAgICAgICB5OiA1NTAsXG4gICAgfTtcblxuICAgIC8vIERDIGRpY29uZWN0XG4gICAgc2l6ZS5kaXNjYm94ID0ge1xuICAgICAgICB3OiAxNDAsXG4gICAgICAgIGg6IDUwLFxuICAgIH07XG4gICAgbG9jLmRpc2Nib3ggPSB7XG4gICAgICAgIHg6IGxvYy5pbnZlcnRlci54IC0gc2l6ZS5pbnZlcnRlci53LzIgKyBzaXplLmRpc2Nib3gudy8yLFxuICAgICAgICB5OiBsb2MuaW52ZXJ0ZXIueSArIHNpemUuaW52ZXJ0ZXIuaC8yICsgc2l6ZS5kaXNjYm94LmgvMiArIDEwLFxuICAgIH07XG5cbiAgICAvLyBBQyBkaWNvbmVjdFxuICAgIHNpemUuQUNfZGlzYyA9IHsgdzogODAsIGg6IDEyNSB9O1xuXG4gICAgbG9jLkFDX2Rpc2MgPSB7XG4gICAgICAgIHg6IGxvYy5pbnZlcnRlci54KzIwMCxcbiAgICAgICAgeTogbG9jLmludmVydGVyLnkrMjUwXG4gICAgfTtcbiAgICBsb2MuQUNfZGlzYy5ib3R0b20gPSBsb2MuQUNfZGlzYy55ICsgc2l6ZS5BQ19kaXNjLmgvMjtcbiAgICBsb2MuQUNfZGlzYy50b3AgPSBsb2MuQUNfZGlzYy55IC0gc2l6ZS5BQ19kaXNjLmgvMjtcbiAgICBsb2MuQUNfZGlzYy5sZWZ0ID0gbG9jLkFDX2Rpc2MueCAtIHNpemUuQUNfZGlzYy53LzI7XG4gICAgbG9jLkFDX2Rpc2Muc3dpdGNoX3RvcCA9IGxvYy5BQ19kaXNjLnRvcCArIDE1O1xuICAgIGxvYy5BQ19kaXNjLnN3aXRjaF9ib3R0b20gPSBsb2MuQUNfZGlzYy5zd2l0Y2hfdG9wICsgMzA7XG5cblxuICAgIC8vIEFDIHBhbmVsXG5cbiAgICBsb2MuQUNfbG9hZGNlbnRlciA9IHtcbiAgICAgICAgeDogbG9jLmludmVydGVyLngrMzUwLFxuICAgICAgICB5OiBsb2MuaW52ZXJ0ZXIueSsxMDBcbiAgICB9O1xuICAgIHNpemUuQUNfbG9hZGNlbnRlciA9IHsgdzogMTI1LCBoOiAzMDAgfTtcbiAgICBsb2MuQUNfbG9hZGNlbnRlci5sZWZ0ID0gbG9jLkFDX2xvYWRjZW50ZXIueCAtIHNpemUuQUNfbG9hZGNlbnRlci53LzI7XG4gICAgbG9jLkFDX2xvYWRjZW50ZXIudG9wID0gbG9jLkFDX2xvYWRjZW50ZXIueSAtIHNpemUuQUNfbG9hZGNlbnRlci5oLzI7XG5cblxuICAgIHNpemUuQUNfbG9hZGNlbnRlci5icmVha2VyID0geyB3OiAyMCwgaDogc2l6ZS50ZXJtaW5hbF9kaWFtLCB9O1xuICAgIGxvYy5BQ19sb2FkY2VudGVyLmJyZWFrZXJzID0ge1xuICAgICAgICBsZWZ0OiBsb2MuQUNfbG9hZGNlbnRlci54IC0gKCBzaXplLkFDX2xvYWRjZW50ZXIuYnJlYWtlci53ICogMS4xICksXG4gICAgfTtcbiAgICBzaXplLkFDX2xvYWRjZW50ZXIuYnJlYWtlcnMgPSB7XG4gICAgICAgIG51bTogMjAsXG4gICAgICAgIHNwYWNpbmc6IHNpemUuQUNfbG9hZGNlbnRlci5icmVha2VyLmggKyAxLFxuICAgIH07XG4gICAgbG9jLkFDX2xvYWRjZW50ZXIuYnJlYWtlcnMudG9wID0gbG9jLkFDX2xvYWRjZW50ZXIudG9wICsgc2l6ZS5BQ19sb2FkY2VudGVyLmgvNTtcbiAgICBsb2MuQUNfbG9hZGNlbnRlci5icmVha2Vycy5ib3R0b20gPSBsb2MuQUNfbG9hZGNlbnRlci5icmVha2Vycy50b3AgKyBzaXplLkFDX2xvYWRjZW50ZXIuYnJlYWtlcnMuc3BhY2luZypzaXplLkFDX2xvYWRjZW50ZXIuYnJlYWtlcnMubnVtO1xuXG5cbiAgICBzaXplLkFDX2xvYWRjZW50ZXIubmV1dHJhbGJhciA9IHsgdzo1LCBoOjQwIH07XG4gICAgbG9jLkFDX2xvYWRjZW50ZXIubmV1dHJhbGJhciA9IHtcbiAgICAgICAgeDogbG9jLkFDX2xvYWRjZW50ZXIubGVmdCArIDIwLFxuICAgICAgICB5OiBsb2MuQUNfbG9hZGNlbnRlci55ICsgc2l6ZS5BQ19sb2FkY2VudGVyLmgqMC4zXG4gICAgfTtcblxuICAgIHNpemUuQUNfbG9hZGNlbnRlci5ncm91bmRiYXIgPSB7IHc6NDAsIGg6NSB9O1xuICAgIGxvYy5BQ19sb2FkY2VudGVyLmdyb3VuZGJhciA9IHtcbiAgICAgICAgeDogbG9jLkFDX2xvYWRjZW50ZXIueCArIDEwLFxuICAgICAgICB5OiBsb2MuQUNfbG9hZGNlbnRlci55ICsgc2l6ZS5BQ19sb2FkY2VudGVyLmgqMC40NVxuICAgIH07XG5cbiAgICBsb2MuQUNfY29uZHVpdCA9IHtcbiAgICAgICAgeTogbG9jLkFDX2xvYWRjZW50ZXIuYnJlYWtlcnMuYm90dG9tIC0gc2l6ZS5BQ19sb2FkY2VudGVyLmJyZWFrZXJzLnNwYWNpbmcvMixcbiAgICB9O1xuXG5cbiAgICAvLyB3aXJlIHRhYmxlXG4gICAgbG9jLndpcmVfdGFibGUgPSB7XG4gICAgICAgIHg6IHNpemUuZHJhd2luZy53IC0gc2l6ZS5kcmF3aW5nLmZyYW1lX3BhZGRpbmcqMyAtIDMyNSxcbiAgICAgICAgeTogc2l6ZS5kcmF3aW5nLmZyYW1lX3BhZGRpbmcqMyxcbiAgICB9O1xuXG4gICAgLy8gdm9sdGFnZSBkcm9wIHRhYmxlXG4gICAgc2l6ZS52b2x0X2Ryb3BfdGFibGUgPSB7fTtcbiAgICBzaXplLnZvbHRfZHJvcF90YWJsZS53ID0gMTUwO1xuICAgIHNpemUudm9sdF9kcm9wX3RhYmxlLmggPSAxMDA7XG4gICAgbG9jLnZvbHRfZHJvcF90YWJsZSA9IHt9O1xuICAgIGxvYy52b2x0X2Ryb3BfdGFibGUueCA9IHNpemUuZHJhd2luZy53IC0gc2l6ZS52b2x0X2Ryb3BfdGFibGUudy8yIC0gMzAgLSBzaXplLmRyYXdpbmcudGl0bGVib3guc2lkZS53O1xuICAgIGxvYy52b2x0X2Ryb3BfdGFibGUueSA9IHNpemUuZHJhd2luZy5oIC0gc2l6ZS52b2x0X2Ryb3BfdGFibGUuaC8yIC0gMzAgLSBzaXplLmRyYXdpbmcudGl0bGVib3guYm90dG9tLmg7XG5cblxuICAgIC8vIHZvbHRhZ2UgZHJvcCB0YWJsZVxuICAgIHNpemUuZ2VuZXJhbF9ub3RlcyA9IHt9O1xuICAgIHNpemUuZ2VuZXJhbF9ub3Rlcy53ID0gMTUwO1xuICAgIHNpemUuZ2VuZXJhbF9ub3Rlcy5oID0gMTAwO1xuICAgIGxvYy5nZW5lcmFsX25vdGVzID0ge307XG4gICAgbG9jLmdlbmVyYWxfbm90ZXMueCA9IHNpemUuZ2VuZXJhbF9ub3Rlcy53LzIgKyAzMDtcbiAgICBsb2MuZ2VuZXJhbF9ub3Rlcy55ID0gc2l6ZS5nZW5lcmFsX25vdGVzLmgvMiArIDMwO1xuXG5cblxuXG4gICAgc2V0dGluZ3MucGFnZXMgPSB7fTtcbiAgICBzZXR0aW5ncy5wYWdlcy5sZXR0ZXIgPSB7XG4gICAgICAgIHVuaXRzOiAnaW5jaGVzJyxcbiAgICAgICAgdzogMTEuMCxcbiAgICAgICAgaDogOC41LFxuICAgIH07XG4gICAgc2V0dGluZ3MucGFnZSA9IHNldHRpbmdzLnBhZ2VzLmxldHRlcjtcblxuICAgIHNldHRpbmdzLnBhZ2VzLlBERiA9IHtcbiAgICAgICAgdzogc2V0dGluZ3MucGFnZS53ICogNzIsXG4gICAgICAgIGg6IHNldHRpbmdzLnBhZ2UuaCAqIDcyLFxuICAgIH07XG5cbiAgICBzZXR0aW5ncy5wYWdlcy5QREYuc2NhbGUgPSB7XG4gICAgICAgIHg6IHNldHRpbmdzLnBhZ2VzLlBERi53IC8gc2V0dGluZ3MuZHJhd2luZ19zZXR0aW5ncy5zaXplLmRyYXdpbmcudyxcbiAgICAgICAgeTogc2V0dGluZ3MucGFnZXMuUERGLmggLyBzZXR0aW5ncy5kcmF3aW5nX3NldHRpbmdzLnNpemUuZHJhd2luZy5oLFxuICAgIH07XG5cbiAgICBpZiggc2V0dGluZ3MucGFnZXMuUERGLnNjYWxlLnggPCBzZXR0aW5ncy5wYWdlcy5QREYuc2NhbGUueSApIHtcbiAgICAgICAgc2V0dGluZ3MucGFnZS5zY2FsZSA9IHNldHRpbmdzLnBhZ2VzLlBERi5zY2FsZS54O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNldHRpbmdzLnBhZ2Uuc2NhbGUgPSBzZXR0aW5ncy5wYWdlcy5QREYuc2NhbGUueTtcbiAgICB9XG5cblxuICAgIGxvYy5wcmV2aWV3ID0gbG9jLnByZXZpZXcgfHwge307XG4gICAgbG9jLnByZXZpZXcuYXJyYXkgPSBsb2MucHJldmlldy5hcnJheSA9IHt9O1xuICAgIGxvYy5wcmV2aWV3LmFycmF5LnRvcCA9IDEwMDtcbiAgICBsb2MucHJldmlldy5hcnJheS5sZWZ0ID0gNTA7XG5cbiAgICBsb2MucHJldmlldy5EQyA9IGxvYy5wcmV2aWV3LkRDID0ge307XG4gICAgbG9jLnByZXZpZXcuaW52ZXJ0ZXIgPSBsb2MucHJldmlldy5pbnZlcnRlciA9IHt9O1xuICAgIGxvYy5wcmV2aWV3LkFDID0gbG9jLnByZXZpZXcuQUMgPSB7fTtcblxuICAgIHNpemUucHJldmlldyA9IHNpemUucHJldmlldyB8fCB7fTtcbiAgICBzaXplLnByZXZpZXcubW9kdWxlID0ge1xuICAgICAgICB3OiAxNSxcbiAgICAgICAgaDogMjUsXG4gICAgfTtcbiAgICBzaXplLnByZXZpZXcuREMgPSB7XG4gICAgICAgIHc6IDMwLFxuICAgICAgICBoOiA1MCxcbiAgICB9O1xuICAgIHNpemUucHJldmlldy5pbnZlcnRlciA9IHtcbiAgICAgICAgdzogMTUwLFxuICAgICAgICBoOiA3NSxcbiAgICB9O1xuICAgIHNpemUucHJldmlldy5BQyA9IHtcbiAgICAgICAgdzogMzAsXG4gICAgICAgIGg6IDUwLFxuICAgIH07XG4gICAgc2l6ZS5wcmV2aWV3LmxvYWRjZW50ZXIgPSB7XG4gICAgICAgIHc6IDUwLFxuICAgICAgICBoOiAxMDAsXG4gICAgfTtcblxuXG5cbiAgcmV0dXJuIHNldHRpbmdzO1xuXG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR0aW5nc19kcmF3aW5nO1xuIiwiLy8vLy8vLy8vLy8vLy8vXG4vLyBmb250c1xuXG52YXIgZm9udHMgPSB7fTtcblxuZm9udHNbJ2Jhc2UnXSA9IHtcbiAgICAnZm9udC1mYW1pbHknOiAnbW9ub3NwYWNlJyxcbiAgICAnZm9udC1zaXplJzogICAgIDEwLFxuICAgICd0ZXh0LWFuY2hvcic6ICAgJ21pZGRsZScsXG59O1xuXG5mb250c1snc2lnbnMnXSA9IHtcbiAgICAnZm9udC1mYW1pbHknOiAnbW9ub3NwYWNlJyxcbiAgICAnZm9udC1zaXplJzogICAgIDUsXG4gICAgJ3RleHQtYW5jaG9yJzogICAnbWlkZGxlJyxcbn07XG5mb250c1snbGFiZWwnXSA9IHtcbiAgICAnZm9udC1mYW1pbHknOiAnbW9ub3NwYWNlJyxcbiAgICAnZm9udC1zaXplJzogICAgIDEyLFxuICAgICd0ZXh0LWFuY2hvcic6ICAgJ21pZGRsZScsXG59O1xuZm9udHNbJ3RpdGxlMSddID0ge1xuICAgICdmb250LWZhbWlseSc6ICdtb25vc3BhY2UnLFxuICAgICdmb250LXNpemUnOiAgICAgMTQsXG4gICAgJ3RleHQtYW5jaG9yJzogICAnbGVmdCcsXG59O1xuZm9udHNbJ3RpdGxlMiddID0ge1xuICAgICdmb250LWZhbWlseSc6ICdtb25vc3BhY2UnLFxuICAgICdmb250LXNpemUnOiAgICAgMTIsXG4gICAgJ3RleHQtYW5jaG9yJzogICAnbGVmdCcsXG59O1xuZm9udHNbJ3RpdGxlMyddID0ge1xuICAgICdmb250LWZhbWlseSc6ICdtb25vc3BhY2UnLFxuICAgICdmb250LXNpemUnOiAgICAgMTAsXG4gICAgJ3RleHQtYW5jaG9yJzogICAnbGVmdCcsXG59O1xuZm9udHNbJ3RpdGxlX0ZTRUMnXSA9IHtcbiAgICAnZm9udC1mYW1pbHknOiAnbW9ub3NwYWNlJyxcbiAgICAnZm9udC1zaXplJzogICAgIDgsXG4gICAgJ3RleHQtYW5jaG9yJzogICAnbWlkZGxlJyxcbn07XG5cblxuXG5cbmZvbnRzWydpbnN0YWxsZXJfaW5mbyddID0ge1xuICAgICdmb250LWZhbWlseSc6ICdtb25vc3BhY2UnLFxuICAgICdmb250LXNpemUnOiAgICAgNixcbiAgICAndGV4dC1hbmNob3InOiAgICdtaWRkbGUnLFxufTtcbmZvbnRzWydzaGVldF9udW0nXSA9IHtcbiAgICAnZm9udC1mYW1pbHknOiAnbW9ub3NwYWNlJyxcbiAgICAnZm9udC1zaXplJzogICAgIDE2LFxuICAgICd0ZXh0LWFuY2hvcic6ICAgJ21pZGRsZScsXG59O1xuZm9udHNbJ2JvcmRlcl9pbmZvJ10gPSB7XG4gICAgJ2ZvbnQtZmFtaWx5JzogJ21vbm9zcGFjZScsXG4gICAgJ2ZvbnQtc2l6ZSc6ICAgICA2LFxuICAgICd0ZXh0LWFuY2hvcic6ICAgJ2xlZnQnLFxufTtcblxuXG5cblxuZm9udHNbJ3RhYmxlJ10gPSB7XG4gICAgJ2ZvbnQtZmFtaWx5JzogJ3NlcmlmJyxcbiAgICAnZm9udC1zaXplJzogICAgIDgsXG4gICAgJ3RleHQtYW5jaG9yJzogICAnbWlkZGxlJyxcbn07XG5mb250c1sndGFibGVfbGVmdCddID0ge1xuICAgICdmb250LWZhbWlseSc6ICdzZXJpZicsXG4gICAgJ2ZvbnQtc2l6ZSc6ICAgICA4LFxuICAgICd0ZXh0LWFuY2hvcic6ICAgJ2xlZnQnLFxufTtcbmZvbnRzWyd0YWJsZV9sYXJnZV9sZWZ0J10gPSB7XG4gICAgJ2ZvbnQtZmFtaWx5JzogJ21vbm9zcGFjZScsXG4gICAgJ2ZvbnQtc2l6ZSc6ICAgICAxNCxcbiAgICAndGV4dC1hbmNob3InOiAgICdsZWZ0Jyxcbn07XG5mb250c1sndGFibGVfbGFyZ2UnXSA9IHtcbiAgICAnZm9udC1mYW1pbHknOiAnbW9ub3NwYWNlJyxcbiAgICAnZm9udC1zaXplJzogICAgIDE0LFxuICAgICd0ZXh0LWFuY2hvcic6ICAgJ21pZGRsZScsXG59O1xuZm9udHNbJ3Byb2plY3QgdGl0bGUnXSA9IHtcbiAgICAnZm9udC1mYW1pbHknOiAnbW9ub3NwYWNlJyxcbiAgICAnZm9udC1zaXplJzogICAgIDE2LFxuICAgICd0ZXh0LWFuY2hvcic6ICAgJ21pZGRsZScsXG59O1xuZm9udHNbJ3ByZXZpZXcgdGV4dCddID0ge1xuICAgICdmb250LWZhbWlseSc6ICdtb25vc3BhY2UnLFxuICAgICdmb250LXNpemUnICA6IDIwLFxuICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnLFxufTtcbmZvbnRzWydkaW1lbnRpb24nXSA9IHtcbiAgICAnZm9udC1mYW1pbHknOiAnbW9ub3NwYWNlJyxcbiAgICAnZm9udC1zaXplJyAgOiAyMCxcbiAgICAndGV4dC1hbmNob3InOiAnbWlkZGxlJyxcbn07XG5cblxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmb250cztcbiIsIi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cbmlmICghT2JqZWN0LmFzc2lnbikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoT2JqZWN0LCBcImFzc2lnblwiLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbih0YXJnZXQsIGZpcnN0U291cmNlKSB7XG4gICAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY29udmVydCBmaXJzdCBhcmd1bWVudCB0byBvYmplY3RcIik7XG4gICAgICB2YXIgdG8gPSBPYmplY3QodGFyZ2V0KTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXh0U291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAobmV4dFNvdXJjZSA9PT0gdW5kZWZpbmVkIHx8IG5leHRTb3VyY2UgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICB2YXIga2V5c0FycmF5ID0gT2JqZWN0LmtleXMoT2JqZWN0KG5leHRTb3VyY2UpKTtcbiAgICAgICAgZm9yICh2YXIgbmV4dEluZGV4ID0gMCwgbGVuID0ga2V5c0FycmF5Lmxlbmd0aDsgbmV4dEluZGV4IDwgbGVuOyBuZXh0SW5kZXgrKykge1xuICAgICAgICAgIHZhciBuZXh0S2V5ID0ga2V5c0FycmF5W25leHRJbmRleF07XG4gICAgICAgICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5leHRTb3VyY2UsIG5leHRLZXkpO1xuICAgICAgICAgIGlmIChkZXNjICE9PSB1bmRlZmluZWQgJiYgZGVzYy5lbnVtZXJhYmxlKSB0b1tuZXh0S2V5XSA9IG5leHRTb3VyY2VbbmV4dEtleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0bztcbiAgICB9XG4gIH0pO1xufVxuXG5cbnZhciBsYXllcl9hdHRyID0ge307XG5cbmxheWVyX2F0dHIuaW1hZ2UgPSB7fTtcblxubGF5ZXJfYXR0ci5iYXNlID0ge1xuICAgICdmaWxsJzogJ25vbmUnLFxuICAgICdzdHJva2UnOicjMDAwMDAwJyxcbiAgICAnc3Ryb2tlLXdpZHRoJzonMXB4JyxcbiAgICAnc3Ryb2tlLWxpbmVjYXAnOididXR0JyxcbiAgICAnc3Ryb2tlLWxpbmVqb2luJzonbWl0ZXInLFxuICAgICdzdHJva2Utb3BhY2l0eSc6MSxcblxufTtcbmxheWVyX2F0dHIuYmxvY2sgPSBPYmplY3QuY3JlYXRlKGxheWVyX2F0dHIuYmFzZSk7XG5sYXllcl9hdHRyLmZyYW1lID0gT2JqZWN0LmNyZWF0ZShsYXllcl9hdHRyLmJhc2UpO1xubGF5ZXJfYXR0ci5mcmFtZS5zdHJva2UgPSAnIzAwMDA0Mic7XG5sYXllcl9hdHRyLnRhYmxlID0gT2JqZWN0LmNyZWF0ZShsYXllcl9hdHRyLmJhc2UpO1xubGF5ZXJfYXR0ci50YWJsZS5zdHJva2UgPSAnIzAwMDAwMCc7XG5cbmxheWVyX2F0dHIuRENfaW50ZXJtb2R1bGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobGF5ZXJfYXR0ci5iYXNlKSx7XG4gICAgc3Ryb2tlOiAnI2JlYmViZScsXG4gICAgXCJzdHJva2UtZGFzaGFycmF5XCI6IFwiMSwgMVwiLFxuXG5cbn0pO1xuXG5sYXllcl9hdHRyLkRDX3BvcyA9IE9iamVjdC5jcmVhdGUobGF5ZXJfYXR0ci5iYXNlKTtcbmxheWVyX2F0dHIuRENfcG9zLnN0cm9rZSA9ICcjZmYwMDAwJztcbmxheWVyX2F0dHIuRENfbmVnID0gT2JqZWN0LmNyZWF0ZShsYXllcl9hdHRyLmJhc2UpO1xubGF5ZXJfYXR0ci5EQ19uZWcuc3Ryb2tlID0gJyMwMDAwMDAnO1xubGF5ZXJfYXR0ci5EQ19ncm91bmQgPSBPYmplY3QuY3JlYXRlKGxheWVyX2F0dHIuYmFzZSk7XG5sYXllcl9hdHRyLkRDX2dyb3VuZC5zdHJva2UgPSAnIzAwNjYwMCc7XG5sYXllcl9hdHRyLm1vZHVsZSA9IE9iamVjdC5jcmVhdGUobGF5ZXJfYXR0ci5iYXNlKTtcbmxheWVyX2F0dHIuYm94ID0gT2JqZWN0LmNyZWF0ZShsYXllcl9hdHRyLmJhc2UpO1xuXG5cblxubGF5ZXJfYXR0ci50ZXh0ID0gT2JqZWN0LmNyZWF0ZShsYXllcl9hdHRyLmJhc2UpO1xubGF5ZXJfYXR0ci50ZXh0LnN0cm9rZSA9ICcjMDAwMGZmJztcbmxheWVyX2F0dHIudGVybWluYWwgPSBPYmplY3QuY3JlYXRlKGxheWVyX2F0dHIuYmFzZSk7XG5cblxubGF5ZXJfYXR0ci5BQ19ncm91bmQgPSBPYmplY3QuY3JlYXRlKGxheWVyX2F0dHIuYmFzZSk7XG5sYXllcl9hdHRyLkFDX2dyb3VuZC5zdHJva2UgPSAnIzAwOTkwMCc7XG5sYXllcl9hdHRyLkFDX25ldXRyYWwgPSBPYmplY3QuY3JlYXRlKGxheWVyX2F0dHIuYmFzZSk7XG5sYXllcl9hdHRyLkFDX25ldXRyYWwuc3Ryb2tlID0gJyM5OTk3OTcnO1xubGF5ZXJfYXR0ci5BQ19MMSA9IE9iamVjdC5jcmVhdGUobGF5ZXJfYXR0ci5iYXNlKTtcbmxheWVyX2F0dHIuQUNfTDEuc3Ryb2tlID0gJyMwMDAwMDAnO1xubGF5ZXJfYXR0ci5BQ19MMiA9IE9iamVjdC5jcmVhdGUobGF5ZXJfYXR0ci5iYXNlKTtcbmxheWVyX2F0dHIuQUNfTDIuc3Ryb2tlID0gJyNGRjAwMDAnO1xubGF5ZXJfYXR0ci5BQ19MMyA9IE9iamVjdC5jcmVhdGUobGF5ZXJfYXR0ci5iYXNlKTtcbmxheWVyX2F0dHIuQUNfTDMuc3Ryb2tlID0gJyMwMDAwRkYnO1xuXG5cbmxheWVyX2F0dHIucHJldmlldyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShsYXllcl9hdHRyLmJhc2UpLHtcbiAgICAnc3Ryb2tlLXdpZHRoJzogJzInLFxufSk7XG5cbmxheWVyX2F0dHIucHJldmlld19tb2R1bGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobGF5ZXJfYXR0ci5wcmV2aWV3KSx7XG4gICAgZmlsbDogJyNmZmIzMDAnLFxuICAgIHN0cm9rZTogJ25vbmUnLFxufSk7XG5cbmxheWVyX2F0dHIucHJldmlld19hcnJheSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShsYXllcl9hdHRyLnByZXZpZXcpLHtcbiAgICBzdHJva2U6ICcjZmY1ZDAwJyxcbn0pO1xuXG5sYXllcl9hdHRyLnByZXZpZXdfREMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobGF5ZXJfYXR0ci5wcmV2aWV3KSx7XG4gICAgc3Ryb2tlOiAnI2IwOTJjNCcsXG59KTtcbmxheWVyX2F0dHIucHJldmlld19EQ19ib3ggPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobGF5ZXJfYXR0ci5wcmV2aWV3KSx7XG4gICAgZmlsbDogJyNiMDkyYzQnLFxuICAgIHN0cm9rZTogJ25vbmUnLFxufSk7XG5cbmxheWVyX2F0dHIucHJldmlld19pbnZlcnRlciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShsYXllcl9hdHRyLnByZXZpZXcpLHtcbiAgICBzdHJva2U6JyM4NmM5NzQnLFxufSk7XG5sYXllcl9hdHRyLnByZXZpZXdfaW52ZXJ0ZXJfYm94ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKGxheWVyX2F0dHIucHJldmlldykse1xuICAgIGZpbGw6ICcjODZjOTc0JyxcbiAgICBzdHJva2U6ICdub25lJyxcbn0pO1xuXG5sYXllcl9hdHRyLnByZXZpZXdfQUMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobGF5ZXJfYXR0ci5wcmV2aWV3KSx7XG4gICAgc3Ryb2tlOiAnIzgxODhhMScsXG59KTtcblxubGF5ZXJfYXR0ci5wcmV2aWV3X0FDX2JveCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShsYXllcl9hdHRyLnByZXZpZXcpLHtcbiAgICBmaWxsOiAnIzgxODhhMScsXG4gICAgc3Ryb2tlOiAnbm9uZScsXG59KTtcblxubGF5ZXJfYXR0ci5wcmV2aWV3X3N0cnVjdHVyYWwgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobGF5ZXJfYXR0ci5wcmV2aWV3KSx7XG4gICAgc3Ryb2tlOiAnIzAwMDAwMCcsXG59KTtcbmxheWVyX2F0dHIucHJldmlld19zdHJ1Y3R1cmFsX2RvdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShsYXllcl9hdHRyLnByZXZpZXcpLHtcbiAgICBzdHJva2U6ICcjMDAwMDAwJyxcbiAgICBcInN0cm9rZS1kYXNoYXJyYXlcIjogXCI1LCA1XCJcbn0pO1xubGF5ZXJfYXR0ci5wcmV2aWV3X3N0cnVjdHVyYWxfcG9seV91bnNlbGVjdGVkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKGxheWVyX2F0dHIucHJldmlldykse1xuICAgIGZpbGw6ICcjZTFlMWUxJyxcbiAgICBzdHJva2U6ICdub25lJ1xufSk7XG5sYXllcl9hdHRyLnByZXZpZXdfc3RydWN0dXJhbF9wb2x5X3NlbGVjdGVkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKGxheWVyX2F0dHIucHJldmlldykse1xuICAgIGZpbGw6ICcjZmZlN2NiJyxcbiAgICBzdHJva2U6ICdub25lJ1xufSk7XG5sYXllcl9hdHRyLnByZXZpZXdfc3RydWN0dXJhbF9wb2x5X3NlbGVjdGVkX2ZyYW1lZCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShsYXllcl9hdHRyLnByZXZpZXcpLHtcbiAgICBmaWxsOiAnI2ZmZTdjYicsXG4gICAgc3Ryb2tlOiAnIzAwMDAwMCdcbn0pO1xuXG5sYXllcl9hdHRyLnByZXZpZXdfc3RydWN0dXJhbF9tb2R1bGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobGF5ZXJfYXR0ci5wcmV2aWV3KSx7XG4gICAgZmlsbDogJyNmZmZmZmYnLFxuICAgIHN0cm9rZTogJ25vbmUnXG59KTtcbmxheWVyX2F0dHIucHJldmlld19zdHJ1Y3R1cmFsX21vZHVsZV9zZWxlY3RlZCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShsYXllcl9hdHRyLnByZXZpZXcpLHtcbiAgICBmaWxsOiAnIzgzOTdlOCcsXG4gICAgc3Ryb2tlOiAnI2RmZmFmZidcbn0pO1xuXG5sYXllcl9hdHRyLm5vcnRoX2Fycm93ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKGxheWVyX2F0dHIucHJldmlldykse1xuICAgIHN0cm9rZTogJyMwMDAwMDAnLFxuICAgICdzdHJva2Utd2lkdGgnOiAxLFxuICAgICdzdHJva2UtbGluZWNhcCc6IFwicm91bmRcIixcbiAgICAnc3Ryb2tlLWxpbmVqb2luJzogXCJyb3VuZFwiLFxufSk7XG5sYXllcl9hdHRyLm5vcnRoX2xldHRlciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShsYXllcl9hdHRyLnByZXZpZXcpLHtcbiAgICBzdHJva2U6ICcjOTQ5NDk0JyxcbiAgICAnc3Ryb2tlLXdpZHRoJzogNSxcbiAgICAnc3Ryb2tlLWxpbmVjYXAnOiBcInJvdW5kXCIsXG4gICAgJ3N0cm9rZS1saW5lam9pbic6IFwicm91bmRcIixcbn0pO1xuXG5sYXllcl9hdHRyLmRpbWVudGlvbiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShsYXllcl9hdHRyLnRleHQpLHtcbiAgICBzdHJva2U6ICcjMTQzM2ZlJyxcbn0pO1xuXG5sYXllcl9hdHRyLmJvcmRlciA9IE9iamVjdC5jcmVhdGUobGF5ZXJfYXR0ci5iYXNlKTtcblxubGF5ZXJfYXR0clsnYm9yZGVyX2xpbmVzJ10gPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobGF5ZXJfYXR0ci50ZXh0KSx7XG4gICAgc3Ryb2tlOiAnIzhlOGU4ZScsXG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGxheWVyX2F0dHI7XG4iLCJcblxuXG5mdW5jdGlvbiBzZXR1cF93ZWJwYWdlKCl7XG4gICAgdmFyIHNldHRpbmdzID0gZztcbiAgICB2YXIgZiA9IGcuZjtcblxuICAgIHZhciBzeXN0ZW1fZnJhbWVfaWQgPSAnc3lzdGVtX2ZyYW1lJztcbiAgICB2YXIgdGl0bGUgPSAnUFYgZHJhd2luZyB0ZXN0JztcblxuICAgIGcuZi5zZXR1cF9ib2R5KHRpdGxlKTtcblxuICAgIHZhciBwYWdlID0gJCgnPGRpdj4nKS5hdHRyKCdjbGFzcycsICdwYWdlJykuYXBwZW5kVG8oJChkb2N1bWVudC5ib2R5KSk7XG4gICAgLy9wYWdlLnN0eWxlKCd3aWR0aCcsIChzZXR0aW5ncy5kcmF3aW5nX3NldHRpbmdzLnNpemUuZHJhd2luZy53KzIwKS50b1N0cmluZygpICsgJ3B4JyApXG5cbiAgICB2YXIgc3lzdGVtX2ZyYW1lID0gJCgnPGRpdj4nKS5hdHRyKCdpZCcsIHN5c3RlbV9mcmFtZV9pZCkuYXBwZW5kVG8ocGFnZSk7XG5cblxuICAgIHZhciBoZWFkZXJfY29udGFpbmVyID0gJCgnPGRpdj4nKS5hcHBlbmRUbyhzeXN0ZW1fZnJhbWUpO1xuICAgICQoJzxpbWc+JylcbiAgICAgICAgLmF0dHIoJ3NyYycsICdkYXRhL1BsYW5zTWFjaGluZS5wbmcnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAndGl0bGVfaW1hZ2UnKVxuICAgICAgICAvLy5hdHRyKCd3aWR0aCcsICc5MCUnKVxuICAgICAgICAuYXBwZW5kVG8oaGVhZGVyX2NvbnRhaW5lcik7XG4gICAgJCgnPGRpdj4nKS5hdHRyKCdjbGFzcycsICdzdWJ0aXRsZScpLmFwcGVuZFRvKGhlYWRlcl9jb250YWluZXIpLmFwcGVuZChcbiAgICAgICAgJCgnPHNwYW4+JykuaHRtbCgnUGxlYXNlIHNlbGVjdCB5b3VyIHN5c3RlbSBzcGVjIGJlbG93JykuYXR0cignY2xhc3MnLCAnY2F0ZWdvcnlfdGl0bGUnKS5hcHBlbmRUbyhoZWFkZXJfY29udGFpbmVyKSxcbiAgICAgICAgJCgnPHNwYW4+JykuaHRtbCgnIHwgJykuYXBwZW5kVG8oaGVhZGVyX2NvbnRhaW5lciksXG4gICAgICAgIC8vJCgnPGlucHV0PicpLmF0dHIoJ3R5cGUnLCAnYnV0dG9uJykuYXR0cigndmFsdWUnLCAnY2xlYXIgc2VsZWN0aW9ucycpLmNsaWNrKHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQpLFxuICAgICAgICAkKCc8YT4nKS5hdHRyKCdocmVmJywgJ2phdmFzY3JpcHQ6d2luZG93LmxvY2F0aW9uLnJlbG9hZCgpJykuaHRtbCgnY2xlYXIgc2VsZWN0aW9ucycpLmFwcGVuZFRvKGhlYWRlcl9jb250YWluZXIpXG5cbiAgICApO1xuXG5cbiAgICAvLyBTeXN0ZW0gc2V0dXBcbiAgICB2YXIgY29uZmlnX2ZyYW1lID0gJCgnPGRpdj4nKS5hdHRyKCdpZCcsICdjb25maWdfZnJhbWUnKS5hcHBlbmRUbyhzeXN0ZW1fZnJhbWUpO1xuXG4gICAgZy5mLmFkZF9kcmF3ZXJzKHNldHRpbmdzLCBjb25maWdfZnJhbWUpO1xuXG4gICAgLy9jb25zb2xlLmxvZyhzZWN0aW9uX3NlbGVjdG9yKTtcblxuXG5cbiAgICAvL3ZhciBsb2NhdGlvbl9kcmF3ZXIgPSAkKCcjc2VjdGlvbl9sb2NhdGlvbicpLmNoaWxkcmVuKCcuZHJhd2VyJykuY2hpbGRyZW4oJy5kcmF3ZXJfY29udGVudCcpO1xuICAgIC8vY29uc29sZS5sb2cobG9jYXRpb25fZHJhd2VyKTtcblxuXG4gICAgdmFyIG1hcF9kaXYgPSAkKCc8ZGl2PicpO1xuICAgIHZhciBtYXBfZHJhd2VyID0gZi5ta19kcmF3ZXIoJ21hcCcsbWFwX2RpdilcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vLmFwcGVuZFRvKGNvbmZpZ19mcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0QWZ0ZXIoICQoJyNzZWN0aW9uX2xvY2F0aW9uJykgKTtcbiAgICBtYXBfZHJhd2VyLmNoaWxkcmVuKCcuZHJhd2VyJykuY2hpbGRyZW4oJy5kcmF3ZXJfY29udGVudCcpLnNsaWRlVXAoJ2Zhc3QnKTtcblxuXG5cbiAgICB2YXIgbGlzdF9lbGVtZW50ID0gJCgnPHVsPicpLmFwcGVuZFRvKG1hcF9kaXYpO1xuICAgICQoJzxsaT4nKS5hcHBlbmRUbyhsaXN0X2VsZW1lbnQpLmFwcGVuZChcbiAgICAgICAgJCgnPGE+JylcbiAgICAgICAgICAgIC50ZXh0KCdXaW5kIFpvbmUgJylcbiAgICAgICAgICAgIC5hdHRyKCdocmVmJywgJ2h0dHA6Ly93aW5kc3BlZWQuYXRjb3VuY2lsLm9yZy8nKVxuICAgICAgICAgICAgLmF0dHIoJ3RhcmdldCcsICdfYmxhbmsnKVxuICAgICk7XG4gICAgJCgnPGxpPicpLmFwcGVuZFRvKGxpc3RfZWxlbWVudCkuYXBwZW5kKFxuICAgICAgICAkKCc8YT4nKVxuICAgICAgICAgICAgLnRleHQoJ0NsaW1hdGUgQ29uZGl0aW9ucycpXG4gICAgICAgICAgICAuYXR0cignaHJlZicsICdodHRwOi8vd3d3LnNvbGFyYWJjcy5vcmcvYWJvdXQvcHVibGljYXRpb25zL3JlcG9ydHMvZXhwZWRpdGVkLXBlcm1pdC9tYXAvaW5kZXguaHRtbCcpXG4gICAgICAgICAgICAuYXR0cigndGFyZ2V0JywgJ19ibGFuaycpXG4gICAgKTtcblxuLy8qXG4gICAgdmFyIGdlb2NvZGVfZGl2ID0gJCgnPGRpdj4nKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnZ2VvY29kZV9saW5lJylcbiAgICAgICAgLmFwcGVuZFRvKG1hcF9kaXYpO1xuICAgICQoJzxhPicpLmFwcGVuZFRvKGdlb2NvZGVfZGl2KVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnZ2VvY29kZV9idXR0b24nKVxuICAgICAgICAudGV4dCgnRmluZCBsb2NhdGlvbiBmcm9tIGFkZHJlc3MnKVxuICAgICAgICAuYXR0cignaHJlZicsICcjJylcbiAgICAgICAgLmNsaWNrKGYucmVxdWVzdF9nZW9jb2RlKTtcbiAgICAkKCc8c3Bhbj4nKS5hcHBlbmRUbyhnZW9jb2RlX2RpdilcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2dlb2NvZGVfZGlzcGxheScpXG4gICAgICAgIC5hdHRyKCdpZCcsJ2dlb2NvZGVfZGlzcGxheScpXG4gICAgICAgIC50ZXh0KCcnKTtcblxuICAgICQoJzxkaXY+JylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ21hcF9yb2FkJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ21hcF9yb2FkJylcbiAgICAgICAgLmF0dHIoJ3N0eWxlJywgJ3dpZHRoOjQ4NXB4O2hlaWdodDozODBweCcpXG4gICAgICAgIC5hcHBlbmRUbyhtYXBfZGl2KTtcbiAgICAkKCc8ZGl2PicpXG4gICAgICAgIC5hdHRyKCdpZCcsICdtYXBfc2F0JylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ21hcF9zYXQnKVxuICAgICAgICAuYXR0cignc3R5bGUnLCAnd2lkdGg6NDg1cHg7aGVpZ2h0OjM4MHB4JylcbiAgICAgICAgLmFwcGVuZFRvKG1hcF9kaXYpO1xuXG5cbiAgICB2YXIgbGF0X2ZsX2NlbnRlciA9IDI3Ljc1O1xuICAgIHZhciBsb25fZmxfY2VudGVyID0gLTg0LjA7XG5cbiAgICB2YXIgbGF0ID0gMjguMzg3Mzk5O1xuICAgIHZhciBsb24gPSAtODAuNzU3ODMzO1xuICAgIHZhciBjb29yID0gWy04MC43NTc4MzMsIDI4LjM4NzM5OV07XG5cbiAgICBMLkF3ZXNvbWVNYXJrZXJzLkljb24ucHJvdG90eXBlLm9wdGlvbnMucHJlZml4ID0gJ2ZhJztcbiAgICB2YXIgc3VuX21hcmtlciA9IEwuQXdlc29tZU1hcmtlcnMuaWNvbih7XG4gICAgICAgIGljb246ICdzdW4tbycsXG4gICAgICAgIG1hcmtlckNvbG9yOiAnYmx1ZSAgJyxcbiAgICAgICAgaWNvbkNvbG9yOiAneWVsbG93J1xuICAgIH0pO1xuXG4gICAgdmFyIG1hcF9yb2FkICA9IGcucGVybS5tYXBzLm1hcF9yb2FkID0gTC5tYXAoICdtYXBfcm9hZCcsIHtcbiAgICAgICAgY2VudGVyOiBbbGF0X2ZsX2NlbnRlciwgbG9uX2ZsX2NlbnRlcl0sXG4gICAgICAgIHpvb206IDZcbiAgICB9KTtcblxuICAgIEwudGlsZUxheWVyKCAnaHR0cDovL3tzfS5tcWNkbi5jb20vdGlsZXMvMS4wLjAvbWFwL3t6fS97eH0ve3l9LnBuZycsIHtcbiAgICAgICAgYXR0cmlidXRpb246ICcmY29weTsgPGEgaHJlZj1cImh0dHA6Ly9vc20ub3JnL2NvcHlyaWdodFwiIHRpdGxlPVwiT3BlblN0cmVldE1hcFwiIHRhcmdldD1cIl9ibGFua1wiPk9wZW5TdHJlZXRNYXA8L2E+IGNvbnRyaWJ1dG9ycyB8IFRpbGVzIENvdXJ0ZXN5IG9mIDxhIGhyZWY9XCJodHRwOi8vd3d3Lm1hcHF1ZXN0LmNvbS9cIiB0aXRsZT1cIk1hcFF1ZXN0XCIgdGFyZ2V0PVwiX2JsYW5rXCI+TWFwUXVlc3Q8L2E+IDxpbWcgc3JjPVwiaHR0cDovL2RldmVsb3Blci5tYXBxdWVzdC5jb20vY29udGVudC9vc20vbXFfbG9nby5wbmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIj4nLFxuICAgICAgICBzdWJkb21haW5zOiBbJ290aWxlMScsJ290aWxlMicsJ290aWxlMycsJ290aWxlNCddXG4gICAgfSkuYWRkVG8oIG1hcF9yb2FkICk7XG5cbiAgICBnLnBlcm0ubWFwcy5tYXJrZXJfcm9hZCA9IEwubWFya2VyKFtsYXQsbG9uXSwge2ljb246IHN1bl9tYXJrZXJ9KS5hZGRUbyhtYXBfcm9hZCk7XG5cbiAgICBtYXBfcm9hZC5vbignY2xpY2snLCBmLnNldF9jb29yZGluYXRlc19mcm9tX21hcCApO1xuXG5cblxuXG4gICAgdmFyIG1hcF9zYXQgPSBnLnBlcm0ubWFwcy5tYXBfc2F0ID0gTC5tYXAoICdtYXBfc2F0Jywge1xuICAgICAgICBjZW50ZXI6IFtsYXQsIGxvbl0sXG4gICAgICAgIHpvb206IDE2XG4gICAgfSk7XG4gICAgTC50aWxlTGF5ZXIoICdodHRwOi8ve3N9Lm1xY2RuLmNvbS90aWxlcy8xLjAuMC9zYXQve3p9L3t4fS97eX0ucG5nJywge1xuICAgICAgICBzdWJkb21haW5zOiBbJ290aWxlMScsJ290aWxlMicsJ290aWxlMycsJ290aWxlNCddXG4gICAgfSkuYWRkVG8oIG1hcF9zYXQgKTtcblxuICAgIGcucGVybS5tYXBzLm1hcmtlcl9zYXQgPSBMLm1hcmtlcihbbGF0LGxvbl0sIHtpY29uOiBzdW5fbWFya2VyfSkuYWRkVG8obWFwX3NhdCk7XG5cbiAgICBtYXBfc2F0Lm9uKCdjbGljaycsIGYuc2V0X2Nvb3JkaW5hdGVzX2Zyb21fbWFwICk7XG4vLyovXG5cblxuXG5cblxuXG5cbiAgICB2YXIgZHJhd2luZ19zZWN0aW9uID0gJCgnPGRpdj4nKS5hdHRyKCdpZCcsICdkcmF3aW5nX2ZyYW1lJykuYXBwZW5kVG8ocGFnZSk7XG4gICAgLy9kcmF3aW5nLmNzcygnd2lkdGgnLCAoc2V0dGluZ3MuZHJhd2luZ19zZXR0aW5ncy5zaXplLmRyYXdpbmcudysyMCkudG9TdHJpbmcoKSArICdweCcgKTtcblxuXG4gICAgLy8kKCc8Zm9ybSBtZXRob2Q9XCJnZXRcIiBhY3Rpb249XCJkYXRhL3NhbXBsZS5wZGZcIj48YnV0dG9uIHR5cGU9XCJzdWJtaXRcIj5Eb3dubG9hZDwvYnV0dG9uPjwvZm9ybT4nKS5hcHBlbmRUbyhkcmF3aW5nX3NlY3Rpb24pO1xuICAgIC8vJCgnPHNwYW4+JykuYXR0cignaWQnLCAnZG93bmxvYWQnKS5hdHRyKCdjbGFzcycsICdmbG9hdF9yaWdodCcpLmFwcGVuZFRvKGRyYXdpbmdfc2VjdGlvbik7XG4gICAgJCgnPGE+JylcbiAgICAgICAgLnRleHQoJ0Rvd25sb2FkIERyYXdpbmcgKHNhbXBsZSknKVxuICAgICAgICAuYXR0cignaHJlZicsICdzYW1wbGVfcGRmL3NhbXBsZS5wZGYnKVxuICAgICAgICAuYXR0cignaWQnLCAnZG93bmxvYWQnKVxuICAgICAgICAuYXR0cignY2xhc3MnLCAnYnV0dG9uX2Zsb2F0X3JpZ2h0JylcbiAgICAgICAgLmF0dHIoJ3RhcmdldCcsICdfYmxhbmsnKVxuICAgICAgICAuYXBwZW5kVG8oZHJhd2luZ19zZWN0aW9uKTtcbiAgICAkKCc8YT4nKVxuICAgICAgICAudGV4dCgnRG93bmxvYWQgRHJhd2luZyAobmV0d29yayB0ZXN0LCBvbmNlKScpXG4gICAgICAgIC8vLmF0dHIoJ2hyZWYnLCAnIycpXG4gICAgICAgIC5hdHRyKCdpZCcsICdkb3dubG9hZCcpXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdidXR0b25fZmxvYXRfcmlnaHQnKVxuICAgICAgICAvLy5hdHRyKCd0YXJnZXQnLCAnX2JsYW5rJylcbiAgICAgICAgLmFwcGVuZFRvKGRyYXdpbmdfc2VjdGlvbilcbiAgICAgICAgLmNsaWNrKGYucmVxdWVzdF9TVkcpO1xuICAgICQoJzxhPicpXG4gICAgICAgIC50ZXh0KCdEb3dubG9hZCBEcmF3aW5nIChuZXR3b3JrIHRlc3QsIHJlcGVhdHMpJylcbiAgICAgICAgLy8uYXR0cignaHJlZicsICcjJylcbiAgICAgICAgLmF0dHIoJ2lkJywgJ2Rvd25sb2FkJylcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2J1dHRvbl9mbG9hdF9yaWdodCcpXG4gICAgICAgIC8vLmF0dHIoJ3RhcmdldCcsICdfYmxhbmsnKVxuICAgICAgICAuYXBwZW5kVG8oZHJhd2luZ19zZWN0aW9uKVxuICAgICAgICAuY2xpY2soZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNldEludGVydmFsKGcuZi5yZXF1ZXN0X1NWRywgMTAwMCk7XG4gICAgICAgIH0pO1xuXG4gICAgdmFyIHN2Z19jb250YWluZXJfb2JqZWN0ID0gJCgnPGRpdj4nKS5hdHRyKCdpZCcsICdkcmF3aW5nJykuYXR0cignY2xhc3MnLCAnZHJhd2luZycpLmNzcygnY2xlYXInLCAnYm90aCcpLmFwcGVuZFRvKGRyYXdpbmdfc2VjdGlvbik7XG4gICAgLy9zdmdfY29udGFpbmVyX29iamVjdC5zdHlsZSgnd2lkdGgnLCBzZXR0aW5ncy5kcmF3aW5nX3NldHRpbmdzLnNpemUuZHJhd2luZy53KydweCcgKVxuICAgIC8vdmFyIHN2Z19jb250YWluZXIgPSBzdmdfY29udGFpbmVyX29iamVjdC5lbGVtO1xuICAgICQoJzxicj4nKS5hcHBlbmRUbyhkcmF3aW5nX3NlY3Rpb24pO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICQoJzxkaXY+JykuaHRtbCgnICcpLmF0dHIoJ2NsYXNzJywgJ3NlY3Rpb25fdGl0bGUnKS5hcHBlbmRUbyhkcmF3aW5nX3NlY3Rpb24pO1xuXG59XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwX3dlYnBhZ2U7XG4iLCJcblxudmFyIHVwZGF0ZV93ZWJwYWdlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgc2V0dGluZ3MgPSBnO1xuICAgIHZhciBmID0gZy5mO1xuXG4gICAgLy8gTWFrZSBwcmV2aWV3XG5cblxuICAgIC8vIGNyZWF0ZSBwcmV2aWV3c1xuICAgIHNldHRpbmdzLmRyYXdpbmcucHJldmlld19wYXJ0cyA9IHt9O1xuICAgIHNldHRpbmdzLmRyYXdpbmcucHJldmlld19zdmdzID0ge307XG4gICAgZm9yKCB2YXIgbmFtZSBpbiBmLm1rX3ByZXZpZXcgKXsgIC8vIGYubWtfc2hlZXRfbnVtIGlzIGEgYXJyYXkgb2YgcGFnZSBtYWtpbmcgZnVuY3Rpb25zLCBzbyB0aGlzIHdpbGwgbG9vcCB0aHJvdWdoIHRoZSBudW1iZXIgb2YgcGFnZXNcbiAgICAgICAgc2V0dGluZ3MuZHJhd2luZy5wcmV2aWV3X3BhcnRzW25hbWVdID0gZi5ta19wcmV2aWV3W25hbWVdKHNldHRpbmdzKTtcbiAgICAgICAgc2V0dGluZ3MuZHJhd2luZy5wcmV2aWV3X3N2Z3NbbmFtZV0gPSBmLm1rX3N2ZyhzZXR0aW5ncy5kcmF3aW5nLnByZXZpZXdfcGFydHNbbmFtZV0sIHNldHRpbmdzLmRyYXdpbmdfc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aWV3X3RhYmxlID0ge1xuICAgICAgICAnc2VjdGlvbl9sb2NhdGlvbic6IFtdLFxuICAgICAgICAnc2VjdGlvbl9tYXAnOiBbXSxcbiAgICAgICAgJ3NlY3Rpb25fcm9vZic6IFsgc2V0dGluZ3MuZHJhd2luZy5wcmV2aWV3X3N2Z3NbJ3Jvb2YnXSBdLFxuICAgICAgICAnc2VjdGlvbl9tb2R1bGUnOiBbIHNldHRpbmdzLmRyYXdpbmcucHJldmlld19zdmdzWydlbGVjJ10sIHNldHRpbmdzLmRyYXdpbmcucHJldmlld19zdmdzWydyb29mJ10gXSxcbiAgICAgICAgJ3NlY3Rpb25fYXJyYXknOiBbIHNldHRpbmdzLmRyYXdpbmcucHJldmlld19zdmdzWydlbGVjJ10gXSxcbiAgICAgICAgJ3NlY3Rpb25fREMnOiBbIHNldHRpbmdzLmRyYXdpbmcucHJldmlld19zdmdzWydlbGVjJ10gXSxcbiAgICAgICAgJ3NlY3Rpb25faW52ZXJ0ZXInOiBbIHNldHRpbmdzLmRyYXdpbmcucHJldmlld19zdmdzWydlbGVjJ10gXSxcbiAgICAgICAgJ3NlY3Rpb25fQUMnOiBbIHNldHRpbmdzLmRyYXdpbmcucHJldmlld19zdmdzWydlbGVjJ10gXSxcbiAgICAgICAgJ3NlY3Rpb25fYXR0YWNobWVudF9zeXN0ZW0nOiBbIHNldHRpbmdzLmRyYXdpbmcucHJldmlld19zdmdzWydyb29mJ10gXSxcbiAgICB9O1xuICAgIC8vY29uc29sZS5sb2coICQoJyNjb25maWdfZnJhbWUnKS5jaGlsZHJlbigpLm1hcChmdW5jdGlvbigpe3JldHVybiB0aGlzLmlkO30pLmdldCgpICk7XG4gICAgLy8kKCcjc2VjdGlvbl9sb2NhdGlvbicpXG4gICAgLy8gICAgLmFwcGVuZChzZXR0aW5ncy5kcmF3aW5nLnByZXZpZXdfc3Znc1snZWxlYyddKTtcbiAgICAvLyQoJyNzZWN0aW9uX21hcCcpXG4gICAgLy8gICAgLmFwcGVuZChzZXR0aW5ncy5kcmF3aW5nLnByZXZpZXdfc3Znc1snZWxlYyddKTtcblxuXG5cblxuLy8gdXBkYXRlIHdlYiBwYWdlXG4gICAgLy8gc2V0IG1hcHMgbWFya2Vyc1xuICAgIGlmKCBnLnBlcm0ubG9jYXRpb24ubGF0ICYmIGcucGVybS5sb2NhdGlvbi5sb24pIHtcbiAgICAgICAgZi5zZXRfc2F0X21hcF9tYXJrZXIoKTtcbiAgICB9XG5cbiAgICAvLyBjaGFuZ2UgdXNlciBpbnB1dHMgdG8gZGVmYXVsdHMgaWYgbmVlZGVkLlxuICAgIC8vIFRoaXMgYWxzbyB1cGRhdGVzIHRoZSBkcm9wIGxpc3QgZWxlbWVudHMgdGhhdCBhcmUgZGVwZW5kZW50IG9uIG90aGVyIGlucHV0cyAoIG1vZGVsIGxpc3QgaXMgYmFzZWQgb24gc2VsZWN0ZWQgbWFrZSkuXG4gICAgc2V0dGluZ3Muc2VsZWN0X3JlZ2lzdHJ5LmZvckVhY2goZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgICAgICBpZiggc2VsZWN0b3IudHlwZSA9PT0gJ3NlbGVjdCcgKXtcbiAgICAgICAgICAgIGYuc2VsZWN0b3JfYWRkX29wdGlvbnMoc2VsZWN0b3IpO1xuICAgICAgICB9IGVsc2UgaWYoIHNlbGVjdG9yLnR5cGUgPT09ICdudW1iZXJfaW5wdXQnIHx8IHNlbGVjdG9yLnR5cGUgPT09ICd0ZXh0X2lucHV0JyApIHtcbiAgICAgICAgICAgIHNlbGVjdG9yLmVsZW0udmFsdWUgPSBzZWxlY3Rvci5zeXN0ZW1fcmVmLmdldCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBEZXRlcm1pbmUgYWN0aXZlIHNlY3Rpb24gYmFzZWQgb24gc2VjdGlvbiBpbnB1dHMgZW50ZXJlZCBieSB1c2VyXG4gICAgdmFyIHNlY3Rpb25zID0gZy53ZWJwYWdlLnNlY3Rpb25zO1xuICAgIHZhciBhY3RpdmVfc2VjdGlvbjtcbiAgICBzZWN0aW9ucy5ldmVyeShmdW5jdGlvbihzZWN0aW9uX25hbWUsaWQpeyAvL1RPRE86IGZpbmQgcHJlIElFOSB3YXkgdG8gZG8gdGhpcz9cbiAgICAgICAgaWYoICEgZy5mLnNlY3Rpb25fZGVmaW5lZChnLCBzZWN0aW9uX25hbWUpICl7XG4gICAgICAgICAgICBhY3RpdmVfc2VjdGlvbiA9IHNlY3Rpb25fbmFtZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhY3RpdmUgc2VjdGlvbjonLCBzZWN0aW9uX25hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoIGlkID09PSBzZWN0aW9ucy5sZW5ndGgtMSApeyAvL0lmIGxhc3Qgc2VjdGlvbiBpcyBkZWZpbmVkLCB0aGVyZSBpcyBubyBhY3RpdmUgc2VjdGlvblxuICAgICAgICAgICAgICAgIGFjdGl2ZV9zZWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2xvc2Ugc2VjdGlvbiBpZiB0aGV5IGFyZSBub3QgYWN0aXZlIHNlY3Rpb25zLCB1bmxlc3MgdGhleSBoYXZlIGJlZW4gb3BlbmVkIGJ5IHRoZSB1c2VyLCBvcGVuIHRoZSBhY3RpdmUgc2VjdGlvblxuICAgIHNlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc2VjdGlvbl9uYW1lLGlkKXsgLy9UT0RPOiBmaW5kIHByZSBJRTkgd2F5IHRvIGRvIHRoaXM/XG4gICAgICAgIHZhciBzdmdfZHJhd2luZ19jb250YWluZXIgPSAkKCcjc2VjdGlvbl8nK3NlY3Rpb25fbmFtZSkuY2hpbGRyZW4oJy5kcmF3ZXInKS5jaGlsZHJlbignLmRyYXdlcl9jb250ZW50JykuY2hpbGRyZW4oJy5zdmdfZHJhd2luZ19jb250YWluZXInKTtcbiAgICAgICAgc3ZnX2RyYXdpbmdfY29udGFpbmVyLmVtcHR5KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKHNlY3Rpb25fbmFtZSk7XG4gICAgICAgIHByZXZpZXdfdGFibGVbJ3NlY3Rpb25fJytzZWN0aW9uX25hbWVdLmZvckVhY2goZnVuY3Rpb24ocHJldmlld19zdmcpe1xuICAgICAgICAgICAgc3ZnX2RyYXdpbmdfY29udGFpbmVyLmFwcGVuZChcbiAgICAgICAgICAgICAgICAkKHByZXZpZXdfc3ZnKS5jbG9uZSgpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICdzdmdfZHJhd2luZ19wcmV2aWV3JylcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKCBzZWN0aW9uX25hbWUgPT09IGFjdGl2ZV9zZWN0aW9uICl7XG4gICAgICAgICAgICAkKCcjc2VjdGlvbl8nK3NlY3Rpb25fbmFtZSkuY2hpbGRyZW4oJy5kcmF3ZXInKS5jaGlsZHJlbignLmRyYXdlcl9jb250ZW50Jykuc2xpZGVEb3duKCdmYXN0Jyk7XG5cbiAgICAgICAgfSBlbHNlIGlmKCAhIGcud2VicGFnZS5zZWxlY3Rpb25zX21hbnVhbF90b2dnbGVkW3NlY3Rpb25fbmFtZV0gKXtcbiAgICAgICAgICAgICQoJyNzZWN0aW9uXycrc2VjdGlvbl9uYW1lKS5jaGlsZHJlbignLmRyYXdlcicpLmNoaWxkcmVuKCcuZHJhd2VyX2NvbnRlbnQnKS5zbGlkZVVwKCdmYXN0Jyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvL0lmIHRoZSBsb2NhdGlvbiBpcyBkZWZpbmVkLCBvcGVuIHRoZSBtYXAuXG4gICAgLypcbiAgICBpZiggKCEgZy53ZWJwYWdlLnNlbGVjdGlvbnNfbWFudWFsX3RvZ2dsZWQubG9jYXRpb24pICYmICBnLmYuc2VjdGlvbl9kZWZpbmVkKGcsICdsb2NhdGlvbicpICl7XG4gICAgICAgICAgICAkKCcjc2VjdGlvbl9tYXAnKS5jaGlsZHJlbignLmRyYXdlcicpLmNoaWxkcmVuKCcuZHJhd2VyX2NvbnRlbnQnKS5zbGlkZURvd24oJ2Zhc3QnKTtcbiAgICB9XG4gICAgLy8qL1xuXG5cblxuXG5cbiAgICB2YXIgcDtcbiAgICAvKlxuICAgICQoJyNkcmF3aW5nX3ByZXZpZXcnKS5lbXB0eSgpO1xuICAgIGZvciggcCBpbiBmLm1rX3ByZXZpZXcgKXsgIC8vIGYubWtfc2hlZXRfbnVtIGlzIGEgYXJyYXkgb2YgcGFnZSBtYWtpbmcgZnVuY3Rpb25zLCBzbyB0aGlzIHdpbGwgbG9vcCB0aHJvdWdoIHRoZSBudW1iZXIgb2YgcGFnZXNcbiAgICAgICAgLy9zZXR0aW5ncy5kcmF3aW5nLnByZXZpZXdfc3Znc1twXSA9IGYubWtfc3ZnKHNldHRpbmdzLmRyYXdpbmcucHJldmlld19wYXJ0c1twXSwgc2V0dGluZ3MuZHJhd2luZ19zZXR0aW5ncyk7XG4gICAgICAgIHZhciBzZWN0aW9uID0gWycnLCdFbGVjdHJpY2FsJywnU3RydWN0dXJhbCddW3BdO1xuICAgICAgICAkKCcjZHJhd2luZ19wcmV2aWV3JylcbiAgICAgICAgICAgIC8vLmFwcGVuZCgkKCc8cD5QYWdlICcrcCsnPC9wPicpKVxuICAgICAgICAgICAgLmFwcGVuZCgkKCc8cD4nK3NlY3Rpb24rJzwvcD4nKSlcbiAgICAgICAgICAgIC5hcHBlbmQoJChzZXR0aW5ncy5kcmF3aW5nLnByZXZpZXdfc3Znc1twXSkpXG4gICAgICAgICAgICAuYXBwZW5kKCQoJzwvYnI+JykpXG4gICAgICAgICAgICAuYXBwZW5kKCQoJzwvYnI+JykpO1xuXG4gICAgfVxuICAgIC8vKi9cblxuICAgIC8vIEFkZCBkcmF3aW5nIHRvIHBhZ2VcbiAgICAkKCcjZHJhd2luZycpLmVtcHR5KCk7XG4gICAgZm9yKCBwIGluIHNldHRpbmdzLmRyYXdpbmcucGFydHMgKXsgIC8vIGYubWtfc2hlZXRfbnVtIGlzIGEgYXJyYXkgb2YgcGFnZSBtYWtpbmcgZnVuY3Rpb25zLCBzbyB0aGlzIHdpbGwgbG9vcCB0aHJvdWdoIHRoZSBudW1iZXIgb2YgcGFnZXNcbiAgICAgICAgc2V0dGluZ3MuZHJhd2luZy5zdmdzW3BdID0gZi5ta19zdmcoc2V0dGluZ3MuZHJhd2luZy5wYXJ0c1twXSwgc2V0dGluZ3MuZHJhd2luZ19zZXR0aW5ncyk7XG4gICAgICAgICQoJyNkcmF3aW5nJylcbiAgICAgICAgICAgIC8vLmFwcGVuZCgkKCc8cD5QYWdlICcrcCsnPC9wPicpKVxuICAgICAgICAgICAgLmFwcGVuZCgkKHNldHRpbmdzLmRyYXdpbmcuc3Znc1twXSkpXG4gICAgICAgICAgICAuYXBwZW5kKCQoJzwvYnI+JykpXG4gICAgICAgICAgICAuYXBwZW5kKCQoJzwvYnI+JykpO1xuXG4gICAgfVxuXG5cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSB1cGRhdGVfd2VicGFnZTtcbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4yXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjInO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gSGVscGVyIGZvciBjb2xsZWN0aW9uIG1ldGhvZHMgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBjb2xsZWN0aW9uXG4gIC8vIHNob3VsZCBiZSBpdGVyYXRlZCBhcyBhbiBhcnJheSBvciBhcyBhbiBvYmplY3RcbiAgLy8gUmVsYXRlZDogaHR0cDovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtdG9sZW5ndGhcbiAgdmFyIE1BWF9BUlJBWV9JTkRFWCA9IE1hdGgucG93KDIsIDUzKSAtIDE7XG4gIHZhciBpc0FycmF5TGlrZSA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbiAmJiBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSByZWR1Y2luZyBmdW5jdGlvbiBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cbiAgZnVuY3Rpb24gY3JlYXRlUmVkdWNlKGRpcikge1xuICAgIC8vIE9wdGltaXplZCBpdGVyYXRvciBmdW5jdGlvbiBhcyB1c2luZyBhcmd1bWVudHMubGVuZ3RoXG4gICAgLy8gaW4gdGhlIG1haW4gZnVuY3Rpb24gd2lsbCBkZW9wdGltaXplIHRoZSwgc2VlICMxOTkxLlxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xuICAgICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIC8vIERldGVybWluZSB0aGUgaW5pdGlhbCB2YWx1ZSBpZiBub25lIGlzIHByb3ZpZGVkLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBkaXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBjcmVhdGVSZWR1Y2UoMSk7XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gY3JlYXRlUmVkdWNlKC0xKTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIga2V5O1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBrZXkgPSBfLmZpbmRJbmRleChvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IF8uZmluZEtleShvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IC0xKSByZXR1cm4gb2JqW2tleV07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm5lZ2F0ZShjYihwcmVkaWNhdGUpKSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKCFwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiB2YWx1ZSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIHRhcmdldCwgZnJvbUluZGV4KSB7XG4gICAgaWYgKCFpc0FycmF5TGlrZShvYmopKSBvYmogPSBfLnZhbHVlcyhvYmopO1xuICAgIHJldHVybiBfLmluZGV4T2Yob2JqLCB0YXJnZXQsIHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicgJiYgZnJvbUluZGV4KSA+PSAwO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gZnVuYyA6IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8ucHJvcGVydHkoa2V5KSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IC1JbmZpbml0eSwgbGFzdENvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPiBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IC1JbmZpbml0eSAmJiByZXN1bHQgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGEgY29sbGVjdGlvbiwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBzZXQgPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0gc2V0Lmxlbmd0aDtcbiAgICB2YXIgc2h1ZmZsZWQgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgcmFuZDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJhbmQgPSBfLnJhbmRvbSgwLCBpbmRleCk7XG4gICAgICBpZiAocmFuZCAhPT0gaW5kZXgpIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSBzZXRbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTsgZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgZ3JvdXBCeWAsIGJ1dCBmb3JcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxuICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gIC8vIGNyaXRlcmlvbi5cbiAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaikgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICBfLnBhcnRpdGlvbiA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIgcGFzcyA9IFtdLCBmYWlsID0gW107XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7XG4gICAgICAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iaikgPyBwYXNzIDogZmFpbCkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIHJldHVybiBfLmluaXRpYWwoYXJyYXksIGFycmF5Lmxlbmd0aCAtIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfLnJlc3QoYXJyYXksIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIG4pKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgc3RhcnRJbmRleCkge1xuICAgIHZhciBvdXRwdXQgPSBbXSwgaWR4ID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwLCBsZW5ndGggPSBpbnB1dCAmJiBpbnB1dC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmIChfLmlzQXJyYXkodmFsdWUpIHx8IF8uaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICAvL2ZsYXR0ZW4gY3VycmVudCBsZXZlbCBvZiBhcnJheSBvciBhcmd1bWVudHMgb2JqZWN0XG4gICAgICAgIGlmICghc2hhbGxvdykgdmFsdWUgPSBmbGF0dGVuKHZhbHVlLCBzaGFsbG93LCBzdHJpY3QpO1xuICAgICAgICB2YXIgaiA9IDAsIGxlbiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgb3V0cHV0Lmxlbmd0aCArPSBsZW47XG4gICAgICAgIHdoaWxlIChqIDwgbGVuKSB7XG4gICAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlW2orK107XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCkge1xuICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgLy8gRmxhdHRlbiBvdXQgYW4gYXJyYXksIGVpdGhlciByZWN1cnNpdmVseSAoYnkgZGVmYXVsdCksIG9yIGp1c3Qgb25lIGxldmVsLlxuICBfLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSwgc2hhbGxvdykge1xuICAgIHJldHVybiBmbGF0dGVuKGFycmF5LCBzaGFsbG93LCBmYWxzZSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXG4gIF8ud2l0aG91dCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYXJyYXkuIElmIHRoZSBhcnJheSBoYXMgYWxyZWFkeVxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXG4gIC8vIEFsaWFzZWQgYXMgYHVuaXF1ZWAuXG4gIF8udW5pcSA9IF8udW5pcXVlID0gZnVuY3Rpb24oYXJyYXksIGlzU29ydGVkLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gW107XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KSA6IHZhbHVlO1xuICAgICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghXy5jb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gW107XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksICdsZW5ndGgnKS5sZW5ndGggfHwgMDtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBfLnBsdWNrKGFycmF5LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGlzdCAmJiBsaXN0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuICAvLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlzU29ydGVkKSB7XG4gICAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheSAmJiBhcnJheS5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBpc1NvcnRlZCA9PSAnbnVtYmVyJykge1xuICAgICAgaSA9IGlzU29ydGVkIDwgMCA/IE1hdGgubWF4KDAsIGxlbmd0aCArIGlzU29ydGVkKSA6IGlzU29ydGVkO1xuICAgIH0gZWxzZSBpZiAoaXNTb3J0ZWQgJiYgbGVuZ3RoKSB7XG4gICAgICBpID0gXy5zb3J0ZWRJbmRleChhcnJheSwgaXRlbSk7XG4gICAgICByZXR1cm4gYXJyYXlbaV0gPT09IGl0ZW0gPyBpIDogLTE7XG4gICAgfVxuICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICByZXR1cm4gXy5maW5kSW5kZXgoc2xpY2UuY2FsbChhcnJheSwgaSksIF8uaXNOYU4pO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBpZiAoYXJyYXlbaV0gPT09IGl0ZW0pIHJldHVybiBpO1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBfLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGZyb20pIHtcbiAgICB2YXIgaWR4ID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICAgIGlmICh0eXBlb2YgZnJvbSA9PSAnbnVtYmVyJykge1xuICAgICAgaWR4ID0gZnJvbSA8IDAgPyBpZHggKyBmcm9tICsgMSA6IE1hdGgubWluKGlkeCwgZnJvbSArIDEpO1xuICAgIH1cbiAgICBpZiAoaXRlbSAhPT0gaXRlbSkge1xuICAgICAgcmV0dXJuIF8uZmluZExhc3RJbmRleChzbGljZS5jYWxsKGFycmF5LCAwLCBpZHgpLCBfLmlzTmFOKTtcbiAgICB9XG4gICAgd2hpbGUgKC0taWR4ID49IDApIGlmIChhcnJheVtpZHhdID09PSBpdGVtKSByZXR1cm4gaWR4O1xuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBmaW5kSW5kZXggYW5kIGZpbmRMYXN0SW5kZXggZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZUluZGV4RmluZGVyKGRpcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ICE9IG51bGwgJiYgYXJyYXkubGVuZ3RoO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVJbmRleEZpbmRlcigxKTtcblxuICBfLmZpbmRMYXN0SW5kZXggPSBjcmVhdGVJbmRleEZpbmRlcigtMSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdGVlKG9iaik7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpO1xuICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W21pZF0pIDwgdmFsdWUpIGxvdyA9IG1pZCArIDE7IGVsc2UgaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhbiBpbnRlZ2VyIEFycmF5IGNvbnRhaW5pbmcgYW4gYXJpdGhtZXRpYyBwcm9ncmVzc2lvbi4gQSBwb3J0IG9mXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXG4gIC8vIFt0aGUgUHl0aG9uIGRvY3VtZW50YXRpb25dKGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS9mdW5jdGlvbnMuaHRtbCNyYW5nZSkuXG4gIF8ucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHN0b3AgPSBzdGFydCB8fCAwO1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCB8fCAxO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcbiAgICB2YXIgcmFuZ2UgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xuICAgICAgcmFuZ2VbaWR4XSA9IHN0YXJ0O1xuICAgIH1cblxuICAgIHJldHVybiByYW5nZTtcbiAgfTtcblxuICAvLyBGdW5jdGlvbiAoYWhlbSkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIERldGVybWluZXMgd2hldGhlciB0byBleGVjdXRlIGEgZnVuY3Rpb24gYXMgYSBjb25zdHJ1Y3RvclxuICAvLyBvciBhIG5vcm1hbCBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudHNcbiAgdmFyIGV4ZWN1dGVCb3VuZCA9IGZ1bmN0aW9uKHNvdXJjZUZ1bmMsIGJvdW5kRnVuYywgY29udGV4dCwgY2FsbGluZ0NvbnRleHQsIGFyZ3MpIHtcbiAgICBpZiAoIShjYWxsaW5nQ29udGV4dCBpbnN0YW5jZW9mIGJvdW5kRnVuYykpIHJldHVybiBzb3VyY2VGdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIHZhciBzZWxmID0gYmFzZUNyZWF0ZShzb3VyY2VGdW5jLnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IHNvdXJjZUZ1bmMuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgaWYgKF8uaXNPYmplY3QocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbiAgLy8gb3B0aW9uYWxseSkuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBGdW5jdGlvbi5iaW5kYCBpZlxuICAvLyBhdmFpbGFibGUuXG4gIF8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICBpZiAobmF0aXZlQmluZCAmJiBmdW5jLmJpbmQgPT09IG5hdGl2ZUJpbmQpIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgaWYgKCFfLmlzRnVuY3Rpb24oZnVuYykpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JpbmQgbXVzdCBiZSBjYWxsZWQgb24gYSBmdW5jdGlvbicpO1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgY29udGV4dCwgdGhpcywgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gUGFydGlhbGx5IGFwcGx5IGEgZnVuY3Rpb24gYnkgY3JlYXRpbmcgYSB2ZXJzaW9uIHRoYXQgaGFzIGhhZCBzb21lIG9mIGl0c1xuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gXyBhY3RzXG4gIC8vIGFzIGEgcGxhY2Vob2xkZXIsIGFsbG93aW5nIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMgdG8gYmUgcHJlLWZpbGxlZC5cbiAgXy5wYXJ0aWFsID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSAwLCBsZW5ndGggPSBib3VuZEFyZ3MubGVuZ3RoO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheShsZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBhcmdzW2ldID0gYm91bmRBcmdzW2ldID09PSBfID8gYXJndW1lbnRzW3Bvc2l0aW9uKytdIDogYm91bmRBcmdzW2ldO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgYXJndW1lbnRzLmxlbmd0aCkgYXJncy5wdXNoKGFyZ3VtZW50c1twb3NpdGlvbisrXSk7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCB0aGlzLCB0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcbiAgLy8gYXJlIHRoZSBtZXRob2QgbmFtZXMgdG8gYmUgYm91bmQuIFVzZWZ1bCBmb3IgZW5zdXJpbmcgdGhhdCBhbGwgY2FsbGJhY2tzXG4gIC8vIGRlZmluZWQgb24gYW4gb2JqZWN0IGJlbG9uZyB0byBpdC5cbiAgXy5iaW5kQWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGksIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGtleTtcbiAgICBpZiAobGVuZ3RoIDw9IDEpIHRocm93IG5ldyBFcnJvcignYmluZEFsbCBtdXN0IGJlIHBhc3NlZCBmdW5jdGlvbiBuYW1lcycpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gYXJndW1lbnRzW2ldO1xuICAgICAgb2JqW2tleV0gPSBfLmJpbmQob2JqW2tleV0sIG9iaik7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gTWVtb2l6ZSBhbiBleHBlbnNpdmUgZnVuY3Rpb24gYnkgc3RvcmluZyBpdHMgcmVzdWx0cy5cbiAgXy5tZW1vaXplID0gZnVuY3Rpb24oZnVuYywgaGFzaGVyKSB7XG4gICAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciBjYWNoZSA9IG1lbW9pemUuY2FjaGU7XG4gICAgICB2YXIgYWRkcmVzcyA9ICcnICsgKGhhc2hlciA/IGhhc2hlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDoga2V5KTtcbiAgICAgIGlmICghXy5oYXMoY2FjaGUsIGFkZHJlc3MpKSBjYWNoZVthZGRyZXNzXSA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBjYWNoZVthZGRyZXNzXTtcbiAgICB9O1xuICAgIG1lbW9pemUuY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gbWVtb2l6ZTtcbiAgfTtcblxuICAvLyBEZWxheXMgYSBmdW5jdGlvbiBmb3IgdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMsIGFuZCB0aGVuIGNhbGxzXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cbiAgXy5kZWxheSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSwgd2FpdCk7XG4gIH07XG5cbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXG4gIC8vIGNsZWFyZWQuXG4gIF8uZGVmZXIgPSBfLnBhcnRpYWwoXy5kZWxheSwgXywgMSk7XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLiBOb3JtYWxseSwgdGhlIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJ1blxuICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XG4gIC8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXG4gIC8vIGB7bGVhZGluZzogZmFsc2V9YC4gVG8gZGlzYWJsZSBleGVjdXRpb24gb24gdGhlIHRyYWlsaW5nIGVkZ2UsIGRpdHRvLlxuICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICBwcmV2aW91cyA9IG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UgPyAwIDogXy5ub3coKTtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IF8ubm93KCk7XG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xuICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwIHx8IHJlbWFpbmluZyA+IHdhaXQpIHtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICghdGltZW91dCAmJiBvcHRpb25zLnRyYWlsaW5nICE9PSBmYWxzZSkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4gIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcbiAgLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXG4gIC8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG4gIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgICB2YXIgdGltZW91dCwgYXJncywgY29udGV4dCwgdGltZXN0YW1wLCByZXN1bHQ7XG5cbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsYXN0ID0gXy5ub3coKSAtIHRpbWVzdGFtcDtcblxuICAgICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPj0gMCkge1xuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCAtIGxhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIGlmICghaW1tZWRpYXRlKSB7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB0aW1lc3RhbXAgPSBfLm5vdygpO1xuICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XG4gICAgICBpZiAoIXRpbWVvdXQpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgIGlmIChjYWxsTm93KSB7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXG4gIC8vIGNvbmRpdGlvbmFsbHkgZXhlY3V0ZSB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gXy5wYXJ0aWFsKHdyYXBwZXIsIGZ1bmMpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBuZWdhdGVkIHZlcnNpb24gb2YgdGhlIHBhc3NlZC1pbiBwcmVkaWNhdGUuXG4gIF8ubmVnYXRlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBhIGxpc3Qgb2YgZnVuY3Rpb25zLCBlYWNoXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXG4gIF8uY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSA9IHN0YXJ0O1xuICAgICAgdmFyIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB3aGlsZSAoaS0tKSByZXN1bHQgPSBhcmdzW2ldLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgb24gYW5kIGFmdGVyIHRoZSBOdGggY2FsbC5cbiAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgdXAgdG8gKGJ1dCBub3QgaW5jbHVkaW5nKSB0aGUgTnRoIGNhbGwuXG4gIF8uYmVmb3JlID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICB2YXIgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA+IDApIHtcbiAgICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aW1lcyA8PSAxKSBmdW5jID0gbnVsbDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93XG4gIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXG4gIF8ub25jZSA9IF8ucGFydGlhbChfLmJlZm9yZSwgMik7XG5cbiAgLy8gT2JqZWN0IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gS2V5cyBpbiBJRSA8IDkgdGhhdCB3b24ndCBiZSBpdGVyYXRlZCBieSBgZm9yIGtleSBpbiAuLi5gIGFuZCB0aHVzIG1pc3NlZC5cbiAgdmFyIGhhc0VudW1CdWcgPSAhe3RvU3RyaW5nOiBudWxsfS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcbiAgdmFyIG5vbkVudW1lcmFibGVQcm9wcyA9IFsndmFsdWVPZicsICdpc1Byb3RvdHlwZU9mJywgJ3RvU3RyaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAncHJvcGVydHlJc0VudW1lcmFibGUnLCAnaGFzT3duUHJvcGVydHknLCAndG9Mb2NhbGVTdHJpbmcnXTtcblxuICBmdW5jdGlvbiBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cykge1xuICAgIHZhciBub25FbnVtSWR4ID0gbm9uRW51bWVyYWJsZVByb3BzLmxlbmd0aDtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBvYmouY29uc3RydWN0b3I7XG4gICAgdmFyIHByb3RvID0gKF8uaXNGdW5jdGlvbihjb25zdHJ1Y3RvcikgJiYgY29uc3RydWN0b3IucHJvdG90eXBlKSB8fCBPYmpQcm90bztcblxuICAgIC8vIENvbnN0cnVjdG9yIGlzIGEgc3BlY2lhbCBjYXNlLlxuICAgIHZhciBwcm9wID0gJ2NvbnN0cnVjdG9yJztcbiAgICBpZiAoXy5oYXMob2JqLCBwcm9wKSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkga2V5cy5wdXNoKHByb3ApO1xuXG4gICAgd2hpbGUgKG5vbkVudW1JZHgtLSkge1xuICAgICAgcHJvcCA9IG5vbkVudW1lcmFibGVQcm9wc1tub25FbnVtSWR4XTtcbiAgICAgIGlmIChwcm9wIGluIG9iaiAmJiBvYmpbcHJvcF0gIT09IHByb3RvW3Byb3BdICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSB7XG4gICAgICAgIGtleXMucHVzaChwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcbiAgXy5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICBpZiAobmF0aXZlS2V5cykgcmV0dXJuIG5hdGl2ZUtleXMob2JqKTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIGFsbCB0aGUgcHJvcGVydHkgbmFtZXMgb2YgYW4gb2JqZWN0LlxuICBfLmFsbEtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHRzIG9mIGFwcGx5aW5nIHRoZSBpdGVyYXRlZSB0byBlYWNoIGVsZW1lbnQgb2YgdGhlIG9iamVjdFxuICAvLyBJbiBjb250cmFzdCB0byBfLm1hcCBpdCByZXR1cm5zIGFuIG9iamVjdFxuICBfLm1hcE9iamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHRzID0ge30sXG4gICAgICAgICAgY3VycmVudEtleTtcbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY3VycmVudEtleSA9IGtleXNbaW5kZXhdO1xuICAgICAgICByZXN1bHRzW2N1cnJlbnRLZXldID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ29udmVydCBhbiBvYmplY3QgaW50byBhIGxpc3Qgb2YgYFtrZXksIHZhbHVlXWAgcGFpcnMuXG4gIF8ucGFpcnMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgcGFpcnMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhaXJzW2ldID0gW2tleXNbaV0sIG9ialtrZXlzW2ldXV07XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbiAgfTtcblxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXG4gIF8uaW52ZXJ0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSBzb3J0ZWQgbGlzdCBvZiB0aGUgZnVuY3Rpb24gbmFtZXMgYXZhaWxhYmxlIG9uIHRoZSBvYmplY3QuXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXG4gIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcbiAgfTtcblxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cbiAgXy5leHRlbmQgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMpO1xuXG4gIC8vIEFzc2lnbnMgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIG93biBwcm9wZXJ0aWVzIGluIHRoZSBwYXNzZWQtaW4gb2JqZWN0KHMpXG4gIC8vIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduKVxuICBfLmV4dGVuZE93biA9IF8uYXNzaWduID0gY3JlYXRlQXNzaWduZXIoXy5rZXlzKTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBrZXkgb24gYW4gb2JqZWN0IHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kS2V5ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaiksIGtleTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2tleV0sIGtleSwgb2JqKSkgcmV0dXJuIGtleTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5waWNrID0gZnVuY3Rpb24ob2JqZWN0LCBvaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIG9iaiA9IG9iamVjdCwgaXRlcmF0ZWUsIGtleXM7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChfLmlzRnVuY3Rpb24ob2l0ZXJhdGVlKSkge1xuICAgICAga2V5cyA9IF8uYWxsS2V5cyhvYmopO1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKG9pdGVyYXRlZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleXMgPSBmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7IHJldHVybiBrZXkgaW4gb2JqOyB9O1xuICAgICAgb2JqID0gT2JqZWN0KG9iaik7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgaWYgKGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iaikpIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCB3aXRob3V0IHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLm9taXQgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcbiAgICAgIGl0ZXJhdGVlID0gXy5uZWdhdGUoaXRlcmF0ZWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IF8ubWFwKGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpLCBTdHJpbmcpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJldHVybiAhXy5jb250YWlucyhrZXlzLCBrZXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIF8ucGljayhvYmosIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgfTtcblxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBfLmRlZmF1bHRzID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzLCB0cnVlKTtcblxuICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXG4gIF8uY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuICB9O1xuXG4gIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai5cbiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG4gIC8vIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICBfLnRhcCA9IGZ1bmN0aW9uKG9iaiwgaW50ZXJjZXB0b3IpIHtcbiAgICBpbnRlcmNlcHRvcihvYmopO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2YgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uaXNNYXRjaCA9IGZ1bmN0aW9uKG9iamVjdCwgYXR0cnMpIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhhdHRycyksIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkgcmV0dXJuICFsZW5ndGg7XG4gICAgdmFyIG9iaiA9IE9iamVjdChvYmplY3QpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKGF0dHJzW2tleV0gIT09IG9ialtrZXldIHx8ICEoa2V5IGluIG9iaikpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cblxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxuICB2YXIgZXEgPSBmdW5jdGlvbihhLCBiLCBhU3RhY2ssIGJTdGFjaykge1xuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICAgIC8vIEEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYC5cbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXG4gICAgaWYgKGEgaW5zdGFuY2VvZiBfKSBhID0gYS5fd3JhcHBlZDtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIF8pIGIgPSBiLl93cmFwcGVkO1xuICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXG4gICAgdmFyIGNsYXNzTmFtZSA9IHRvU3RyaW5nLmNhbGwoYSk7XG4gICAgaWYgKGNsYXNzTmFtZSAhPT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCByZWd1bGFyIGV4cHJlc3Npb25zLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb2VyY2VkIHRvIHN0cmluZ3MgZm9yIGNvbXBhcmlzb24gKE5vdGU6ICcnICsgL2EvaSA9PT0gJy9hL2knKVxuICAgICAgY2FzZSAnW29iamVjdCBTdHJpbmddJzpcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byBgbmV3IFN0cmluZyhcIjVcIilgLlxuICAgICAgICByZXR1cm4gJycgKyBhID09PSAnJyArIGI7XG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxuICAgICAgICAvLyBgTmFOYHMgYXJlIGVxdWl2YWxlbnQsIGJ1dCBub24tcmVmbGV4aXZlLlxuICAgICAgICAvLyBPYmplY3QoTmFOKSBpcyBlcXVpdmFsZW50IHRvIE5hTlxuICAgICAgICBpZiAoK2EgIT09ICthKSByZXR1cm4gK2IgIT09ICtiO1xuICAgICAgICAvLyBBbiBgZWdhbGAgY29tcGFyaXNvbiBpcyBwZXJmb3JtZWQgZm9yIG90aGVyIG51bWVyaWMgdmFsdWVzLlxuICAgICAgICByZXR1cm4gK2EgPT09IDAgPyAxIC8gK2EgPT09IDEgLyBiIDogK2EgPT09ICtiO1xuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICBjYXNlICdbb2JqZWN0IEJvb2xlYW5dJzpcbiAgICAgICAgLy8gQ29lcmNlIGRhdGVzIGFuZCBib29sZWFucyB0byBudW1lcmljIHByaW1pdGl2ZSB2YWx1ZXMuIERhdGVzIGFyZSBjb21wYXJlZCBieSB0aGVpclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXG4gICAgICAgIC8vIG9mIGBOYU5gIGFyZSBub3QgZXF1aXZhbGVudC5cbiAgICAgICAgcmV0dXJuICthID09PSArYjtcbiAgICB9XG5cbiAgICB2YXIgYXJlQXJyYXlzID0gY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIGlmICghYXJlQXJyYXlzKSB7XG4gICAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzIG9yIGBBcnJheWBzXG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgYUN0b3IgaW5zdGFuY2VvZiBhQ3RvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNGdW5jdGlvbihiQ3RvcikgJiYgYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgKCdjb25zdHJ1Y3RvcicgaW4gYSAmJiAnY29uc3RydWN0b3InIGluIGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxuICAgIFxuICAgIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAvLyBJdCdzIGRvbmUgaGVyZSBzaW5jZSB3ZSBvbmx5IG5lZWQgdGhlbSBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIGNvbXBhcmlzb24uXG4gICAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICAgIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGFyZUFycmF5cykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghZXEoYVtsZW5ndGhdLCBiW2xlbmd0aF0sIGFTdGFjaywgYlN0YWNrKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKGEpLCBrZXk7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICAgIGlmIChfLmtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgICAga2V5ID0ga2V5c1tsZW5ndGhdO1xuICAgICAgICBpZiAoIShfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYik7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikgJiYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSB8fCBfLmlzQXJndW1lbnRzKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICByZXR1cm4gXy5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9O1xuXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLCBpc0Vycm9yLlxuICBfLmVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCcsICdFcnJvciddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUgPCA5KSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5oYXMob2JqLCAnY2FsbGVlJyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS4gV29yayBhcm91bmQgc29tZSB0eXBlb2YgYnVncyBpbiBvbGQgdjgsXG4gIC8vIElFIDExICgjMTYyMSksIGFuZCBpbiBTYWZhcmkgOCAoIzE5MjkpLlxuICBpZiAodHlwZW9mIC8uLyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiBJbnQ4QXJyYXkgIT0gJ29iamVjdCcpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgb2JqICE9PSArb2JqO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBQcmVkaWNhdGUtZ2VuZXJhdGluZyBmdW5jdGlvbnMuIE9mdGVuIHVzZWZ1bCBvdXRzaWRlIG9mIFVuZGVyc2NvcmUuXG4gIF8uY29uc3RhbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xuXG4gIF8ubm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuICBfLnByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZXMgYSBmdW5jdGlvbiBmb3IgYSBnaXZlbiBvYmplY3QgdGhhdCByZXR1cm5zIGEgZ2l2ZW4gcHJvcGVydHkuXG4gIF8ucHJvcGVydHlPZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT0gbnVsbCA/IGZ1bmN0aW9uKCl7fSA6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIHByZWRpY2F0ZSBmb3IgY2hlY2tpbmcgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIFxuICAvLyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVyID0gXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICBhdHRycyA9IF8uZXh0ZW5kT3duKHt9LCBhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaXNNYXRjaChvYmosIGF0dHJzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWNjdW0gPSBBcnJheShNYXRoLm1heCgwLCBuKSk7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRlZShpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH07XG5cbiAgLy8gQSAocG9zc2libHkgZmFzdGVyKSB3YXkgdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyLlxuICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVzY2FwZU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICdgJzogJyYjeDYwOydcbiAgfTtcbiAgdmFyIHVuZXNjYXBlTWFwID0gXy5pbnZlcnQoZXNjYXBlTWFwKTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIHZhciBjcmVhdGVFc2NhcGVyID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hcFttYXRjaF07XG4gICAgfTtcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWRcbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBfLmtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XG4gICAgdmFyIHRlc3RSZWdleHAgPSBSZWdFeHAoc291cmNlKTtcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG4gIF8udW5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcblxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxuICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBmYWxsYmFjaykge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0W3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBmYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XG4gICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlciwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbi4gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGluc3RhbmNlID0gXyhvYmopO1xuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihpbnN0YW5jZSwgb2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKChuYW1lID09PSAnc2hpZnQnIHx8IG5hbWUgPT09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBvYmopO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICBfLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94eSBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbiAgXy5wcm90b3R5cGUudmFsdWVPZiA9IF8ucHJvdG90eXBlLnRvSlNPTiA9IF8ucHJvdG90eXBlLnZhbHVlO1xuICBcbiAgXy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJycgKyB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIEFNRCByZWdpc3RyYXRpb24gaGFwcGVucyBhdCB0aGUgZW5kIGZvciBjb21wYXRpYmlsaXR5IHdpdGggQU1EIGxvYWRlcnNcbiAgLy8gdGhhdCBtYXkgbm90IGVuZm9yY2UgbmV4dC10dXJuIHNlbWFudGljcyBvbiBtb2R1bGVzLiBFdmVuIHRob3VnaCBnZW5lcmFsXG4gIC8vIHByYWN0aWNlIGZvciBBTUQgcmVnaXN0cmF0aW9uIGlzIHRvIGJlIGFub255bW91cywgdW5kZXJzY29yZSByZWdpc3RlcnNcbiAgLy8gYXMgYSBuYW1lZCBtb2R1bGUgYmVjYXVzZSwgbGlrZSBqUXVlcnksIGl0IGlzIGEgYmFzZSBsaWJyYXJ5IHRoYXQgaXNcbiAgLy8gcG9wdWxhciBlbm91Z2ggdG8gYmUgYnVuZGxlZCBpbiBhIHRoaXJkIHBhcnR5IGxpYiwgYnV0IG5vdCBiZSBwYXJ0IG9mXG4gIC8vIGFuIEFNRCBsb2FkIHJlcXVlc3QuIFRob3NlIGNhc2VzIGNvdWxkIGdlbmVyYXRlIGFuIGVycm9yIHdoZW4gYW5cbiAgLy8gYW5vbnltb3VzIGRlZmluZSgpIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGEgbG9hZGVyIHJlcXVlc3QuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoJ3VuZGVyc2NvcmUnLCBbXSwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXztcbiAgICB9KTtcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG4vLyBTZXR1cFxuICAgIC8vIExvYWQgYW5kIGNyZWF0ZSBtYWluIHNldHRpbmdzLCBhbmQgc2F2ZSB0aGVtIHRvIHRoZSByb290IGdsb2JhbCBvYmplY3QuXG4gICAgdmFyIG1rX3NldHRpbmdzID0gcmVxdWlyZSgnLi9tb2R1bGVzL21rX3NldHRpbmdzJyk7XG4gICAgd2luZG93LmcgPSBta19zZXR0aW5ncygpO1xuXG4gICAgY29uc29sZS5sb2coJ3NldHRpbmdzJywgZyk7XG5cblxuICAgIC8vdmFyIHZlcnNpb25fc3RyaW5nID0gJ0Rldic7XG4gICAgLy92YXIgdmVyc2lvbl9zdHJpbmcgPSAnQWxwaGEyMDE0MDEtLSc7XG4gICAgdmFyIHZlcnNpb25fc3RyaW5nID0gJ1ByZXZpZXcnK21vbWVudCgpLmZvcm1hdCgnWVlZWU1NREQnKTtcbiAgICBnLnN0YXRlLnZlcnNpb25fc3RyaW5nID0gdmVyc2lvbl9zdHJpbmc7XG4gICAgLy8gTG9hZCBhbmQgVVJMIHF1ZXJ5IHZhcmlhYmxlc1xuICAgIHZhciBxdWVyeSA9IGcuZi5xdWVyeV9zdHJpbmcoKTtcbiAgICAvL2NvbnNvbGUubG9nKHF1ZXJ5KTtcblxuICAgIHZhciB1cGRhdGVfd2VicGFnZSA9IHJlcXVpcmUoJy4vbW9kdWxlcy91cGRhdGVfd2VicGFnZScpO1xuXG4gICAgZy5mLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IGc7XG4gICAgICAgIHZhciBmID0gZy5mO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCcvLS0tIGJlZ2luIHVwZGF0ZScpO1xuICAgICAgICBnLmYuY2xlYXJfZHJhd2luZygpO1xuXG4gICAgICAgIHNldHRpbmdzLnNlbGVjdF9yZWdpc3RyeS5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgICAgICAgIGlmKHNlbGVjdG9yLnZhbHVlKCkpIHNlbGVjdG9yLmlucHV0X3JlZi5zZXQoc2VsZWN0b3IudmFsdWUoKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJlY2FsY3VsYXRlIHN5c3RlbSBzZXR0aW5nc1xuICAgICAgICBnLmYucHJvY2VzcyhzZXR0aW5ncyk7XG5cbiAgICAgICAgdXBkYXRlX3dlYnBhZ2UoKTtcblxuICAgICAgICBjb25zb2xlLmxvZygnXFxcXC0tLSBlbmQgdXBkYXRlJyk7XG4gICAgfTtcblxuXG4vLyByZXF1ZXN0IGV4dGVybmFsIGRhdGFcblxuICAgIHZhciBuZXd0d29ya190ZXN0ID0gZmFsc2U7XG5cbiAgICBnLmYucmVxdWVzdF9TVkcgPSBmdW5jdGlvbigpe1xuICAgIC8vKlxuICAgICAgICBjb25zb2xlLmxvZygnc2VuZGluZyBkYXRhIHRvIHNlcnZlcicpO1xuICAgICAgICB2YXIgdXJsID0gJ2h0dHA6Ly9sb2NhbGhvc3Q6NDIzMy9wbGFuc19tYWNoaW5lJztcbiAgICAgICAgdmFyIHVzZXJfaW5wdXRfanNvbiA9IEpTT04uc3RyaW5naWZ5KGcudXNlcl9pbnB1dCk7XG4gICAgICAgIHZhciBkYXRhID0geyB1c2VyX2lucHV0X2pzb246IHVzZXJfaW5wdXRfanNvbn07XG4gICAgICAgIC8vdmFyIGRhdGEgPSB7XG4gICAgICAgIC8vICAgIHRlc3Q6NDIsXG4gICAgICAgIC8vICAgIHRlc3QyOjIzLFxuICAgICAgICAvL307XG4gICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmRvbmUoZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnc2VydmVyIHJlc3BvbmNlPycsIHJlcyk7XG5cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZmFpbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyggJ2Vycm9yJyApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5hbHdheXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coICdjb21wbGV0ZScgKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgfTtcblxuICAgIC8vdmFyIGRhdGFiYXNlX2pzb25fVVJMID0gJ2h0dHA6Ly8xMC4xNzMuNjQuMjA0OjgwMDAvdGVtcG9yYXJ5Lyc7XG4gICAgdmFyIGRhdGFiYXNlX2pzb25fVVJMID0gJ2RhdGEvZnNlY19jb3B5Lmpzb24nO1xuICAgICQuZ2V0SlNPTiggZGF0YWJhc2VfanNvbl9VUkwpXG4gICAgICAgIC5kb25lKGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgZy5GU0VDX2RhdGFiYXNlID0gZGF0YTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ2RhdGFiYXNlIGxvYWRlZCcsIHNldHRpbmdzLmRhdGFiYXNlKTtcbiAgICAgICAgICAgIGcuY29tcG9uZW50cyA9IGcuZi5sb2FkX2RhdGFiYXNlKGRhdGEpO1xuICAgICAgICAgICAgZy5zdGF0ZS5kYXRhYmFzZV9sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYoIGcuc3RhdGUubW9kZSA9PT0gJ2Rldicpe1xuICAgICAgICAgICAgICAgIGcuZi5zZXR0aW5nc19kZXZfZGVmYXVsdHMoZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnLmYudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIC8vLy8vLy8vXG4gICAgICAgICAgICAvLyBURU1QXG4gICAgICAgICAgICAvL2cuZi5yZXF1ZXN0X1NWRygpO1xuICAgICAgICAgICAgLy8vLy8vLy9cbiAgICAgICAgfSk7XG5cblxuLy8gQnVpbGQgd2VicGFnZVxuXG4gICAgLy8gU2V0IGRldiBtb2RlIGlmIHJlcXVlc3RlZFxuICAgIGlmKCBxdWVyeVsnbW9kZSddID09PSAnZGV2JyApIHtcbiAgICAgICAgZy5zdGF0ZS5tb2RlID0gJ2Rldic7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZy5zdGF0ZS5tb2RlID0gJ3JlbGVhc2UnO1xuICAgIH1cblxuICAgIGlmKCBxdWVyeVsncGFzc3dvcmQnXSA9PT0gJ3NkNzIzc2ZrYmdyOHlyJyApIHtcbiAgICAgICAgZy5zdGF0ZS5wYXNzd29yZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZy5zdGF0ZS5wYXNzd29yZCA9IGZhbHNlO1xuICAgIH1cblxuXG4gICAgaWYoIGcuc3RhdGUubW9kZSA9PT0gJ2RldicgKXtcbiAgICAgICAgZy5mLnNldHRpbmdzX2Rldl9kZWZhdWx0cyhnKTtcbiAgICB9XG5cbiAgICBpZiggZy5zdGF0ZS5wYXNzd29yZCB8fCBxdWVyeVsnbW9kZSddID09PSAnZGV2JyApe1xuICAgICAgICBnLmYuc2V0dXBfd2VicGFnZSgpO1xuXG4gICAgICAgIC8vIEFkZCBzdGF0dXMgYmFyXG4gICAgICAgIHZhciBib290X3RpbWUgPSBtb21lbnQoKTtcbiAgICAgICAgdmFyIHN0YXR1c19pZCA9ICdzdGF0dXMnO1xuICAgICAgICBzZXRJbnRlcnZhbChmdW5jdGlvbigpeyBnLmYudXBkYXRlX3N0YXR1c19iYXIoc3RhdHVzX2lkLCBib290X3RpbWUsIHZlcnNpb25fc3RyaW5nKTt9LDEwMDApO1xuXG4gICAgICAgIGcuZi51cGRhdGUoKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdubyBwYXNzd29yZCcpO1xuICAgICAgICAkKCc8aW1nPicpXG4gICAgICAgICAgICAuYXR0cignc3JjJywgJ2RhdGEvUGxhbnNNYWNoaW5lLnBuZycpXG4gICAgICAgICAgICAvLy5hdHRyKCdjbGFzcycsICd0aXRsZV9pbWFnZScpXG4gICAgICAgICAgICAuY3NzKCd3aWR0aCcsICczMDBweCcpXG4gICAgICAgICAgICAuY3NzKCdwYWRkaW5nJywgJzMwcHgnKVxuICAgICAgICAgICAgLmNzcygnZGlzcGxheScsICdibG9jaycpXG4gICAgICAgICAgICAuY3NzKCdtYXJnaW4tbGVmdCcsICdhdXRvJylcbiAgICAgICAgICAgIC5jc3MoJ21hcmdpbi1yaWdodCcsICdhdXRvJylcbiAgICAgICAgICAgIC5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgJCgnPGRpdj4nKVxuICAgICAgICAgICAgLmF0dHIoJ3N0eWxlJywgJ3RleHQtYWxpZ246IGNlbnRlcicpXG4gICAgICAgICAgICAuaHRtbCgnUGFzc3dvcmQgcmVxdWlyZWQgZm9yIGRlbW8nKVxuICAgICAgICAgICAgLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xuICAgIH1cbiJdfQ==
